<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/webpack/webpack">webpack (v2.4.1)</a>
</h1>
<h4>Packs CommonJs/AMD modules for the browser. Allows to split your codebase into multiple bundles, which can be loaded on demand. Support loaders to preprocess files, i.e. json, jsx, es7, css, less, ... and your custom stuff.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack">module webpack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack">
            function <span class="apidocSignatureSpan"></span>webpack
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.AutomaticPrefetchPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>AutomaticPrefetchPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.BannerPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>BannerPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.CachePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>CachePlugin
            <span class="apidocSignatureSpan">(cache)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler">
            function <span class="apidocSignatureSpan">webpack.</span>Compiler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching">
            function <span class="apidocSignatureSpan">webpack.</span>Compiler.Watching
            <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextModuleFactory">
            function <span class="apidocSignatureSpan">webpack.</span>ContextModuleFactory
            <span class="apidocSignatureSpan">(resolvers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextReplacementPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ContextReplacementPlugin
            <span class="apidocSignatureSpan">(resourceRegExp, newContentResource, newContentRecursive, newContentRegExp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DefinePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>DefinePlugin
            <span class="apidocSignatureSpan">(definitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Dependency">
            function <span class="apidocSignatureSpan">webpack.</span>Dependency
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DllPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>DllPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DllReferencePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>DllReferencePlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DynamicEntryPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>DynamicEntryPlugin
            <span class="apidocSignatureSpan">(context, entry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.EnvironmentPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>EnvironmentPlugin
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.EvalDevToolModulePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>EvalDevToolModulePlugin
            <span class="apidocSignatureSpan">(sourceUrlComment, moduleFilenameTemplate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.EvalSourceMapDevToolPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>EvalSourceMapDevToolPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ExtendedAPIPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ExtendedAPIPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ExternalsPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ExternalsPlugin
            <span class="apidocSignatureSpan">(type, externals)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.HashedModuleIdsPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>HashedModuleIdsPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.HotModuleReplacementPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>HotModuleReplacementPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.IgnorePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>IgnorePlugin
            <span class="apidocSignatureSpan">(resourceRegExp, contextRegExp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.JsonpTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>JsonpTemplatePlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.LibraryTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>LibraryTemplatePlugin
            <span class="apidocSignatureSpan">(name, target, umdNamedDefine, auxiliaryComment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.LoaderOptionsPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>LoaderOptionsPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.LoaderTargetPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>LoaderTargetPlugin
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem">
            function <span class="apidocSignatureSpan">webpack.</span>MemoryOutputFileSystem
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler">
            function <span class="apidocSignatureSpan">webpack.</span>MultiCompiler
            <span class="apidocSignatureSpan">(compilers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NamedChunksPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NamedChunksPlugin
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NamedModulesPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NamedModulesPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NewWatchingPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NewWatchingPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NoEmitOnErrorsPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NoEmitOnErrorsPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NoErrorsPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NoErrorsPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NodeEnvironmentPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NodeEnvironmentPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NormalModuleReplacementPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NormalModuleReplacementPlugin
            <span class="apidocSignatureSpan">(resourceRegExp, newResource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.PrefetchPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>PrefetchPlugin
            <span class="apidocSignatureSpan">(context, request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ProgressPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ProgressPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ProvidePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ProvidePlugin
            <span class="apidocSignatureSpan">(definitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.SetVarMainTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>SetVarMainTemplatePlugin
            <span class="apidocSignatureSpan">(varExpression, copyObject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.SourceMapDevToolPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>SourceMapDevToolPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.UmdMainTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>UmdMainTemplatePlugin
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.WatchIgnorePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>WatchIgnorePlugin
            <span class="apidocSignatureSpan">(paths)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.WebpackOptionsApply">
            function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsApply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.WebpackOptionsDefaulter">
            function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsDefaulter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.WebpackOptionsValidationError">
            function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsValidationError
            <span class="apidocSignatureSpan">(validationErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.validate">
            function <span class="apidocSignatureSpan">webpack.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.validateSchema">
            function <span class="apidocSignatureSpan">webpack.</span>validateSchema
            <span class="apidocSignatureSpan">(schema, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web">
            function <span class="apidocSignatureSpan">webpack.</span>webpack_web
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>Compiler.Watching.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>Compiler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>ContextModuleFactory.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>ErrorHelpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>HotModuleReplacementPlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>MemoryOutputFileSystem.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>ModuleFilenameHelpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>MultiCompiler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>ParserHelpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>SizeFormatHelpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>dependencies</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>optimize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>system</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Compiler">module webpack.Compiler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Compiler">
            function <span class="apidocSignatureSpan">webpack.</span>Compiler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching">
            function <span class="apidocSignatureSpan">webpack.Compiler.</span>Watching
            <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Compiler.Watching">module webpack.Compiler.Watching</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.Watching">
            function <span class="apidocSignatureSpan">webpack.Compiler.</span>Watching
            <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Compiler.Watching.prototype">module webpack.Compiler.Watching.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.prototype._done">
            function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>_done
            <span class="apidocSignatureSpan">(err, compilation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.prototype._go">
            function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>_go
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.prototype.close">
            function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.prototype.invalidate">
            function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>invalidate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.prototype.watch">
            function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>watch
            <span class="apidocSignatureSpan">(files, dirs, missing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Compiler.prototype">module webpack.Compiler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.compile">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>compile
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.createChildCompiler">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createChildCompiler
            <span class="apidocSignatureSpan">(compilation, compilerName, outputOptions, plugins)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.createCompilation">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createCompilation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.createContextModuleFactory">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createContextModuleFactory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.createNormalModuleFactory">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createNormalModuleFactory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.emitAssets">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>emitAssets
            <span class="apidocSignatureSpan">(compilation, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.emitRecords">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>emitRecords
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.isChild">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>isChild
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.newCompilation">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>newCompilation
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.newCompilationParams">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>newCompilationParams
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.purgeInputFileSystem">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>purgeInputFileSystem
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.readRecords">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>readRecords
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.run">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>run
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.runAsChild">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>runAsChild
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.watch">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>watch
            <span class="apidocSignatureSpan">(watchOptions, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ContextModuleFactory">module webpack.ContextModuleFactory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextModuleFactory.ContextModuleFactory">
            function <span class="apidocSignatureSpan">webpack.</span>ContextModuleFactory
            <span class="apidocSignatureSpan">(resolvers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ContextModuleFactory.prototype">module webpack.ContextModuleFactory.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextModuleFactory.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>constructor
            <span class="apidocSignatureSpan">(resolvers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextModuleFactory.prototype.create">
            function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextModuleFactory.prototype.resolveDependencies">
            function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>resolveDependencies
            <span class="apidocSignatureSpan">(fs, resource, recursive, regExp, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Dependency">module webpack.Dependency</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Dependency.Dependency">
            function <span class="apidocSignatureSpan">webpack.</span>Dependency
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Dependency.compare">
            function <span class="apidocSignatureSpan">webpack.Dependency.</span>compare
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.DynamicEntryPlugin">module webpack.DynamicEntryPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DynamicEntryPlugin.DynamicEntryPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>DynamicEntryPlugin
            <span class="apidocSignatureSpan">(context, entry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DynamicEntryPlugin.createDependency">
            function <span class="apidocSignatureSpan">webpack.DynamicEntryPlugin.</span>createDependency
            <span class="apidocSignatureSpan">(entry, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ErrorHelpers">module webpack.ErrorHelpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ErrorHelpers.cleanUp">
            function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cleanUp
            <span class="apidocSignatureSpan">(stack, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ErrorHelpers.cutOffLoaderExecution">
            function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cutOffLoaderExecution
            <span class="apidocSignatureSpan">(stack)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ErrorHelpers.cutOffMessage">
            function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cutOffMessage
            <span class="apidocSignatureSpan">(stack, message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.HotModuleReplacementPlugin">module webpack.HotModuleReplacementPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.HotModuleReplacementPlugin.HotModuleReplacementPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>HotModuleReplacementPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.HotModuleReplacementPlugin.prototype">module webpack.HotModuleReplacementPlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.HotModuleReplacementPlugin.prototype.apply">
            function <span class="apidocSignatureSpan">webpack.HotModuleReplacementPlugin.prototype.</span>apply
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.MemoryOutputFileSystem">module webpack.MemoryOutputFileSystem</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.MemoryOutputFileSystem">
            function <span class="apidocSignatureSpan">webpack.</span>MemoryOutputFileSystem
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.MemoryOutputFileSystem.prototype">module webpack.MemoryOutputFileSystem.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype._remove">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>_remove
            <span class="apidocSignatureSpan">(_path, name, testFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.createReadStream">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>createReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.createWriteStream">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>createWriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.exists">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>exists
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.existsSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>existsSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.join">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>join
            <span class="apidocSignatureSpan">(path, request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.meta">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>meta
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdir">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdir
            <span class="apidocSignatureSpan">(path, optArg, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirp">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirp
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirpSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirpSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.normalize">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>normalize
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.pathToArray">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>pathToArray
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFile">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readFile
            <span class="apidocSignatureSpan">(path, optArg, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFileSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readFileSync
            <span class="apidocSignatureSpan">(_path, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdir">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readdir
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdirSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readdirSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlink">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readlink
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlinkSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readlinkSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdir">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>rmdir
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdirSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>rmdirSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.stat">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>stat
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.statSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>statSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlink">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>unlink
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlinkSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>unlinkSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFile">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>writeFile
            <span class="apidocSignatureSpan">(path, content, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFileSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>writeFileSync
            <span class="apidocSignatureSpan">(_path, content, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ModuleFilenameHelpers">module webpack.ModuleFilenameHelpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ModuleFilenameHelpers.createFilename">
            function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>createFilename
            <span class="apidocSignatureSpan">(module, moduleFilenameTemplate, requestShortener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ModuleFilenameHelpers.createFooter">
            function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>createFooter
            <span class="apidocSignatureSpan">(module, requestShortener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ModuleFilenameHelpers.matchObject">
            function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>matchObject
            <span class="apidocSignatureSpan">(obj, str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ModuleFilenameHelpers.matchPart">
            function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>matchPart
            <span class="apidocSignatureSpan">(str, test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ModuleFilenameHelpers.replaceDuplicates">
            function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>replaceDuplicates
            <span class="apidocSignatureSpan">(array, fn, comparator)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_ABSOLUTE_RESOURCE_PATH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_ALL_LOADERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_ALL_LOADERS_RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_HASH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_ID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_LOADERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_LOADERS_RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_QUERY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_RESOURCE_PATH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>ABSOLUTE_RESOURCE_PATH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>ALL_LOADERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>ALL_LOADERS_RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>HASH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>ID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>LOADERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>LOADERS_RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>QUERY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>RESOURCE_PATH</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.MultiCompiler">module webpack.MultiCompiler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler.MultiCompiler">
            function <span class="apidocSignatureSpan">webpack.</span>MultiCompiler
            <span class="apidocSignatureSpan">(compilers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.MultiCompiler.prototype">module webpack.MultiCompiler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>constructor
            <span class="apidocSignatureSpan">(compilers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler.prototype.purgeInputFileSystem">
            function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>purgeInputFileSystem
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler.prototype.run">
            function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>run
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler.prototype.watch">
            function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>watch
            <span class="apidocSignatureSpan">(watchOptions, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ParserHelpers">module webpack.ParserHelpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.addParsedVariableToModule">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>addParsedVariableToModule
            <span class="apidocSignatureSpan">(parser, name, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.approve">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>approve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.evaluateToBoolean">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>evaluateToBoolean
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.evaluateToString">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>evaluateToString
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.expressionIsUnsupported">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>expressionIsUnsupported
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.requireFileAsExpression">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>requireFileAsExpression
            <span class="apidocSignatureSpan">(context, pathToModule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.skipTraversal">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>skipTraversal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.toConstantDependency">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>toConstantDependency
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.SizeFormatHelpers">module webpack.SizeFormatHelpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.SizeFormatHelpers.formatSize">
            function <span class="apidocSignatureSpan">webpack.SizeFormatHelpers.</span>formatSize
            <span class="apidocSignatureSpan">(size &lt;= 0)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.optimize">module webpack.optimize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.AggressiveMergingPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>AggressiveMergingPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.AggressiveSplittingPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>AggressiveSplittingPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.ChunkModuleIdRangePlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>ChunkModuleIdRangePlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.CommonsChunkPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>CommonsChunkPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.DedupePlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>DedupePlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.LimitChunkCountPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>LimitChunkCountPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.MinChunkSizePlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>MinChunkSizePlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.OccurrenceOrderPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>OccurrenceOrderPlugin
            <span class="apidocSignatureSpan">(preferEntry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.UglifyJsPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>UglifyJsPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.system">module webpack.system</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.system.import">
            function <span class="apidocSignatureSpan">webpack.system.</span>import
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.webpack_web">module webpack.webpack_web</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web.webpack_web">
            function <span class="apidocSignatureSpan">webpack.</span>webpack_web
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web.Compiler">
            function <span class="apidocSignatureSpan">webpack.webpack_web.</span>Compiler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web.WebEnvironmentPlugin">
            function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebEnvironmentPlugin
            <span class="apidocSignatureSpan">(inputFileSystem, outputFileSystem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web.WebpackOptionsApply">
            function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebpackOptionsApply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web.WebpackOptionsDefaulter">
            function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebpackOptionsDefaulter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack" id="apidoc.module.webpack">module webpack</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.webpack" id="apidoc.element.webpack.webpack">
        function <span class="apidocSignatureSpan"></span>webpack
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function webpack(options, callback) {
	const webpackOptionsValidationErrors = validateSchema(webpackOptionsSchema, options);
	if(webpackOptionsValidationErrors.length) {
		throw new WebpackOptionsValidationError(webpackOptionsValidationErrors);
	}
	let compiler;
	if(Array.isArray(options)) {
		compiler = new MultiCompiler(options.map(options =&gt; webpack(options)));
	} else if(typeof options === "object") {
		new WebpackOptionsDefaulter().process(options);

		compiler = new Compiler();
		compiler.context = options.context;
		compiler.options = options;
		new NodeEnvironmentPlugin().apply(compiler);
		if(options.plugins &amp;&amp; Array.isArray(options.plugins)) {
			compiler.apply.apply(compiler, options.plugins);
		}
		compiler.applyPlugins("environment");
		compiler.applyPlugins("after-environment");
		compiler.options = new WebpackOptionsApply().process(options, compiler);
	} else {
		throw new Error("Invalid argument: options");
	}
	if(callback) {
		if(typeof callback !== "function") throw new Error("Invalid argument: callback");
		if(options.watch === true || (Array.isArray(options) &amp;&amp; options.some(o =&gt; o.watch))) {
			const watchOptions = Array.isArray(options) ? options.map(o =&gt; o.watchOptions || {}) : (options.watchOptions || {});
			return compiler.watch(watchOptions, callback);
		}
		compiler.run(callback);
	}
	return compiler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.AutomaticPrefetchPlugin" id="apidoc.element.webpack.AutomaticPrefetchPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>AutomaticPrefetchPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AutomaticPrefetchPlugin {
	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			const normalModuleFactory = params.normalModuleFactory;

			compilation.dependencyFactories.set(PrefetchDependency, normalModuleFactory);
		});
		let lastModules = null;
		compiler.plugin("after-compile", (compilation, callback) =&gt; {
			lastModules = compilation.modules
				.filter(m =&gt; m instanceof NormalModule)
				.map(m =&gt; ({
					context: m.context,
					request: m.request
				}));
			callback();
		});
		compiler.plugin("make", (compilation, callback) =&gt; {
			if(!lastModules) return callback();
			asyncLib.forEach(lastModules, (m, callback) =&gt; {
				compilation.prefetch(m.context || compiler.context, new PrefetchDependency(m.request), callback);
			}, callback);
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.BannerPlugin" id="apidoc.element.webpack.BannerPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>BannerPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class BannerPlugin {
	constructor(options) {
		if(arguments.length &gt; 1)
			throw new Error("BannerPlugin only takes one argument (pass an options object)");
		if(typeof options === "string")
			options = {
				banner: options
			};
		this.options = options || {};
		this.banner = this.options.raw ? options.banner : wrapComment(options.banner);
	}

	apply(compiler) {
		const options = this.options;
		const banner = this.banner;

		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-chunk-assets", (chunks, callback) =&gt; {
				chunks.forEach((chunk) =&gt; {
					if(options.entryOnly &amp;&amp; !chunk.isInitial()) return;

					chunk.files
						.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options))
						.forEach((file) =&gt;
							compilation.assets[file] = new ConcatSource(
								banner, "\n", compilation.assets[file]
							)
						);
				});
				callback();
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.CachePlugin" id="apidoc.element.webpack.CachePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>CachePlugin
        <span class="apidocSignatureSpan">(cache)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CachePlugin {
	constructor(cache) {
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.apply(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
						new Error(`CachePlugin - Cache cannot be used because of: ${compilation.notCacheable}`)
					);
				}
			});
			compiler.plugin("watch-run", (compiler, callback) =&gt; {
				this.watching = true;
				callback();
			});
			compiler.plugin("run", (compiler, callback) =&gt; {
				if(!compiler._lastCompilationFileDependencies) return callback();
				const fs = compiler.inputFileSystem;
				const fileTs = compiler.fileTimestamps = {};
				asyncLib.forEach(compiler._lastCompilationFileDependencies, (file, callback) =&gt; {
					fs.stat(file, (err, stat) =&gt; {
						if(err) {
							if(err.code === "ENOENT") return callback();
							return callback(err);
						}

						if(stat.mtime)
							this.applyMtime(+stat.mtime);

						fileTs[file] = +stat.mtime || Infinity;
						callback();
					});
				}, err =&gt; {
					if(err) return callback(err);
					Object.keys(fileTs).forEach(key =&gt; {
						fileTs[key] += this.FS_ACCURENCY;
					});
					callback();
				});
			});
			compiler.plugin("after-compile", function(compilation, callback) {
				compilation.compiler._lastCompilationFileDependencies = compilation.fileDependencies;
				compilation.compiler._lastCompilationContextDependencies = compilation.contextDependencies;
				callback();
			});
		}
	}

	/* istanbul ignore next */
	applyMtime(mtime) {
		if(this.FS_ACCURENCY &gt; 1 &amp;&amp; mtime % 2 !== 0)
			this.FS_ACCURENCY = 1;
		else if(this.FS_ACCURENCY &gt; 10 &amp;&amp; mtime % 20 !== 0)
			this.FS_ACCURENCY = 10;
		else if(this.FS_ACCURENCY &gt; 100 &amp;&amp; mtime % 200 !== 0)
			this.FS_ACCURENCY = 100;
		else if(this.FS_ACCURENCY &gt; 1000 &amp;&amp; mtime % 2000 !== 0)
			this.FS_ACCURENCY = 1000;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler" id="apidoc.element.webpack.Compiler">
        function <span class="apidocSignatureSpan">webpack.</span>Compiler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler() {
	Tapable.call(this);

	this.outputPath = "";
	this.outputFileSystem = null;
	this.inputFileSystem = null;

	this.recordsInputPath = null;
	this.recordsOutputPath = null;
	this.records = {};

	this.fileTimestamps = {};
	this.contextTimestamps = {};

	this.resolvers = {
		normal: null,
		loader: null,
		context: null
	};
	var deprecationReported = false;
	this.parser = {
		plugin: function(hook, fn) {
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.plugin(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.plugin(hook, fn);
				});
			});
		}.bind(this),
		apply: function() {
			var args = arguments;
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.apply(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.apply.apply(parser, args);
				});
			});
		}.bind(this)
	};

	this.options = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching" id="apidoc.element.webpack.Compiler.Watching">
        function <span class="apidocSignatureSpan">webpack.</span>Compiler.Watching
        <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Watching(compiler, watchOptions, handler) {
	this.startTime = null;
	this.invalid = false;
	this.error = null;
	this.stats = null;
	this.handler = handler;
	this.closed = false;
	if(typeof watchOptions === "number") {
		this.watchOptions = {
			aggregateTimeout: watchOptions
		};
	} else if(watchOptions &amp;&amp; typeof watchOptions === "object") {
		this.watchOptions = Object.assign({}, watchOptions);
	} else {
		this.watchOptions = {};
	}
	this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200;
	this.compiler = compiler;
	this.running = true;
	this.compiler.readRecords(function(err) {
		if(err) return this._done(err);

		this._go();
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ContextModuleFactory" id="apidoc.element.webpack.ContextModuleFactory">
        function <span class="apidocSignatureSpan">webpack.</span>ContextModuleFactory
        <span class="apidocSignatureSpan">(resolvers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ContextModuleFactory(resolvers) {
	Tapable.call(this);
	this.resolvers = resolvers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ContextReplacementPlugin" id="apidoc.element.webpack.ContextReplacementPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ContextReplacementPlugin
        <span class="apidocSignatureSpan">(resourceRegExp, newContentResource, newContentRecursive, newContentRegExp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ContextReplacementPlugin {
	constructor(resourceRegExp, newContentResource, newContentRecursive, newContentRegExp) {
		this.resourceRegExp = resourceRegExp;

		if(typeof newContentResource === "function") {
			this.newContentCallback = newContentResource;
		} else if(typeof newContentResource === "string" &amp;&amp; typeof newContentRecursive === "object") {
			this.newContentResource = newContentResource;
			this.newContentCreateContextMap = (fs, callback) =&gt; {
				callback(null, newContentRecursive);
			};
		} else if(typeof newContentResource === "string" &amp;&amp; typeof newContentRecursive === "function") {
			this.newContentResource = newContentResource;
			this.newContentCreateContextMap = newContentRecursive;
		} else {
			if(typeof newContentResource !== "string") {
				newContentRegExp = newContentRecursive;
				newContentRecursive = newContentResource;
				newContentResource = undefined;
			}
			if(typeof newContentRecursive !== "boolean") {
				newContentRegExp = newContentRecursive;
				newContentRecursive = undefined;
			}
			this.newContentResource = newContentResource;
			this.newContentRecursive = newContentRecursive;
			this.newContentRegExp = newContentRegExp;
		}
	}

	apply(compiler) {
		const resourceRegExp = this.resourceRegExp;
		const newContentCallback = this.newContentCallback;
		const newContentResource = this.newContentResource;
		const newContentRecursive = this.newContentRecursive;
		const newContentRegExp = this.newContentRegExp;
		const newContentCreateContextMap = this.newContentCreateContextMap;

		compiler.plugin("context-module-factory", (cmf) =&gt; {
			cmf.plugin("before-resolve", (result, callback) =&gt; {
				if(!result) return callback();
				if(resourceRegExp.test(result.request)) {
					if(typeof newContentResource !== "undefined")
						result.request = newContentResource;
					if(typeof newContentRecursive !== "undefined")
						result.recursive = newContentRecursive;
					if(typeof newContentRegExp !== "undefined")
						result.regExp = newContentRegExp;
					if(typeof newContentCallback === "function") {
						newContentCallback(result);
					} else {
						result.dependencies.forEach((d) =&gt; {
							if(d.critical)
								d.critical = false;
						});
					}
				}
				return callback(null, result);
			});
			cmf.plugin("after-resolve", (result, callback) =&gt; {
				if(!result) return callback();
				if(resourceRegExp.test(result.resource)) {
					if(typeof newContentResource !== "undefined")
						result.resource = path.resolve(result.resource, newContentResource);
					if(typeof newContentRecursive !== "undefined")
						result.recursive = newContentRecursive;
					if(typeof newContentRegExp !== "undefined")
						result.regExp = newContentRegExp;
					if(typeof newContentCreateContextMap === "function")
						result.resolveDependencies = createResolveDependenciesFromContextMap(newContentCreateContextMap);
					if(typeof newContentCallback === "function") {
						const origResource = result.resource;
						newContentCallback(result);
						if(result.resource !== origResource) {
							result.resource = path.resolve(origResource, result.resource);
						}
					} else {
						result.dependencies.forEach((d) =&gt; {
							if(d.critical)
								d.critical = false;
						});
					}
				}
				return callback(null, result);
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DefinePlugin" id="apidoc.element.webpack.DefinePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>DefinePlugin
        <span class="apidocSignatureSpan">(definitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DefinePlugin {
	constructor(definitions) {
		this.definitions = definitions;
	}

	apply(compiler) {
		const definitions = this.definitions;
		compiler.plugin("compilation", (compilation, params) =&gt; {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

			params.normalModuleFactory.plugin("parser", (parser) =&gt; {
				(function walkDefinitions(definitions, prefix) {
					Object.keys(definitions).forEach((key) =&gt; {
						const code = definitions[key];
						if(code &amp;&amp; typeof code === "object" &amp;&amp; !(code instanceof RegExp)) {
							walkDefinitions(code, prefix + key + ".");
							applyObjectDefine(prefix + key, code);
							return;
						}
						applyDefineKey(prefix, key);
						applyDefine(prefix + key, code);
					});
				}(definitions, ""));

				function stringifyObj(obj) {
					return "__webpack_require__.i({" + Object.keys(obj).map((key) =&gt; {
						const code = obj[key];
						return JSON.stringify(key) + ":" + toCode(code);
					}).join(",") + "})";
				}

				function toCode(code) {
					if(code === null) return "null";
					else if(code === undefined) return "undefined";
					else if(code instanceof RegExp &amp;&amp; code.toString) return code.toString();
					else if(typeof code === "function" &amp;&amp; code.toString) return "(" + code.toString() + ")";
					else if(typeof code === "object") return stringifyObj(code);
					else return code + "";
				}

				function applyDefineKey(prefix, key) {
					const splittedKey = key.split(".");
					splittedKey.slice(1).forEach((_, i) =&gt; {
						const fullKey = prefix + splittedKey.slice(0, i + 1).join(".");
						parser.plugin("can-rename " + fullKey, ParserHelpers.approve);
					});
				}

				function applyDefine(key, code) {
					const isTypeof = /^typeof\s+/.test(key);
					if(isTypeof) key = key.replace(/^typeof\s+/, "");
					let recurse = false;
					let recurseTypeof = false;
					code = toCode(code);
					if(!isTypeof) {
						parser.plugin("can-rename " + key, ParserHelpers.approve);
						parser.plugin("evaluate Identifier " + key, (expr) =&gt; {
							/**
							 * this is needed in case there is a recursion in the DefinePlugin
							 * to prevent an endless recursion
							 * e.g.: new DefinePlugin({
							 * "a": "b",
							 * "b": "a"
							 * });
							 */
							if(recurse) return;
							recurse = true;
							const res = parser.evaluate(code);
							recurse = false;
							res.setRange(expr.range);
							return res;
						});
						parser.plugin("expression " + key, ParserHelpers.toConstantDependency(code));
					}
					const typeofCode = isTypeof ? code : "typeof (" + code + ")";
					parser.plugin("evaluate typeof " + key, (expr) =&gt; {
						/**
						 * this is needed in case there is a recursion in the DefinePlugin
						 * to prevent an endless recursion
						 * e.g.: new DefinePlugin({
						 * "typeof a": "tyepof b",
						 * "typeof b": "typeof a"
						 * });
						 */
						if(recurseTypeof) return;
						recurseTypeof = true;
						const res = parser.evaluate(typeofCode);
						recurseTypeof = false;
						res.setRange(expr.range);
						return res;
					});
					parser.plugin("typeof " + key, (expr) =&gt; {
						const res = parser.evaluate(typeofCode);
						if(!res.isString()) return;
						return ParserHelpers.toConstantDependency(JSON.stringify(res.string)).bind(parser)(expr);
					});
				}

				function applyObjectDefine(key, obj) {
					const code = stringifyObj(obj);
					parser.plugin("can-rename " + key, ParserHelpers.approve);
					parser.plugin("evaluate Identifier " + key, (expr) =&gt; new BasicEvaluatedExpression().setRange(expr.range));
					parser.plugin("evaluate typeof " + key, ParserHelpers.evaluateToString("object"));
					parser.plugin("expression " + key, ParserHelpers.toConstantDependency(code));
					parser.plugin("typeof " + key, ParserHelpers.toConstantDependency(JSON.stringify("object")));
				}
			});
		} ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Dependency" id="apidoc.element.webpack.Dependency">
        function <span class="apidocSignatureSpan">webpack.</span>Dependency
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Dependency {
	constructor() {
		this.module = null;
	}

	isEqualResource() {
		return false;
	}

	// Returns the referenced module and export
	getReference() {
		if(!this.module) return null;
		return {
			module: this.module,
			importedNames: true, // true: full object, false: only sideeffects/no export, array of strings: the exports with this names
		};
	}

	// Returns the exported names
	getExports() {
		return null;
	}

	getWarnings() {
		return null;
	}

	getErrors() {
		return null;
	}

	updateHash(hash) {
		hash.update((this.module &amp;&amp; this.module.id) + "");
	}

	disconnect() {
		this.module = null;
	}

	// TODO: remove in webpack 3
	compare(a, b) {
		return compareLocations(a.loc, b.loc);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DllPlugin" id="apidoc.element.webpack.DllPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>DllPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DllPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.plugin("entry-option", (context, entry) =&gt; {
			function itemToPlugin(item, name) {
				if(Array.isArray(item))
					return new DllEntryPlugin(context, item, name);
				else
					throw new Error("DllPlugin: supply an Array as entry");
			}
			if(typeof entry === "object" &amp;&amp; !Array.isArray(entry)) {
				Object.keys(entry).forEach(name =&gt; {
					compiler.apply(itemToPlugin(entry[name], name));
				});
			} else {
				compiler.apply(itemToPlugin(entry, "main"));
			}
			return true;
		});
		compiler.apply(new LibManifestPlugin(this.options));
		compiler.apply(new FlagInitialModulesAsUsedPlugin());
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DllReferencePlugin" id="apidoc.element.webpack.DllReferencePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>DllReferencePlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DllReferencePlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			const normalModuleFactory = params.normalModuleFactory;
			compilation.dependencyFactories.set(DelegatedSourceDependency, normalModuleFactory);
		});

		compiler.plugin("before-compile", (params, callback) =&gt; {
			const manifest = this.options.manifest;
			if(typeof manifest === "string") {
				params.compilationDependencies.push(manifest);
				compiler.inputFileSystem.readFile(manifest, function(err, result) {
					if(err) return callback(err);
					params["dll reference " + manifest] = JSON.parse(result.toString("utf-8"));
					return callback();
				});
			} else {
				return callback();
			}
		});

		compiler.plugin("compile", (params) =&gt; {
			let manifest = this.options.manifest;
			if(typeof manifest === "string") {
				manifest = params["dll reference " + manifest];
			}
			const name = this.options.name || manifest.name;
			const sourceType = this.options.sourceType || "var";
			const externals = {};
			const source = "dll-reference " + name;
			externals[source] = name;
			params.normalModuleFactory.apply(new ExternalModuleFactoryPlugin(sourceType, externals));
			params.normalModuleFactory.apply(new DelegatedModuleFactoryPlugin({
				source: source,
				type: this.options.type,
				scope: this.options.scope,
				context: this.options.context || compiler.options.context,
				content: this.options.content || manifest.content,
				extensions: this.options.extensions
			}));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DynamicEntryPlugin" id="apidoc.element.webpack.DynamicEntryPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>DynamicEntryPlugin
        <span class="apidocSignatureSpan">(context, entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DynamicEntryPlugin {
	constructor(context, entry) {
		this.context = context;
		this.entry = entry;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			const multiModuleFactory = new MultiModuleFactory();
			const normalModuleFactory = params.normalModuleFactory;

			compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);
			compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
		});

		compiler.plugin("make", (compilation, callback) =&gt; {
			const addEntry = (entry, name) =&gt; {
				const dep = DynamicEntryPlugin.createDependency(entry, name);
				return new Promise((resolve, reject) =&gt; {
					compilation.addEntry(this.context, dep, name, (err) =&gt; {
						if(err) return reject(err);
						resolve();
					});
				});
			};

			Promise.resolve(this.entry()).then((entry) =&gt; {
				if(typeof entry === "string" || Array.isArray(entry)) {
					addEntry(entry, "main").then(() =&gt; callback(), callback);
				} else if(typeof entry === "object") {
					Promise.all(Object.keys(entry).map((name) =&gt; {
						return addEntry(entry[name], name);
					})).then(() =&gt; callback(), callback);
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.EnvironmentPlugin" id="apidoc.element.webpack.EnvironmentPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>EnvironmentPlugin
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class EnvironmentPlugin {
	constructor(keys) {
		if(Array.isArray(keys)) {
			this.keys = keys;
			this.defaultValues = {};
		} else if(keys &amp;&amp; typeof keys === "object") {
			this.keys = Object.keys(keys);
			this.defaultValues = keys;
		} else {
			this.keys = Array.prototype.slice.call(arguments);
			this.defaultValues = {};
		}
	}

	apply(compiler) {
		const definitions = this.keys.reduce((defs, key) =&gt; {
			const value = process.env[key] !== undefined ? process.env[key] : this.defaultValues[key];

			if(value === undefined) {
				compiler.plugin("this-compilation", compilation =&gt; {
					const error = new Error(
						`EnvironmentPlugin - ${key} environment variable is undefined.\n\n` +
						"You can pass an object with default values to suppress this warning.\n" +
						"See https://webpack.js.org/plugins/environment-plugin for example."
					);

					error.name = "EnvVariableNotDefinedError";
					compilation.warnings.push(error);
				});
			}

			defs[`process.env.${key}`] = typeof value === "undefined" ? "undefined" : JSON.stringify(value);

			return defs;
		}, {});

		compiler.apply(new DefinePlugin(definitions));
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.EvalDevToolModulePlugin" id="apidoc.element.webpack.EvalDevToolModulePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>EvalDevToolModulePlugin
        <span class="apidocSignatureSpan">(sourceUrlComment, moduleFilenameTemplate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class EvalDevToolModulePlugin {
	constructor(sourceUrlComment, moduleFilenameTemplate) {
		this.sourceUrlComment = sourceUrlComment;
		this.moduleFilenameTemplate = moduleFilenameTemplate;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.moduleTemplate.apply(new EvalDevToolModuleTemplatePlugin(this.sourceUrlComment, this.moduleFilenameTemplate));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.EvalSourceMapDevToolPlugin" id="apidoc.element.webpack.EvalSourceMapDevToolPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>EvalSourceMapDevToolPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class EvalSourceMapDevToolPlugin {
	constructor(options) {
		if(arguments.length &gt; 1)
			throw new Error("EvalSourceMapDevToolPlugin only takes one argument (pass an options object)");
		if(typeof options === "string") {
			options = {
				append: options
			};
		}
		if(!options) options = {};
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
			compilation.moduleTemplate.apply(new EvalSourceMapDevToolModuleTemplatePlugin(compilation, options));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ExtendedAPIPlugin" id="apidoc.element.webpack.ExtendedAPIPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ExtendedAPIPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ExtendedAPIPlugin {
	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
			compilation.mainTemplate.plugin("require-extensions", function(source, chunk, hash) {
				const buf = [source];
				buf.push("");
				buf.push("// __webpack_hash__");
				buf.push(`${this.requireFn}.h = ${JSON.stringify(hash)};`);
				buf.push("");
				buf.push("// __webpack_chunkname__");
				buf.push(`${this.requireFn}.cn = ${JSON.stringify(chunk.name)};`);
				return this.asString(buf);
			});
			compilation.mainTemplate.plugin("global-hash", () =&gt; true);

			params.normalModuleFactory.plugin("parser", (parser, parserOptions) =&gt; {
				Object.keys(REPLACEMENTS).forEach(key =&gt; {
					parser.plugin(`expression ${key}`, ParserHelpers.toConstantDependency(REPLACEMENTS[key]));
					parser.plugin(`evaluate typeof ${key}`, ParserHelpers.evaluateToString(REPLACEMENT_TYPES[key]));
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ExternalsPlugin" id="apidoc.element.webpack.ExternalsPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ExternalsPlugin
        <span class="apidocSignatureSpan">(type, externals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ExternalsPlugin {
	constructor(type, externals) {
		this.type = type;
		this.externals = externals;
	}
	apply(compiler) {
		compiler.plugin("compile", (params) =&gt; {
			params.normalModuleFactory.apply(new ExternalModuleFactoryPlugin(this.type, this.externals));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.HashedModuleIdsPlugin" id="apidoc.element.webpack.HashedModuleIdsPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>HashedModuleIdsPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class HashedModuleIdsPlugin {
	constructor(options) {
		this.options = Object.assign({
			hashFunction: "md5",
			hashDigest: "base64",
			hashDigestLength: 4
		}, options);
	}

	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			const usedIds = new Set();
			compilation.plugin("before-module-ids", (modules) =&gt; {
				modules.forEach((module) =&gt; {
					if(module.id === null &amp;&amp; module.libIdent) {
						const id = module.libIdent({
							context: this.options.context || compiler.options.context
						});
						const hash = createHash(options.hashFunction);
						hash.update(id);
						const hashId = hash.digest(options.hashDigest);
						let len = options.hashDigestLength;
						while(usedIds.has(hashId.substr(0, len)))
							len++;
						module.id = hashId.substr(0, len);
						usedIds.add(module.id);
					}
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.HotModuleReplacementPlugin" id="apidoc.element.webpack.HotModuleReplacementPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>HotModuleReplacementPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HotModuleReplacementPlugin(options) {
	options = options || {};
	this.multiStep = options.multiStep;
	this.fullBuildTimeout = options.fullBuildTimeout || 200;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.IgnorePlugin" id="apidoc.element.webpack.IgnorePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>IgnorePlugin
        <span class="apidocSignatureSpan">(resourceRegExp, contextRegExp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class IgnorePlugin {
	constructor(resourceRegExp, contextRegExp) {
		this.resourceRegExp = resourceRegExp;
		this.contextRegExp = contextRegExp;

		this.checkIgnore = this.checkIgnore.bind(this);
	}

	/*
	 * Only returns true if a "resourceRegExp" exists
	 * and the resource given matches the regexp.
	 */
	checkResouce(resource) {
		if(!this.resourceRegExp) {
			return false;
		}
		return this.resourceRegExp.test(resource);
	}

	/*
	 * Returns true if contextRegExp does not exist
	 * or if context matches the given regexp.
	 */
	checkContext(context) {
		if(!this.contextRegExp) {
			return true;
		}
		return this.contextRegExp.test(context);
	}

	/*
	 * Returns true if result should be ignored.
	 * false if it shouldn't.
	 *
	 * Not that if "contextRegExp" is given, both the "resourceRegExp"
	 * and "contextRegExp" have to match.
	 */
	checkResult(result) {
		if(!result) {
			return true;
		}
		return this.checkResouce(result.request) &amp;&amp; this.checkContext(result.context);
	}

	checkIgnore(result, callback) {
		// check if result is ignored
		if(this.checkResult(result)) {
			return callback();
		}
		return callback(null, result);
	}

	apply(compiler) {
		compiler.plugin("normal-module-factory", (nmf) =&gt; {
			nmf.plugin("before-resolve", this.checkIgnore);
		});
		compiler.plugin("context-module-factory", (cmf) =&gt; {
			cmf.plugin("before-resolve", this.checkIgnore);
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.JsonpTemplatePlugin" id="apidoc.element.webpack.JsonpTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>JsonpTemplatePlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class JsonpTemplatePlugin {
	apply(compiler) {
		compiler.plugin("this-compilation", (compilation) =&gt; {
			compilation.mainTemplate.apply(new JsonpMainTemplatePlugin());
			compilation.chunkTemplate.apply(new JsonpChunkTemplatePlugin());
			compilation.hotUpdateChunkTemplate.apply(new JsonpHotUpdateChunkTemplatePlugin());
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.LibraryTemplatePlugin" id="apidoc.element.webpack.LibraryTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>LibraryTemplatePlugin
        <span class="apidocSignatureSpan">(name, target, umdNamedDefine, auxiliaryComment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LibraryTemplatePlugin {

	constructor(name, target, umdNamedDefine, auxiliaryComment) {
		this.name = name;
		this.target = target;
		this.umdNamedDefine = umdNamedDefine;
		this.auxiliaryComment = auxiliaryComment;
	}

	apply(compiler) {
		compiler.plugin("this-compilation", (compilation) =&gt; {
			switch(this.target) {
				case "var":
					compilation.apply(new SetVarMainTemplatePlugin(`var ${accessorAccess(false, this.name)}`));
					break;
				case "assign":
					compilation.apply(new SetVarMainTemplatePlugin(accessorAccess(undefined, this.name)));
					break;
				case "this":
				case "window":
				case "global":
					if(this.name)
						compilation.apply(new SetVarMainTemplatePlugin(accessorAccess(this.target, this.name)));
					else
						compilation.apply(new SetVarMainTemplatePlugin(this.target, true));
					break;
				case "commonjs":
					if(this.name)
						compilation.apply(new SetVarMainTemplatePlugin(accessorAccess("exports", this.name)));
					else
						compilation.apply(new SetVarMainTemplatePlugin("exports", true));
					break;
				case "commonjs2":
				case "commonjs-module":
					compilation.apply(new SetVarMainTemplatePlugin("module.exports"));
					break;
				case "amd":
					var AmdMainTemplatePlugin = require("./AmdMainTemplatePlugin");
					compilation.apply(new AmdMainTemplatePlugin(this.name));
					break;
				case "umd":
				case "umd2":
					var UmdMainTemplatePlugin = require("./UmdMainTemplatePlugin");
					compilation.apply(new UmdMainTemplatePlugin(this.name, {
						optionalAmdExternalAsGlobal: this.target === "umd2",
						namedDefine: this.umdNamedDefine,
						auxiliaryComment: this.auxiliaryComment
					}));
					break;
				case "jsonp":
					var JsonpExportMainTemplatePlugin = require("./JsonpExportMainTemplatePlugin");
					compilation.apply(new JsonpExportMainTemplatePlugin(this.name));
					break;
				default:
					throw new Error(`${this.target} is not a valid Library target`);
			}
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.LoaderOptionsPlugin" id="apidoc.element.webpack.LoaderOptionsPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>LoaderOptionsPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LoaderOptionsPlugin {
	constructor(options) {
		if(typeof options !== "object") options = {};
		if(!options.test) options.test = {
			test: () =&gt; true
		};
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("normal-module-loader", (context, module) =&gt; {
				const resource = module.resource;
				if(!resource) return;
				const i = resource.indexOf("?");
				if(ModuleFilenameHelpers.matchObject(options, i &lt; 0 ? resource : resource.substr(0, i))) {
					const filterSet = new Set(["include", "exclude", "test"]);
					Object.keys(options)
						.filter((key) =&gt; !filterSet.has(key))
						.forEach((key) =&gt; context[key] = options[key]);
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				switch(err.params.additionalProperty) {
					case "debug":
						return `${baseMessage}\n` +
							"The 'debug' property was removed in webpack 2.\n" +
							"Loaders should be updated to allow passing this option via loader options in module.rules.\n" +
							"Until loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\n" +
							"plugins: [\n" +
							"  new webpack.<span class="apidocCodeKeywordSpan">LoaderOptionsPlugin</span>({\n" +
							"    debug: true\n" +
							"  })\n" +
							"]";
				}
				return baseMessage + "\n" +
					"For typos: please correct them.\n" +
					"For loader options: webpack 2 no longer allows custom properties in configuration.\n" +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.LoaderTargetPlugin" id="apidoc.element.webpack.LoaderTargetPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>LoaderTargetPlugin
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LoaderTargetPlugin {
	constructor(target) {
		this.target = target;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("normal-module-loader", (loaderContext) =&gt; loaderContext.target = this.target);
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem" id="apidoc.element.webpack.MemoryOutputFileSystem">
        function <span class="apidocSignatureSpan">webpack.</span>MemoryOutputFileSystem
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryFileSystem(data) {
	this.data = data || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler" id="apidoc.element.webpack.MultiCompiler">
        function <span class="apidocSignatureSpan">webpack.</span>MultiCompiler
        <span class="apidocSignatureSpan">(compilers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiCompiler(compilers) {
	Tapable.call(this);
	if(!Array.isArray(compilers)) {
		compilers = Object.keys(compilers).map(function(name) {
			compilers[name].name = name;
			return compilers[name];
		});
	}
	this.compilers = compilers;

	function delegateProperty(name) {
		Object.defineProperty(this, name, {
			configurable: false,
			get: function() {
				throw new Error("Cannot read " + name + " of a MultiCompiler");
			},
			set: function(value) {
				this.compilers.forEach(function(compiler) {
					compiler[name] = value;
				});
			}.bind(this)
		});
	}
	delegateProperty.call(this, "outputFileSystem");
	delegateProperty.call(this, "inputFileSystem");

	Object.defineProperty(this, "outputPath", {
		configurable: false,
		get: function() {
			var commonPath = compilers[0].outputPath;
			for(var i = 1; i &lt; compilers.length; i++) {
				while(compilers[i].outputPath.indexOf(commonPath) !== 0 &amp;&amp; /[\/\\]/.test(commonPath)) {
					commonPath = commonPath.replace(/[\/\\][^\/\\]*$/, "");
				}
			}
			if(!commonPath &amp;&amp; compilers[0].outputPath[0] === "/") return "/";
			return commonPath;
		}
	});

	var doneCompilers = 0;
	var compilerStats = [];
	this.compilers.forEach(function(compiler, idx) {
		var compilerDone = false;
		compiler.plugin("done", function(stats) {
			if(!compilerDone) {
				compilerDone = true;
				doneCompilers++;
			}
			compilerStats[idx] = stats;
			if(doneCompilers === this.compilers.length) {
				this.applyPlugins("done", new MultiStats(compilerStats));
			}
		}.bind(this));
		compiler.plugin("invalid", function() {
			if(compilerDone) {
				compilerDone = false;
				doneCompilers--;
			}
			this.applyPlugins("invalid");
		}.bind(this));
	}, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NamedChunksPlugin" id="apidoc.element.webpack.NamedChunksPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NamedChunksPlugin
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NamedChunksPlugin {

	static defaultNameResolver(chunk) {
		return chunk.name || null;
	}

	constructor(nameResolver) {
		this.nameResolver = nameResolver || NamedChunksPlugin.defaultNameResolver;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("before-chunk-ids", (chunks) =&gt; {
				chunks.forEach((chunk) =&gt; {
					if(chunk.id === null) {
						chunk.id = this.nameResolver(chunk);
					}
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NamedModulesPlugin" id="apidoc.element.webpack.NamedModulesPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NamedModulesPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NamedModulesPlugin {
	constructor(options) {
		this.options = options || {};
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("before-module-ids", (modules) =&gt; {
				modules.forEach((module) =&gt; {
					if(module.id === null &amp;&amp; module.libIdent) {
						module.id = module.libIdent({
							context: this.options.context || compiler.options.context
						});
					}
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NewWatchingPlugin" id="apidoc.element.webpack.NewWatchingPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NewWatchingPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NewWatchingPlugin {
	apply(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.warnings.push(new Error("The 'NewWatchingPlugin' is no longer necessary (now default)"));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NoEmitOnErrorsPlugin" id="apidoc.element.webpack.NoEmitOnErrorsPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NoEmitOnErrorsPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NoEmitOnErrorsPlugin {
	apply(compiler) {
		compiler.plugin("should-emit", (compilation) =&gt; {
			if(compilation.errors.length &gt; 0)
				return false;
		});
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("should-record", () =&gt; {
				if(compilation.errors.length &gt; 0)
					return false;
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NoErrorsPlugin" id="apidoc.element.webpack.NoErrorsPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NoErrorsPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NoErrorsPlugin {
	apply(compiler) {
		compiler.plugin("should-emit", (compilation) =&gt; {
			if(!deprecationReported) {
				compilation.warnings.push("webpack: Using NoErrorsPlugin is deprecated.\n" +
					"Use NoEmitOnErrorsPlugin instead.\n");
				deprecationReported = true;
			}
			if(compilation.errors.length &gt; 0)
				return false;
		});
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("should-record", () =&gt; {
				if(compilation.errors.length &gt; 0)
					return false;
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NodeEnvironmentPlugin" id="apidoc.element.webpack.NodeEnvironmentPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NodeEnvironmentPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NodeEnvironmentPlugin {
	apply(compiler) {
		compiler.inputFileSystem = new CachedInputFileSystem(new NodeJsInputFileSystem(), 60000);
		const inputFileSystem = compiler.inputFileSystem;
		compiler.outputFileSystem = new NodeOutputFileSystem();
		compiler.watchFileSystem = new NodeWatchFileSystem(compiler.inputFileSystem);
		compiler.plugin("before-run", (compiler, callback) =&gt; {
			if(compiler.inputFileSystem === inputFileSystem)
				inputFileSystem.purge();
			callback();
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NormalModuleReplacementPlugin" id="apidoc.element.webpack.NormalModuleReplacementPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NormalModuleReplacementPlugin
        <span class="apidocSignatureSpan">(resourceRegExp, newResource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NormalModuleReplacementPlugin {
	constructor(resourceRegExp, newResource) {
		this.resourceRegExp = resourceRegExp;
		this.newResource = newResource;
	}

	apply(compiler) {
		const resourceRegExp = this.resourceRegExp;
		const newResource = this.newResource;
		compiler.plugin("normal-module-factory", (nmf) =&gt; {
			nmf.plugin("before-resolve", (result, callback) =&gt; {
				if(!result) return callback();
				if(resourceRegExp.test(result.request)) {
					if(typeof newResource === "function") {
						newResource(result);
					} else {
						result.request = newResource;
					}
				}
				return callback(null, result);
			});
			nmf.plugin("after-resolve", (result, callback) =&gt; {
				if(!result) return callback();
				if(resourceRegExp.test(result.resource)) {
					if(typeof newResource === "function") {
						newResource(result);
					} else {
						result.resource = path.resolve(path.dirname(result.resource), newResource);
					}
				}
				return callback(null, result);
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.PrefetchPlugin" id="apidoc.element.webpack.PrefetchPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>PrefetchPlugin
        <span class="apidocSignatureSpan">(context, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PrefetchPlugin {

	constructor(context, request) {
		if(!request) {
			this.request = context;
		} else {
			this.context = context;
			this.request = request;
		}
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			const normalModuleFactory = params.normalModuleFactory;

			compilation.dependencyFactories.set(PrefetchDependency, normalModuleFactory);
		});
		compiler.plugin("make", (compilation, callback) =&gt; {
			compilation.prefetch(this.context || compiler.context, new PrefetchDependency(this.request), callback);
		});
	}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ProgressPlugin" id="apidoc.element.webpack.ProgressPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ProgressPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ProgressPlugin {

	constructor(options) {
		if(typeof options === "function") {
			options = {
				handler: options
			};
		}
		options = options || {};
		this.profile = options.profile;
		this.handler = options.handler;
	}

	apply(compiler) {
		const handler = this.handler || defaultHandler;
		const profile = this.profile;
		if(compiler.compilers) {
			const states = new Array(compiler.compilers.length);
			compiler.compilers.forEach(function(compiler, idx) {
				compiler.apply(new ProgressPlugin(function(p, msg) {
					states[idx] = Array.prototype.slice.apply(arguments);
					handler.apply(null, [
						states.map(state =&gt; state &amp;&amp; state[0] || 0).reduce((a, b) =&gt; a + b) / states.length,
						`[${idx}] ${msg}`
					].concat(Array.prototype.slice.call(arguments, 2)));
				}));
			});
		} else {
			let lastModulesCount = 0;
			let moduleCount = 500;
			let doneModules = 0;
			const activeModules = [];

			const update = function update(module) {
				handler(
					0.1 + (doneModules / Math.max(lastModulesCount, moduleCount)) * 0.6,
					"building modules",
					`${doneModules}/${moduleCount} modules`,
					`${activeModules.length} active`,
					activeModules[activeModules.length - 1]
				);
			};

			const moduleDone = function moduleDone(module) {
				doneModules++;
				const ident = module.identifier();
				if(ident) {
					const idx = activeModules.indexOf(ident);
					if(idx &gt;= 0) activeModules.splice(idx, 1);
				}
				update();
			};
			compiler.plugin("compilation", function(compilation) {
				if(compilation.compiler.isChild()) return;
				lastModulesCount = moduleCount;
				moduleCount = 0;
				doneModules = 0;
				handler(0, "compiling");
				compilation.plugin("build-module", function(module) {
					moduleCount++;
					const ident = module.identifier();
					if(ident) {
						activeModules.push(ident);
					}
					update();
				});
				compilation.plugin("failed-module", moduleDone);
				compilation.plugin("succeed-module", moduleDone);
				const syncHooks = {
					"seal": [0.71, "sealing"],
					"optimize": [0.72, "optimizing"],
					"optimize-modules-basic": [0.73, "basic module optimization"],
					"optimize-modules": [0.74, "module optimization"],
					"optimize-modules-advanced": [0.75, "advanced module optimization"],
					"optimize-chunks-basic": [0.76, "basic chunk optimization"],
					"optimize-chunks": [0.77, "chunk optimization"],
					"optimize-chunks-advanced": [0.78, "advanced chunk optimization"],
					// optimize-tree
					"revive-modules": [0.80, "module reviving"],
					"optimize-module-order": [0.81, "module order optimization"],
					"optimize-module-ids": [0.82, "module id optimization"],
					"revive-chunks": [0.83, "chunk reviving"],
					"optimize-chunk-order": [0.84, "chunk order optimization"],
					"optimize-chunk-ids": [0.85, "chunk id optimization"],
					"before-hash": [0.86, "hashing"],
					"before-module-assets": [0.87, "module assets processing"],
					"before-chunk-assets": [0.88, "chunk assets processing"],
					"additional-chunk-assets": [0.89, "additional chunk assets processing"],
					"record": [0.90, "recording"]
				};
				Object.keys(syncHooks).forEach(name =&gt; {
					let pass = 0;
					const settings = syncHooks[name];
					compilation.plugin(name, () =&gt; {
						if(pass++ &gt; 0)
							handler(settings[0], settings[1], `pass ${pass}`);
						else
							handler(settings[0], settings[1]);
					});
				});
				compilation.plugin("optimize-tree", (chunks, modules, callback) =&gt; {
					handler(0.79, "module and chunk tree optimization");
					callback();
				});
				compilation.plugin("additional-assets", callback =&gt; {
					handler(0.91, "additional asset processing");
					callback();
				});
				compilation.plugin("optimize-chunk-assets", (chunks, callback) =&gt; {
					handler(0.92, "chunk asset optimization");
					callback();
				});
				compilation.plugin("optimize-assets", (assets, callback) =&gt; {
					handler(0.94, "asset optimization");
					callback(); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ProvidePlugin" id="apidoc.element.webpack.ProvidePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ProvidePlugin
        <span class="apidocSignatureSpan">(definitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ProvidePlugin {
	constructor(definitions) {
		this.definitions = definitions;
	}

	apply(compiler) {
		const definitions = this.definitions;
		compiler.plugin("compilation", (compilation, params) =&gt; {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
			params.normalModuleFactory.plugin("parser", (parser, parserOptions) =&gt; {
				Object.keys(definitions).forEach(name =&gt; {
					var request = [].concat(definitions[name]);
					var splittedName = name.split(".");
					if(splittedName.length &gt; 0) {
						splittedName.slice(1).forEach((_, i) =&gt; {
							const name = splittedName.slice(0, i + 1).join(".");
							parser.plugin(`can-rename ${name}`, ParserHelpers.approve);
						});
					}
					parser.plugin(`expression ${name}`, function(expr) {
						let nameIdentifier = name;
						const scopedName = name.indexOf(".") &gt;= 0;
						let expression = `require(${JSON.stringify(request[0])})`;
						if(scopedName) {
							nameIdentifier = `__webpack_provided_${name.replace(/\./g, "_dot_")}`;
						}
						if(request.length &gt; 1) {
							expression += request.slice(1).map(r =&gt; `[${JSON.stringify(r)}]`).join("");
						}
						if(!ParserHelpers.addParsedVariableToModule(this, nameIdentifier, expression)) {
							return false;
						}
						if(scopedName) {
							ParserHelpers.toConstantDependency(nameIdentifier).bind(this)(expr);
						}
						return true;
					});
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.SetVarMainTemplatePlugin" id="apidoc.element.webpack.SetVarMainTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>SetVarMainTemplatePlugin
        <span class="apidocSignatureSpan">(varExpression, copyObject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SetVarMainTemplatePlugin {
	constructor(varExpression, copyObject) {
		this.varExpression = varExpression;
		this.copyObject = copyObject;
	}

	apply(compilation) {
		const mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", (source, chunk, hash) =&gt; {
			const varExpression = mainTemplate.applyPluginsWaterfall("asset-path", this.varExpression, {
				hash,
				chunk
			});
			if(this.copyObject) {
				return new ConcatSource(`(function(e, a) { for(var i in a) e[i] = a[i]; }(${varExpression}, `, source, "))");
			} else {
				const prefix = `${varExpression} =\n`;
				return new ConcatSource(prefix, source);
			}
		});
		mainTemplate.plugin("global-hash-paths", (paths) =&gt; {
			if(this.varExpression) paths.push(this.varExpression);
			return paths;
		});
		mainTemplate.plugin("hash", hash =&gt; {
			hash.update("set var");
			hash.update(`${this.varExpression}`);
			hash.update(`${this.copyObject}`);
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.SourceMapDevToolPlugin" id="apidoc.element.webpack.SourceMapDevToolPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>SourceMapDevToolPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SourceMapDevToolPlugin {
	constructor(options) {
		if(arguments.length &gt; 1)
			throw new Error("SourceMapDevToolPlugin only takes one argument (pass an options object)");
		// TODO: remove in webpack 3
		if(typeof options === "string") {
			options = {
				sourceMapFilename: options
			};
		}
		if(!options) options = {};
		this.sourceMapFilename = options.filename;
		this.sourceMappingURLComment = options.append === false ? false : options.append || "\n//# sourceMappingURL=[url]";
		this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack:///[resourcePath]";
		this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || "webpack:///[resourcePath]?[hash]";
		this.options = options;
	}

	apply(compiler) {
		const sourceMapFilename = this.sourceMapFilename;
		const sourceMappingURLComment = this.sourceMappingURLComment;
		const moduleFilenameTemplate = this.moduleFilenameTemplate;
		const fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;
		const requestShortener = new RequestShortener(compiler.context);
		const options = this.options;
		options.test = options.test || /\.(js|css)($|\?)/i;
		compiler.plugin("compilation", compilation =&gt; {
			new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
			compilation.plugin("after-optimize-chunk-assets", function(chunks) {
				let allModules = [];
				let allModuleFilenames = [];
				const tasks = [];
				chunks.forEach(function(chunk) {
					chunk.files.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options)).map(function(file) {
						const asset = compilation.assets[file];
						if(asset.__SourceMapDevToolFile === file &amp;&amp; asset.__SourceMapDevToolData) {
							const data = asset.__SourceMapDevToolData;
							for(const cachedFile in data) {
								compilation.assets[cachedFile] = data[cachedFile];
								if(cachedFile !== file)
									chunk.files.push(cachedFile);
							}
							return;
						}
						let source, sourceMap;
						if(asset.sourceAndMap) {
							const sourceAndMap = asset.sourceAndMap(options);
							sourceMap = sourceAndMap.map;
							source = sourceAndMap.source;
						} else {
							sourceMap = asset.map(options);
							source = asset.source();
						}
						if(sourceMap) {
							return {
								chunk,
								file,
								asset,
								source,
								sourceMap
							};
						}
					}).filter(Boolean).map(task =&gt; {
						const modules = task.sourceMap.sources.map(source =&gt; {
							const module = compilation.findModule(source);
							return module || source;
						});
						const moduleFilenames = modules.map(module =&gt; ModuleFilenameHelpers.createFilename(module, moduleFilenameTemplate, requestShortener
));
						task.modules = modules;
						task.moduleFilenames = moduleFilenames;
						return task;
					}).forEach(task =&gt; {
						allModules = allModules.concat(task.modules);
						allModuleFilenames = allModuleFilenames.concat(task.moduleFilenames);
						tasks.push(task);
					});
				});
				allModuleFilenames = ModuleFilenameHelpers.replaceDuplicates(allModuleFilenames, (filename, i) =&gt; ModuleFilenameHelpers.createFilename
(allModules[i], fallbackModuleFilenameTemplate, requestShortener), (ai, bi) =&gt; {
					let a = allModules[ai];
					let b = allModules[bi];
					a = !a ? "" : typeof a === "string" ? a : a.identifier();
					b = !b ? "" : typeof b === "string" ? b : b.identifier();
					return a.length - b.length;
				});
				allModuleFilenames = ModuleFilenameHelpers.replaceDuplicates(allModuleFilenames, (filename, i, n) =&gt; {
					for(let j = 0; j &lt; n; j++)
						filename += "*";
					return filename;
				});
				tasks.forEach(task =&gt; {
					task.moduleFilenames = allModuleFilenames.slice(0, task.moduleFilenames.length);
					allModuleFilenames = allModuleFilenames.slice(task.moduleFilenames.length);
				});
				tasks.forEach(function(task) {
					const chunk = task.chunk;
					const file = task.file;
					const asset = task.asset;
					const sourceMap = task.sou ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.UmdMainTemplatePlugin" id="apidoc.element.webpack.UmdMainTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>UmdMainTemplatePlugin
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class UmdMainTemplatePlugin {
	constructor(name, options) {
		this.name = name;
		this.optionalAmdExternalAsGlobal = options.optionalAmdExternalAsGlobal;
		this.namedDefine = options.namedDefine;
		this.auxiliaryComment = options.auxiliaryComment;
	}

	apply(compilation) {
		const mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", function(source, chunk, hash) {
			let externals = chunk.modules.filter(m =&gt; m.external);
			const optionalExternals = [];
			let requiredExternals = [];
			if(this.optionalAmdExternalAsGlobal) {
				externals.forEach(m =&gt; {
					if(m.optional) {
						optionalExternals.push(m);
					} else {
						requiredExternals.push(m);
					}
				});
				externals = requiredExternals.concat(optionalExternals);
			} else {
				requiredExternals = externals;
			}

			function replaceKeys(str) {
				return mainTemplate.applyPluginsWaterfall("asset-path", str, {
					hash,
					chunk
				});
			}

			function externalsDepsArray(modules) {
				return `[${replaceKeys(modules.map(m =&gt; JSON.stringify(typeof m.request === "object" ? m.request.amd : m.request)).join(", "))}]`;
			}

			function externalsRootArray(modules) {
				return replaceKeys(modules.map(m =&gt; {
					let request = m.request;
					if(typeof request === "object") request = request.root;
					return `root${accessorToObjectAccess([].concat(request))}`;
				}).join(", "));
			}

			function externalsRequireArray(type) {
				return replaceKeys(externals.map(m =&gt; {
					let expr;
					let request = m.request;
					if(typeof request === "object") request = request[type];
					if(Array.isArray(request)) {
						expr = `require(${JSON.stringify(request[0])})${accessorToObjectAccess(request.slice(1))}`;
					} else
						expr = `require(${JSON.stringify(request)})`;
					if(m.optional) {
						expr = `(function webpackLoadOptionalExternalModule() { try { return ${expr}; } catch(e) {} }())`;
					}
					return expr;
				}).join(", "));
			}

			function externalsArguments(modules) {
				return modules.map(m =&gt; Template.toIdentifier(`__WEBPACK_EXTERNAL_MODULE_${m.id}__`)).join(", ");
			}

			function libraryName(library) {
				return JSON.stringify(replaceKeys([].concat(library).pop()));
			}

			let amdFactory;
			if(optionalExternals.length &gt; 0) {
				const wrapperArguments = externalsArguments(requiredExternals);
				const factoryArguments = requiredExternals.length &gt; 0 ?
					externalsArguments(requiredExternals) + ", " + externalsRootArray(optionalExternals) :
					externalsRootArray(optionalExternals);
				amdFactory = `function webpackLoadOptionalExternalModuleAmd(${wrapperArguments}) {\n` +
					`			return factory(${factoryArguments});\n` +
					"		}";
			} else {
				amdFactory = "factory";
			}

			return new ConcatSource(new OriginalSource(
				"(function webpackUniversalModuleDefinition(root, factory) {\n" +
				(this.auxiliaryComment &amp;&amp;
					typeof this.auxiliaryComment === "string" ?
					"   //" + this.auxiliaryComment + "\n" :
					this.auxiliaryComment.commonjs2 ?
					"   //" + this.auxiliaryComment.commonjs2 + "\n" :
					""
				) +
				"	if(typeof exports === 'object' &amp;&amp; typeof module === 'object')\n" +
				"		module.exports = factory(" + externalsRequireArray("commonjs2") + ");\n" +
				(this.auxiliaryComment &amp;&amp;
					typeof this.auxiliaryComment === "string" ?
					"   //" + this.auxiliaryComment + "\n" :
					this.auxiliaryComment.amd ?
					"   //" + this.auxiliaryComment.amd + "\n" :
					""
				) +
				"	else if(typeof define === 'function' &amp;&amp; define.amd)\n" +
				(requiredExternals.length &gt; 0 ?
					(this.name &amp;&amp; this.namedDefine === true ?
						"		define(" + libraryName(this.name) + ", " + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n" :
						"		define(" + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n"
					) :
					(this.name &amp;&amp; this.namedDefine === true ?
						"		define(" + libraryName(this.name) + ", [], " + amdFactory + ");\n" :
						" ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.WatchIgnorePlugin" id="apidoc.element.webpack.WatchIgnorePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>WatchIgnorePlugin
        <span class="apidocSignatureSpan">(paths)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WatchIgnorePlugin {
	constructor(paths) {
		this.paths = paths;
	}

	apply(compiler) {
		compiler.plugin("after-environment", () =&gt; {
			compiler.watchFileSystem = new IgnoringWatchFileSystem(compiler.watchFileSystem, this.paths);
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.WebpackOptionsApply" id="apidoc.element.webpack.WebpackOptionsApply">
        function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsApply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebpackOptionsApply extends OptionsApply {
	constructor() {
		super();
	}

	process(options, compiler) {
		let ExternalsPlugin;
		compiler.outputPath = options.output.path;
		compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;
		compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath;
		compiler.name = options.name;
		compiler.dependencies = options.dependencies;
		if(typeof options.target === "string") {
			let JsonpTemplatePlugin;
			let NodeSourcePlugin;
			let NodeTargetPlugin;
			let NodeTemplatePlugin;

			switch(options.target) {
				case "web":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeSourcePlugin = require("./node/NodeSourcePlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeSourcePlugin(options.node),
						new LoaderTargetPlugin("web")
					);
					break;
				case "webworker":
					{
						let WebWorkerTemplatePlugin = require("./webworker/WebWorkerTemplatePlugin");
						NodeSourcePlugin = require("./node/NodeSourcePlugin");
						compiler.apply(
							new WebWorkerTemplatePlugin(),
							new FunctionModulePlugin(options.output),
							new NodeSourcePlugin(options.node),
							new LoaderTargetPlugin("webworker")
						);
						break;
					}
				case "node":
				case "async-node":
					NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					compiler.apply(
						new NodeTemplatePlugin({
							asyncChunkLoading: options.target === "async-node"
						}),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new LoaderTargetPlugin("node")
					);
					break;
				case "node-webkit":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", "nw.gui"),
						new LoaderTargetPlugin("node-webkit")
					);
					break;
				case "atom":
				case "electron":
				case "electron-main":
					NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new NodeTemplatePlugin({
							asyncChunkLoading: true
						}),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"app",
							"auto-updater",
							"browser-window",
							"content-tracing",
							"dialog",
							"electron",
							"global-shortcut",
							"ipc",
							"ipc-main",
							"menu",
							"menu-item",
							"power-monitor",
							"power-save-blocker",
							"protocol",
							"session",
							"web-contents",
							"tray",
							"clipboard",
							"crash-reporter",
							"native-image",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				case "electron-renderer":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"desktop-capturer",
							"electron",
							"ipc",
							"ipc-renderer",
							"remote",
							"web-frame",
							"clipboard",
							"crash-reporter",
							"native-image",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				default:
					throw new Error("Unsupported target '" + options.target + "'."); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.WebpackOptionsDefaulter" id="apidoc.element.webpack.WebpackOptionsDefaulter">
        function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsDefaulter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebpackOptionsDefaulter extends OptionsDefaulter {
	constructor() {
		super();
		this.set("devtool", false);
		this.set("cache", true);

		this.set("context", process.cwd());
		this.set("target", "web");

		this.set("module.unknownContextRequest", ".");
		this.set("module.unknownContextRegExp", false);
		this.set("module.unknownContextRecursive", true);
		this.set("module.unknownContextCritical", true);
		this.set("module.exprContextRequest", ".");
		this.set("module.exprContextRegExp", false);
		this.set("module.exprContextRecursive", true);
		this.set("module.exprContextCritical", true);
		this.set("module.wrappedContextRegExp", /.*/);
		this.set("module.wrappedContextRecursive", true);
		this.set("module.wrappedContextCritical", false);
		this.set("module.strictExportPresence", false);

		this.set("module.unsafeCache", true);

		this.set("output", "call", (value, options) =&gt; {
			if(typeof value === "string") {
				return {
					filename: value
				};
			} else if(typeof value !== "object") {
				return {};
			} else {
				return value;
			}
		});
		this.set("output.filename", "[name].js");
		this.set("output.chunkFilename", "make", (options) =&gt; {
			const filename = options.output.filename;
			return filename.indexOf("[name]") &gt;= 0 ? filename.replace("[name]", "[id]") : "[id]." + filename;
		});
		this.set("output.library", "");
		this.set("output.hotUpdateFunction", "make", (options) =&gt; {
			return Template.toIdentifier("webpackHotUpdate" + options.output.library);
		});
		this.set("output.jsonpFunction", "make", (options) =&gt; {
			return Template.toIdentifier("webpackJsonp" + options.output.library);
		});
		this.set("output.libraryTarget", "var");
		this.set("output.path", process.cwd());
		this.set("output.sourceMapFilename", "[file].map[query]");
		this.set("output.hotUpdateChunkFilename", "[id].[hash].hot-update.js");
		this.set("output.hotUpdateMainFilename", "[hash].hot-update.json");
		this.set("output.crossOriginLoading", false);
		this.set("output.hashFunction", "md5");
		this.set("output.hashDigest", "hex");
		this.set("output.hashDigestLength", 20);
		this.set("output.devtoolLineToLine", false);
		this.set("output.strictModuleExceptionHandling", false);

		this.set("node", {});
		this.set("node.console", false);
		this.set("node.process", true);
		this.set("node.global", true);
		this.set("node.Buffer", true);
		this.set("node.setImmediate", true);
		this.set("node.__filename", "mock");
		this.set("node.__dirname", "mock");

		this.set("performance.maxAssetSize", 250000);
		this.set("performance.maxEntrypointSize", 250000);
		this.set("performance.hints", false);

		this.set("resolve", {});
		this.set("resolve.unsafeCache", true);
		this.set("resolve.modules", ["node_modules"]);
		this.set("resolve.extensions", [".js", ".json"]);
		this.set("resolve.aliasFields", "make", (options) =&gt; {
			if(options.target === "web" || options.target === "webworker")
				return ["browser"];
			else
				return [];
		});
		this.set("resolve.mainFields", "make", (options) =&gt; {
			if(options.target === "web" || options.target === "webworker")
				return ["browser", "module", "main"];
			else
				return ["module", "main"];
		});
		this.set("resolveLoader", {});
		this.set("resolveLoader.unsafeCache", true);
		this.set("resolveLoader.mainFields", ["loader", "main"]);
		this.set("resolveLoader.extensions", [".js", ".json"]);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.WebpackOptionsValidationError" id="apidoc.element.webpack.WebpackOptionsValidationError">
        function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsValidationError
        <span class="apidocSignatureSpan">(validationErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebpackOptionsValidationError extends WebpackError {
	constructor(validationErrors) {
		super();

		this.name = "WebpackOptionsValidationError";
		this.message = "Invalid configuration object. " +
			"Webpack has been initialised using a configuration object that does not match the API schema.\n" +
			validationErrors.map(err =&gt; " - " + indent(WebpackOptionsValidationError.formatValidationError(err), "   ", false)).join("\n");
		this.validationErrors = validationErrors;

		Error.captureStackTrace(this, this.constructor);
	}

	static formatSchema(schema, prevSchemas) {
		prevSchemas = prevSchemas || [];

		const formatInnerSchema = (innerSchema, addSelf) =&gt; {
			if(!addSelf) return WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas);
			if(prevSchemas.indexOf(innerSchema) &gt;= 0) return "(recursive)";
			return WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas.concat(schema));
		};

		if(schema.type === "string") {
			if(schema.minLength === 1)
				return "non-empty string";
			else if(schema.minLength &gt; 1)
				return `string (min length ${schema.minLength})`;
			return "string";
		} else if(schema.type === "boolean") {
			return "boolean";
		} else if(schema.type === "number") {
			return "number";
		} else if(schema.type === "object") {
			if(schema.properties) {
				const required = schema.required || [];
				return `object { ${Object.keys(schema.properties).map(property =&gt; {
					if(required.indexOf(property) &lt; 0) return property + "?";
					return property;
				}).concat(schema.additionalProperties ? ["..."] : []).join(", ")} }`;
			}
			if(schema.additionalProperties) {
				return `object { &lt;key&gt;: ${formatInnerSchema(schema.additionalProperties)} }`;
			}
			return "object";
		} else if(schema.type === "array") {
			return `[${formatInnerSchema(schema.items)}]`;
		}

		switch(schema.instanceof) {
			case "Function":
				return "function";
			case "RegExp":
				return "RegExp";
		}
		if(schema.$ref) return formatInnerSchema(getSchemaPart(schema.$ref), true);
		if(schema.allOf) return schema.allOf.map(formatInnerSchema).join(" &amp; ");
		if(schema.oneOf) return schema.oneOf.map(formatInnerSchema).join(" | ");
		if(schema.anyOf) return schema.anyOf.map(formatInnerSchema).join(" | ");
		if(schema.enum) return schema.enum.map(item =&gt; JSON.stringify(item)).join(" | ");
		return JSON.stringify(schema, 0, 2);
	}

	static formatValidationError(err) {
		const dataPath = `configuration${err.dataPath}`;
		if(err.keyword === "additionalProperties") {
			const baseMessage = `${dataPath} has an unknown property '${err.params.additionalProperty}'. These properties are valid:\n${getSchemaPartText
(err.parentSchema)}`;
			if(!err.dataPath) {
				switch(err.params.additionalProperty) {
					case "debug":
						return `${baseMessage}\n` +
							"The 'debug' property was removed in webpack 2.\n" +
							"Loaders should be updated to allow passing this option via loader options in module.rules.\n" +
							"Until loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\n" +
							"plugins: [\n" +
							"  new webpack.LoaderOptionsPlugin({\n" +
							"    debug: true\n" +
							"  })\n" +
							"]";
				}
				return baseMessage + "\n" +
					"For typos: please correct them.\n" +
					"For loader options: webpack 2 no longer allows custom properties in configuration.\n" +
					"  Loaders should be updated to allow passing options via loader options in module.rules.\n" +
					"  Until loaders are updated one can use the LoaderOptionsPlugin to pass these options to the loader:\n" +
					"  plugins: [\n" +
					"    new webpack.LoaderOptionsPlugin({\n" +
					"      // test: /\\.xxx$/, // may apply this only for some modules\n" +
					"      options: {\n" +
					`        ${err.params.additionalProperty}: ...\n` +
					"      }\n" +
					"    })\n" +
					"  ]";
			}
			return baseMessage;
		} else if(err.keyword === "oneOf" || err.keyword === "anyOf") {
			if(err.children &amp;&amp; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.validate" id="apidoc.element.webpack.validate">
        function <span class="apidocSignatureSpan">webpack.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.validateSchema" id="apidoc.element.webpack.validateSchema">
        function <span class="apidocSignatureSpan">webpack.</span>validateSchema
        <span class="apidocSignatureSpan">(schema, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateSchema(schema, options) {
	if(Array.isArray(options)) {
		const errors = options.map((options) =&gt; validateObject(schema, options));
		errors.forEach((list, idx) =&gt; {
			list.forEach(function applyPrefix(err) {
				err.dataPath = `[${idx}]${err.dataPath}`;
				if(err.children) {
					err.children.forEach(applyPrefix);
				}
			});
		});
		return errors.reduce((arr, items) =&gt; {
			return arr.concat(items);
		}, []);
	} else {
		return validateObject(schema, options);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.webpack_web" id="apidoc.element.webpack.webpack_web">
        function <span class="apidocSignatureSpan">webpack.</span>webpack_web
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function webpack(options, callback) {
	new WebpackOptionsDefaulter().process(options);

	const compiler = new Compiler();
	compiler.options = options;
	compiler.options = new WebpackOptionsApply().process(options, compiler);
	new WebEnvironmentPlugin(options.inputFileSystem, options.outputFileSystem).apply(compiler);
	if(callback) {
		compiler.run(callback);
	}
	return compiler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Compiler" id="apidoc.module.webpack.Compiler">module webpack.Compiler</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Compiler.Compiler" id="apidoc.element.webpack.Compiler.Compiler">
        function <span class="apidocSignatureSpan">webpack.</span>Compiler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler() {
	Tapable.call(this);

	this.outputPath = "";
	this.outputFileSystem = null;
	this.inputFileSystem = null;

	this.recordsInputPath = null;
	this.recordsOutputPath = null;
	this.records = {};

	this.fileTimestamps = {};
	this.contextTimestamps = {};

	this.resolvers = {
		normal: null,
		loader: null,
		context: null
	};
	var deprecationReported = false;
	this.parser = {
		plugin: function(hook, fn) {
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.plugin(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.plugin(hook, fn);
				});
			});
		}.bind(this),
		apply: function() {
			var args = arguments;
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.apply(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.apply.apply(parser, args);
				});
			});
		}.bind(this)
	};

	this.options = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching" id="apidoc.element.webpack.Compiler.Watching">
        function <span class="apidocSignatureSpan">webpack.Compiler.</span>Watching
        <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Watching(compiler, watchOptions, handler) {
	this.startTime = null;
	this.invalid = false;
	this.error = null;
	this.stats = null;
	this.handler = handler;
	this.closed = false;
	if(typeof watchOptions === "number") {
		this.watchOptions = {
			aggregateTimeout: watchOptions
		};
	} else if(watchOptions &amp;&amp; typeof watchOptions === "object") {
		this.watchOptions = Object.assign({}, watchOptions);
	} else {
		this.watchOptions = {};
	}
	this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200;
	this.compiler = compiler;
	this.running = true;
	this.compiler.readRecords(function(err) {
		if(err) return this._done(err);

		this._go();
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Compiler.Watching" id="apidoc.module.webpack.Compiler.Watching">module webpack.Compiler.Watching</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.Watching" id="apidoc.element.webpack.Compiler.Watching.Watching">
        function <span class="apidocSignatureSpan">webpack.Compiler.</span>Watching
        <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Watching(compiler, watchOptions, handler) {
	this.startTime = null;
	this.invalid = false;
	this.error = null;
	this.stats = null;
	this.handler = handler;
	this.closed = false;
	if(typeof watchOptions === "number") {
		this.watchOptions = {
			aggregateTimeout: watchOptions
		};
	} else if(watchOptions &amp;&amp; typeof watchOptions === "object") {
		this.watchOptions = Object.assign({}, watchOptions);
	} else {
		this.watchOptions = {};
	}
	this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200;
	this.compiler = compiler;
	this.running = true;
	this.compiler.readRecords(function(err) {
		if(err) return this._done(err);

		this._go();
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Compiler.Watching.prototype" id="apidoc.module.webpack.Compiler.Watching.prototype">module webpack.Compiler.Watching.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.prototype._done" id="apidoc.element.webpack.Compiler.Watching.prototype._done">
        function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>_done
        <span class="apidocSignatureSpan">(err, compilation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_done = function (err, compilation) {
	this.running = false;
	if(this.invalid) return this._go();
	this.error = err || null;
	this.stats = compilation ? compilation.getStats() : null;
	if(this.stats) {
		this.stats.startTime = this.startTime;
		this.stats.endTime = new Date().getTime();
	}
	if(this.stats)
		this.compiler.applyPlugins("done", this.stats);
	else
		this.compiler.applyPlugins("failed", this.error);
	this.handler(this.error, this.stats);
	if(!this.error &amp;&amp; !this.closed)
		this.watch(compilation.fileDependencies, compilation.contextDependencies, compilation.missingDependencies);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.prototype._go" id="apidoc.element.webpack.Compiler.Watching.prototype._go">
        function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>_go
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_go = function () {
	var self = this;
	self.startTime = new Date().getTime();
	self.running = true;
	self.invalid = false;
	self.compiler.applyPluginsAsync("watch-run", self, function(err) {
		if(err) return self._done(err);
		self.compiler.compile(function onCompiled(err, compilation) {
			if(err) return self._done(err);
			if(self.invalid) return self._done();

			if(self.compiler.applyPluginsBailResult("should-emit", compilation) === false) {
				return self._done(null, compilation);
			}

			self.compiler.emitAssets(compilation, function(err) {
				if(err) return self._done(err);
				if(self.invalid) return self._done();

				self.compiler.emitRecords(function(err) {
					if(err) return self._done(err);

					if(compilation.applyPluginsBailResult("need-additional-pass")) {
						compilation.needAdditionalPass = true;

						var stats = compilation.getStats();
						stats.startTime = self.startTime;
						stats.endTime = new Date().getTime();
						self.compiler.applyPlugins("done", stats);

						self.compiler.applyPluginsAsync("additional-pass", function(err) {
							if(err) return self._done(err);
							self.compiler.compile(onCompiled);
						});
						return;
					}
					return self._done(null, compilation);
				});
			});
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.prototype.close" id="apidoc.element.webpack.Compiler.Watching.prototype.close">
        function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
	if(callback === undefined) callback = function() {};

	this.closed = true;
	if(this.watcher) {
		this.watcher.close();
		this.watcher = null;
	}
	if(this.pausedWatcher) {
		this.pausedWatcher.close();
		this.pausedWatcher = null;
	}
	if(this.running) {
		this.invalid = true;
		this._done = () =&gt; {
			this.compiler.applyPlugins("watch-close");
			callback();
		};
	} else {
		this.compiler.applyPlugins("watch-close");
		callback();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.watchings.forEach((watching) =&gt; watching.invalidate());
	}

	close(callback) {
		if(callback === undefined) callback = () =&gt; { /*do nothing*/ };

		asyncLib.forEach(this.watchings, (watching, finishedCallback) =&gt; {
			watching.<span class="apidocCodeKeywordSpan">close</span>(finishedCallback);
		}, err =&gt; {
			this.compiler.applyPlugins("watch-close");
			callback(err);
		});

	}
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.prototype.invalidate" id="apidoc.element.webpack.Compiler.Watching.prototype.invalidate">
        function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>invalidate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invalidate = function () {
	if(this.watcher) {
		this.pausedWatcher = this.watcher;
		this.watcher.pause();
		this.watcher = null;
	}
	if(this.running) {
		this.invalid = true;
		return false;
	} else {
		this._go();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
class MultiWatching {
	constructor(watchings, compiler) {
		this.watchings = watchings;
		this.compiler = compiler;
	}

	invalidate() {
		this.watchings.forEach((watching) =&gt; watching.<span class="apidocCodeKeywordSpan">invalidate</span>());
	}

	close(callback) {
		if(callback === undefined) callback = () =&gt; { /*do nothing*/ };

		asyncLib.forEach(this.watchings, (watching, finishedCallback) =&gt; {
			watching.close(finishedCallback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.prototype.watch" id="apidoc.element.webpack.Compiler.Watching.prototype.watch">
        function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>watch
        <span class="apidocSignatureSpan">(files, dirs, missing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watch = function (files, dirs, missing) {
	this.pausedWatcher = null;
	this.watcher = this.compiler.watchFileSystem.watch(files, dirs, missing, this.startTime, this.watchOptions, function(err, filesModified
, contextModified, missingModified, fileTimestamps, contextTimestamps) {
		this.pausedWatcher = this.watcher;
		this.watcher = null;
		if(err) return this.handler(err);

		this.compiler.fileTimestamps = fileTimestamps;
		this.compiler.contextTimestamps = contextTimestamps;
		this.invalidate();
	}.bind(this), function(fileName, changeTime) {
		this.compiler.applyPlugins("invalid", fileName, changeTime);
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		const ignored = path =&gt; this.paths.some(p =&gt; p instanceof RegExp ? p.test(path) : path.indexOf(p) === 0);

		const notIgnored = path =&gt; !ignored(path);

		const ignoredFiles = files.filter(ignored);
		const ignoredDirs = dirs.filter(ignored);

		this.wfs.<span class="apidocCodeKeywordSpan">watch</span>(files.filter(notIgnored), dirs.filter(notIgnored), missing, startTime
, options, (err, filesModified, dirsModified, missingModified, fileTimestamps, dirTimestamps) =&gt; {
			if(err) return callback(err);

			ignoredFiles.forEach(path =&gt; {
				fileTimestamps[path] = 1;
			});

			ignoredDirs.forEach(path =&gt; {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Compiler.prototype" id="apidoc.module.webpack.Compiler.prototype">module webpack.Compiler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.compile" id="apidoc.element.webpack.Compiler.prototype.compile">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>compile
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (callback) {
	var self = this;
	var params = self.newCompilationParams();
	self.applyPluginsAsync("before-compile", params, function(err) {
		if(err) return callback(err);

		self.applyPlugins("compile", params);

		var compilation = self.newCompilation(params);

		self.applyPluginsParallel("make", compilation, function(err) {
			if(err) return callback(err);

			compilation.finish();

			compilation.seal(function(err) {
				if(err) return callback(err);

				self.applyPluginsAsync("after-compile", compilation, function(err) {
					if(err) return callback(err);

					return callback(null, compilation);
				});
			});
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}, []);
	} else {
		return validateObject(schema, options);
	}
}

function validateObject(schema, options) {
	const validate = ajv.<span class="apidocCodeKeywordSpan">compile</span>(schema);
	const valid = validate(options);
	return valid ? [] : filterErrors(validate.errors);
}

function filterErrors(errors) {
	let newErrors = [];
	errors.forEach((err) =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.constructor" id="apidoc.element.webpack.Compiler.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler() {
	Tapable.call(this);

	this.outputPath = "";
	this.outputFileSystem = null;
	this.inputFileSystem = null;

	this.recordsInputPath = null;
	this.recordsOutputPath = null;
	this.records = {};

	this.fileTimestamps = {};
	this.contextTimestamps = {};

	this.resolvers = {
		normal: null,
		loader: null,
		context: null
	};
	var deprecationReported = false;
	this.parser = {
		plugin: function(hook, fn) {
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.plugin(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.plugin(hook, fn);
				});
			});
		}.bind(this),
		apply: function() {
			var args = arguments;
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.apply(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.apply.apply(parser, args);
				});
			});
		}.bind(this)
	};

	this.options = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.createChildCompiler" id="apidoc.element.webpack.Compiler.prototype.createChildCompiler">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createChildCompiler
        <span class="apidocSignatureSpan">(compilation, compilerName, outputOptions, plugins)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChildCompiler = function (compilation, compilerName, outputOptions, plugins) {
	var childCompiler = new Compiler();
	if(Array.isArray(plugins)) {
		plugins.forEach(plugin =&gt; childCompiler.apply(plugin));
	}
	for(var name in this._plugins) {
		if(["make", "compile", "emit", "after-emit", "invalid", "done", "this-compilation"].indexOf(name) &lt; 0)
			childCompiler._plugins[name] = this._plugins[name].slice();
	}
	childCompiler.name = compilerName;
	childCompiler.outputPath = this.outputPath;
	childCompiler.inputFileSystem = this.inputFileSystem;
	childCompiler.outputFileSystem = null;
	childCompiler.resolvers = this.resolvers;
	childCompiler.fileTimestamps = this.fileTimestamps;
	childCompiler.contextTimestamps = this.contextTimestamps;
	if(!this.records[compilerName]) this.records[compilerName] = [];
	this.records[compilerName].push(childCompiler.records = {});
	childCompiler.options = Object.create(this.options);
	childCompiler.options.output = Object.create(childCompiler.options.output);
	for(name in outputOptions) {
		childCompiler.options.output[name] = outputOptions[name];
	}
	childCompiler.parentCompilation = compilation;
	return childCompiler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	getStats() {
		return new Stats(this);
	}

	createChildCompiler(name, outputOptions) {
		return this.compiler.<span class="apidocCodeKeywordSpan">createChildCompiler</span>(this, name, outputOptions);
	}

	checkConstraints() {
		const usedIds = {};

		const modules = this.modules;
		for(let indexModule = 0; indexModule &lt; modules.length; indexModule++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.createCompilation" id="apidoc.element.webpack.Compiler.prototype.createCompilation">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createCompilation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCompilation = function () {
	return new Compilation(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.createContextModuleFactory" id="apidoc.element.webpack.Compiler.prototype.createContextModuleFactory">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createContextModuleFactory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createContextModuleFactory = function () {
	var contextModuleFactory = new ContextModuleFactory(this.resolvers, this.inputFileSystem);
	this.applyPlugins("context-module-factory", contextModuleFactory);
	return contextModuleFactory;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.createNormalModuleFactory" id="apidoc.element.webpack.Compiler.prototype.createNormalModuleFactory">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createNormalModuleFactory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createNormalModuleFactory = function () {
	var normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolvers, this.options.module || {});
	this.applyPlugins("normal-module-factory", normalModuleFactory);
	return normalModuleFactory;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.emitAssets" id="apidoc.element.webpack.Compiler.prototype.emitAssets">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>emitAssets
        <span class="apidocSignatureSpan">(compilation, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emitAssets = function (compilation, callback) {
	var outputPath;

	this.applyPluginsAsync("emit", compilation, function(err) {
		if(err) return callback(err);
		outputPath = compilation.getPath(this.outputPath);
		this.outputFileSystem.mkdirp(outputPath, emitFiles.bind(this));
	}.bind(this));

	function emitFiles(err) {
		if(err) return callback(err);

		require("async").forEach(Object.keys(compilation.assets), function(file, callback) {

			var targetFile = file;
			var queryStringIdx = targetFile.indexOf("?");
			if(queryStringIdx &gt;= 0) {
				targetFile = targetFile.substr(0, queryStringIdx);
			}

			if(targetFile.match(/\/|\\/)) {
				var dir = path.dirname(targetFile);
				this.outputFileSystem.mkdirp(this.outputFileSystem.join(outputPath, dir), writeOut.bind(this));
			} else writeOut.call(this);

			function writeOut(err) {
				if(err) return callback(err);
				var targetPath = this.outputFileSystem.join(outputPath, targetFile);
				var source = compilation.assets[file];
				if(source.existsAt === targetPath) {
					source.emitted = false;
					return callback();
				}
				var content = source.source();

				if(!Buffer.isBuffer(content)) {
					content = new Buffer(content, "utf8"); //eslint-disable-line
				}

				source.existsAt = targetPath;
				source.emitted = true;
				this.outputFileSystem.writeFile(targetPath, content, callback);
			}

		}.bind(this), function(err) {
			if(err) return callback(err);

			afterEmit.call(this);
		}.bind(this));
	}

	function afterEmit() {
		this.applyPluginsAsyncSeries1("after-emit", compilation, function(err) {
			if(err) return callback(err);

			return callback();
		});
	}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.emitRecords" id="apidoc.element.webpack.Compiler.prototype.emitRecords">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>emitRecords
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitRecords(callback) {
	if(!this.recordsOutputPath) return callback();
	var idx1 = this.recordsOutputPath.lastIndexOf("/");
	var idx2 = this.recordsOutputPath.lastIndexOf("\\");
	var recordsOutputPathDirectory = null;
	if(idx1 &gt; idx2) recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);
	if(idx1 &lt; idx2) recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);
	if(!recordsOutputPathDirectory) return writeFile.call(this);
	this.outputFileSystem.mkdirp(recordsOutputPathDirectory, function(err) {
		if(err) return callback(err);
		writeFile.call(this);
	}.bind(this));

	function writeFile() {
		this.outputFileSystem.writeFile(this.recordsOutputPath, JSON.stringify(this.records, undefined, 2), callback);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.isChild" id="apidoc.element.webpack.Compiler.prototype.isChild">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>isChild
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isChild = function () {
	return !!this.parentCompilation;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				if(ident) {
					const idx = activeModules.indexOf(ident);
					if(idx &gt;= 0) activeModules.splice(idx, 1);
				}
				update();
			};
			compiler.plugin("compilation", function(compilation) {
				if(compilation.compiler.<span class="apidocCodeKeywordSpan">isChild</span>()) return;
				lastModulesCount = moduleCount;
				moduleCount = 0;
				doneModules = 0;
				handler(0, "compiling");
				compilation.plugin("build-module", function(module) {
					moduleCount++;
					const ident = module.identifier();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.newCompilation" id="apidoc.element.webpack.Compiler.prototype.newCompilation">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>newCompilation
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newCompilation = function (params) {
	var compilation = this.createCompilation();
	compilation.fileTimestamps = this.fileTimestamps;
	compilation.contextTimestamps = this.contextTimestamps;
	compilation.name = this.name;
	compilation.records = this.records;
	compilation.compilationDependencies = params.compilationDependencies;
	this.applyPlugins("this-compilation", compilation, params);
	this.applyPlugins("compilation", compilation, params);
	return compilation;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.newCompilationParams" id="apidoc.element.webpack.Compiler.prototype.newCompilationParams">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>newCompilationParams
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newCompilationParams = function () {
	var params = {
		normalModuleFactory: this.createNormalModuleFactory(),
		contextModuleFactory: this.createContextModuleFactory(),
		compilationDependencies: []
	};
	return params;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.purgeInputFileSystem" id="apidoc.element.webpack.Compiler.prototype.purgeInputFileSystem">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>purgeInputFileSystem
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purgeInputFileSystem = function () {
	if(this.inputFileSystem &amp;&amp; this.inputFileSystem.purge)
		this.inputFileSystem.purge();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.readRecords" id="apidoc.element.webpack.Compiler.prototype.readRecords">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>readRecords
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readRecords(callback) {
	var self = this;
	if(!self.recordsInputPath) {
		self.records = {};
		return callback();
	}
	self.inputFileSystem.stat(self.recordsInputPath, function(err) {
		// It doesn't exist
		// We can ignore self.
		if(err) return callback();

		self.inputFileSystem.readFile(self.recordsInputPath, function(err, content) {
			if(err) return callback(err);

			try {
				self.records = JSON.parse(content.toString("utf-8"));
			} catch(e) {
				e.message = "Cannot parse records: " + e.message;
				return callback(e);
			}

			return callback();
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.run" id="apidoc.element.webpack.Compiler.prototype.run">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>run
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (callback) {
	var self = this;
	var startTime = new Date().getTime();

	self.applyPluginsAsync("before-run", self, function(err) {
		if(err) return callback(err);

		self.applyPluginsAsync("run", self, function(err) {
			if(err) return callback(err);

			self.readRecords(function(err) {
				if(err) return callback(err);

				self.compile(function onCompiled(err, compilation) {
					if(err) return callback(err);

					if(self.applyPluginsBailResult("should-emit", compilation) === false) {
						var stats = compilation.getStats();
						stats.startTime = startTime;
						stats.endTime = new Date().getTime();
						self.applyPlugins("done", stats);
						return callback(null, stats);
					}

					self.emitAssets(compilation, function(err) {
						if(err) return callback(err);

						if(compilation.applyPluginsBailResult("need-additional-pass")) {
							compilation.needAdditionalPass = true;

							var stats = compilation.getStats();
							stats.startTime = startTime;
							stats.endTime = new Date().getTime();
							self.applyPlugins("done", stats);

							self.applyPluginsAsync("additional-pass", function(err) {
								if(err) return callback(err);
								self.compile(onCompiled);
							});
							return;
						}

						self.emitRecords(function(err) {
							if(err) return callback(err);

							var stats = compilation.getStats();
							stats.startTime = startTime;
							stats.endTime = new Date().getTime();
							self.applyPlugins("done", stats);
							return callback(null, stats);
						});
					});
				});
			});
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	new WebpackOptionsDefaulter().process(options);

	const compiler = new Compiler();
	compiler.options = options;
	compiler.options = new WebpackOptionsApply().process(options, compiler);
	new WebEnvironmentPlugin(options.inputFileSystem, options.outputFileSystem).apply(compiler);
	if(callback) {
		compiler.<span class="apidocCodeKeywordSpan">run</span>(callback);
	}
	return compiler;
}
module.exports = webpack;

webpack.WebpackOptionsDefaulter = WebpackOptionsDefaulter;
webpack.WebpackOptionsApply = WebpackOptionsApply;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.runAsChild" id="apidoc.element.webpack.Compiler.prototype.runAsChild">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>runAsChild
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runAsChild = function (callback) {
	this.compile(function(err, compilation) {
		if(err) return callback(err);

		this.parentCompilation.children.push(compilation);
		Object.keys(compilation.assets).forEach(function(name) {
			this.parentCompilation.assets[name] = compilation.assets[name];
		}.bind(this));

		var entries = Object.keys(compilation.entrypoints).map(function(name) {
			return compilation.entrypoints[name].chunks;
		}).reduce(function(array, chunks) {
			return array.concat(chunks);
		}, []);

		return callback(null, entries, compilation);
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.watch" id="apidoc.element.webpack.Compiler.prototype.watch">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>watch
        <span class="apidocSignatureSpan">(watchOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watch = function (watchOptions, handler) {
	this.fileTimestamps = {};
	this.contextTimestamps = {};
	var watching = new Watching(this, watchOptions, handler);
	return watching;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		const ignored = path =&gt; this.paths.some(p =&gt; p instanceof RegExp ? p.test(path) : path.indexOf(p) === 0);

		const notIgnored = path =&gt; !ignored(path);

		const ignoredFiles = files.filter(ignored);
		const ignoredDirs = dirs.filter(ignored);

		this.wfs.<span class="apidocCodeKeywordSpan">watch</span>(files.filter(notIgnored), dirs.filter(notIgnored), missing, startTime
, options, (err, filesModified, dirsModified, missingModified, fileTimestamps, dirTimestamps) =&gt; {
			if(err) return callback(err);

			ignoredFiles.forEach(path =&gt; {
				fileTimestamps[path] = 1;
			});

			ignoredDirs.forEach(path =&gt; {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ContextModuleFactory" id="apidoc.module.webpack.ContextModuleFactory">module webpack.ContextModuleFactory</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ContextModuleFactory.ContextModuleFactory" id="apidoc.element.webpack.ContextModuleFactory.ContextModuleFactory">
        function <span class="apidocSignatureSpan">webpack.</span>ContextModuleFactory
        <span class="apidocSignatureSpan">(resolvers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ContextModuleFactory(resolvers) {
	Tapable.call(this);
	this.resolvers = resolvers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ContextModuleFactory.prototype" id="apidoc.module.webpack.ContextModuleFactory.prototype">module webpack.ContextModuleFactory.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ContextModuleFactory.prototype.constructor" id="apidoc.element.webpack.ContextModuleFactory.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>constructor
        <span class="apidocSignatureSpan">(resolvers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ContextModuleFactory(resolvers) {
	Tapable.call(this);
	this.resolvers = resolvers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ContextModuleFactory.prototype.create" id="apidoc.element.webpack.ContextModuleFactory.prototype.create">
        function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
	var module = this;
	var context = data.context;
	var dependencies = data.dependencies;
	var dependency = dependencies[0];
	this.applyPluginsAsyncWaterfall("before-resolve", {
		context: context,
		request: dependency.request,
		recursive: dependency.recursive,
		regExp: dependency.regExp,
		async: dependency.async,
		dependencies: dependencies
	}, function(err, result) {
		if(err) return callback(err);

		// Ignored
		if(!result) return callback();

		var context = result.context;
		var request = result.request;
		var recursive = result.recursive;
		var regExp = result.regExp;
		var asyncContext = result.async;
		var dependencies = result.dependencies;

		var loaders, resource, loadersPrefix = "";
		var idx = request.lastIndexOf("!");
		if(idx &gt;= 0) {
			loaders = request.substr(0, idx + 1);
			for(var i = 0; i &lt; loaders.length &amp;&amp; loaders[i] === "!"; i++) {
				loadersPrefix += "!";
			}
			loaders = loaders.substr(i).replace(/!+$/, "").replace(/!!+/g, "!");
			if(loaders === "") loaders = [];
			else loaders = loaders.split("!");
			resource = request.substr(idx + 1);
		} else {
			loaders = [];
			resource = request;
		}

		var resolvers = module.resolvers;

		asyncLib.parallel([
			function(callback) {
				resolvers.context.resolve({}, context, resource, function(err, result) {
					if(err) return callback(err);
					callback(null, result);
				});
			},
			function(callback) {
				asyncLib.map(loaders, function(loader, callback) {
					resolvers.loader.resolve({}, context, loader, function(err, result) {
						if(err) return callback(err);
						callback(null, result);
					});
				}, callback);
			}
		], function(err, result) {
			if(err) return callback(err);

			module.applyPluginsAsyncWaterfall("after-resolve", {
				loaders: loadersPrefix + result[1].join("!") + (result[1].length &gt; 0 ? "!" : ""),
				resource: result[0],
				recursive: recursive,
				regExp: regExp,
				async: asyncContext,
				dependencies: dependencies,
				resolveDependencies: module.resolveDependencies.bind(module)
			}, function(err, result) {
				if(err) return callback(err);

				// Ignored
				if(!result) return callback();

				return callback(null, new ContextModule(result.resolveDependencies, result.resource, result.recursive, result.regExp, result
.loaders, result.async, dependency.chunkName));
			});
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...





module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.<span class="apidocCodeKeywordSpan">create</span>(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ContextModuleFactory.prototype.resolveDependencies" id="apidoc.element.webpack.ContextModuleFactory.prototype.resolveDependencies">
        function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>resolveDependencies
        <span class="apidocSignatureSpan">(fs, resource, recursive, regExp, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveDependencies(fs, resource, recursive, regExp, callback) {
	if(!regExp || !resource)
		return callback(null, []);
	(function addDirectory(directory, callback) {
		fs.readdir(directory, function(err, files) {
			if(err) return callback(err);
			if(!files || files.length === 0) return callback(null, []);
			asyncLib.map(files.filter(function(p) {
				return p.indexOf(".") !== 0;
			}), function(seqment, callback) {

				var subResource = path.join(directory, seqment);

				fs.stat(subResource, function(err, stat) {
					if(err) return callback(err);

					if(stat.isDirectory()) {

						if(!recursive) return callback();
						addDirectory.call(this, subResource, callback);

					} else if(stat.isFile()) {

						var obj = {
							context: resource,
							request: "." + subResource.substr(resource.length).replace(/\\/g, "/")
						};

						this.applyPluginsAsyncWaterfall("alternatives", [obj], function(err, alternatives) {
							if(err) return callback(err);
							alternatives = alternatives.filter(function(obj) {
								return regExp.test(obj.request);
							}).map(function(obj) {
								var dep = new ContextElementDependency(obj.request);
								dep.optional = true;
								return dep;
							});
							callback(null, alternatives);
						});

					} else callback();

				}.bind(this));

			}.bind(this), function(err, result) {
				if(err) return callback(err);

				if(!result) return callback(null, []);

				callback(null, result.filter(function(i) {
					return !!i;
				}).reduce(function(a, i) {
					return a.concat(i);
				}, []));
			});
		}.bind(this));
	}.call(this, resource, callback));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.built = false;
		super.unbuild();
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.builtTime = new Date().getTime();
		this.<span class="apidocCodeKeywordSpan">resolveDependencies</span>(fs, this.context, this.recursive, this.regExp, (err, dependencies
) =&gt; {
			if(err) return callback(err);

			if(!dependencies) {
				this.dependencies = [];
				callback();
				return;
			}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Dependency" id="apidoc.module.webpack.Dependency">module webpack.Dependency</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Dependency.Dependency" id="apidoc.element.webpack.Dependency.Dependency">
        function <span class="apidocSignatureSpan">webpack.</span>Dependency
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Dependency {
	constructor() {
		this.module = null;
	}

	isEqualResource() {
		return false;
	}

	// Returns the referenced module and export
	getReference() {
		if(!this.module) return null;
		return {
			module: this.module,
			importedNames: true, // true: full object, false: only sideeffects/no export, array of strings: the exports with this names
		};
	}

	// Returns the exported names
	getExports() {
		return null;
	}

	getWarnings() {
		return null;
	}

	getErrors() {
		return null;
	}

	updateHash(hash) {
		hash.update((this.module &amp;&amp; this.module.id) + "");
	}

	disconnect() {
		this.module = null;
	}

	// TODO: remove in webpack 3
	compare(a, b) {
		return compareLocations(a.loc, b.loc);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Dependency.compare" id="apidoc.element.webpack.Dependency.compare">
        function <span class="apidocSignatureSpan">webpack.Dependency.</span>compare
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(a, b) =&gt; compareLocations(a.loc, b.loc)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.DynamicEntryPlugin" id="apidoc.module.webpack.DynamicEntryPlugin">module webpack.DynamicEntryPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.DynamicEntryPlugin.DynamicEntryPlugin" id="apidoc.element.webpack.DynamicEntryPlugin.DynamicEntryPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>DynamicEntryPlugin
        <span class="apidocSignatureSpan">(context, entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DynamicEntryPlugin {
	constructor(context, entry) {
		this.context = context;
		this.entry = entry;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			const multiModuleFactory = new MultiModuleFactory();
			const normalModuleFactory = params.normalModuleFactory;

			compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);
			compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
		});

		compiler.plugin("make", (compilation, callback) =&gt; {
			const addEntry = (entry, name) =&gt; {
				const dep = DynamicEntryPlugin.createDependency(entry, name);
				return new Promise((resolve, reject) =&gt; {
					compilation.addEntry(this.context, dep, name, (err) =&gt; {
						if(err) return reject(err);
						resolve();
					});
				});
			};

			Promise.resolve(this.entry()).then((entry) =&gt; {
				if(typeof entry === "string" || Array.isArray(entry)) {
					addEntry(entry, "main").then(() =&gt; callback(), callback);
				} else if(typeof entry === "object") {
					Promise.all(Object.keys(entry).map((name) =&gt; {
						return addEntry(entry[name], name);
					})).then(() =&gt; callback(), callback);
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DynamicEntryPlugin.createDependency" id="apidoc.element.webpack.DynamicEntryPlugin.createDependency">
        function <span class="apidocSignatureSpan">webpack.DynamicEntryPlugin.</span>createDependency
        <span class="apidocSignatureSpan">(entry, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDependency = function (entry, name) {
	if(Array.isArray(entry))
		return MultiEntryPlugin.createDependency(entry, name);
	else
		return SingleEntryPlugin.createDependency(entry, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

			compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);
			compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
		});

		compiler.plugin("make", (compilation, callback) =&gt; {
			const addEntry = (entry, name) =&gt; {
				const dep = DynamicEntryPlugin.<span class="apidocCodeKeywordSpan">createDependency</span>(entry, name);
				return new Promise((resolve, reject) =&gt; {
					compilation.addEntry(this.context, dep, name, (err) =&gt; {
						if(err) return reject(err);
						resolve();
					});
				});
			};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ErrorHelpers" id="apidoc.module.webpack.ErrorHelpers">module webpack.ErrorHelpers</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ErrorHelpers.cleanUp" id="apidoc.element.webpack.ErrorHelpers.cleanUp">
        function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cleanUp
        <span class="apidocSignatureSpan">(stack, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(stack, message) =&gt; {
	stack = exports.cutOffLoaderExecution(stack);
	stack = exports.cutOffMessage(stack, message);
	return stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ErrorHelpers.cutOffLoaderExecution" id="apidoc.element.webpack.ErrorHelpers.cutOffLoaderExecution">
        function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cutOffLoaderExecution
        <span class="apidocSignatureSpan">(stack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(stack) =&gt; {
	stack = stack.split("\n");
	for(let i = 0; i &lt; stack.length; i++)
		if(stack[i].indexOf(loaderFlag) &gt;= 0)
			stack.length = i;
	return stack.join("\n");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ErrorHelpers.cutOffMessage" id="apidoc.element.webpack.ErrorHelpers.cutOffMessage">
        function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cutOffMessage
        <span class="apidocSignatureSpan">(stack, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(stack, message) =&gt; {
	const nextLine = stack.indexOf("\n");
	if(nextLine === -1) {
		return stack === message ? "" : stack;
	} else {
		const firstLine = stack.substr(0, nextLine);
		return firstLine === message ? stack.substr(nextLine + 1) : stack;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.HotModuleReplacementPlugin" id="apidoc.module.webpack.HotModuleReplacementPlugin">module webpack.HotModuleReplacementPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.HotModuleReplacementPlugin.HotModuleReplacementPlugin" id="apidoc.element.webpack.HotModuleReplacementPlugin.HotModuleReplacementPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>HotModuleReplacementPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HotModuleReplacementPlugin(options) {
	options = options || {};
	this.multiStep = options.multiStep;
	this.fullBuildTimeout = options.fullBuildTimeout || 200;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.HotModuleReplacementPlugin.prototype" id="apidoc.module.webpack.HotModuleReplacementPlugin.prototype">module webpack.HotModuleReplacementPlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.HotModuleReplacementPlugin.prototype.apply" id="apidoc.element.webpack.HotModuleReplacementPlugin.prototype.apply">
        function <span class="apidocSignatureSpan">webpack.HotModuleReplacementPlugin.prototype.</span>apply
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (compiler) {
	var multiStep = this.multiStep;
	var fullBuildTimeout = this.fullBuildTimeout;
	var hotUpdateChunkFilename = compiler.options.output.hotUpdateChunkFilename;
	var hotUpdateMainFilename = compiler.options.output.hotUpdateMainFilename;
	compiler.plugin("compilation", function(compilation, params) {
		var hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate;
		if(!hotUpdateChunkTemplate) return;

		var normalModuleFactory = params.normalModuleFactory;

		compilation.dependencyFactories.set(ConstDependency, new NullFactory());
		compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

		compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory);
		compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template());

		compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory);
		compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template());

		compilation.plugin("record", function(compilation, records) {
			if(records.hash === this.hash) return;
			records.hash = compilation.hash;
			records.moduleHashs = {};
			this.modules.forEach(function(module) {
				var identifier = module.identifier();
				var hash = require("crypto").createHash("md5");
				module.updateHash(hash);
				records.moduleHashs[identifier] = hash.digest("hex");
			});
			records.chunkHashs = {};
			this.chunks.forEach(function(chunk) {
				records.chunkHashs[chunk.id] = chunk.hash;
			});
			records.chunkModuleIds = {};
			this.chunks.forEach(function(chunk) {
				records.chunkModuleIds[chunk.id] = chunk.modules.map(function(m) {
					return m.id;
				});
			});
		});
		var initialPass = false;
		var recompilation = false;
		compilation.plugin("after-hash", function() {
			var records = this.records;
			if(!records) {
				initialPass = true;
				return;
			}
			if(!records.hash)
				initialPass = true;
			var preHash = records.preHash || "x";
			var prepreHash = records.prepreHash || "x";
			if(preHash === this.hash) {
				recompilation = true;
				this.modifyHash(prepreHash);
				return;
			}
			records.prepreHash = records.hash || "x";
			records.preHash = this.hash;
			this.modifyHash(records.prepreHash);
		});
		compilation.plugin("should-generate-chunk-assets", function() {
			if(multiStep &amp;&amp; !recompilation &amp;&amp; !initialPass)
				return false;
		});
		compilation.plugin("need-additional-pass", function() {
			if(multiStep &amp;&amp; !recompilation &amp;&amp; !initialPass)
				return true;
		});
		compiler.plugin("additional-pass", function(callback) {
			if(multiStep)
				return setTimeout(callback, fullBuildTimeout);
			return callback();
		});
		compilation.plugin("additional-chunk-assets", function() {
			var records = this.records;
			if(records.hash === this.hash) return;
			if(!records.moduleHashs || !records.chunkHashs || !records.chunkModuleIds) return;
			this.modules.forEach(function(module) {
				var identifier = module.identifier();
				var hash = require("crypto").createHash("md5");
				module.updateHash(hash);
				hash = hash.digest("hex");
				module.hotUpdate = records.moduleHashs[identifier] !== hash;
			});
			var hotUpdateMainContent = {
				h: this.hash,
				c: {}
			};
			Object.keys(records.chunkHashs).forEach(function(chunkId) {
				chunkId = isNaN(+chunkId) ? chunkId : +chunkId;
				var currentChunk = this.chunks.find(chunk =&gt; chunk.id === chunkId);
				if(currentChunk) {
					var newModules = currentChunk.modules.filter(function(module) {
						return module.hotUpdate;
					});
					var allModules = {};
					currentChunk.modules.forEach(function(module) {
						allModules[module.id] = true;
					});
					var removedModules = records.chunkModuleIds[chunkId].filter(function(id) {
						return !allModules[id];
					});
					if(newModules.length &gt; 0 || removedModules.length &gt; 0) {
						var source = hotUpdateChunkTemplate.render(chunkId, newModules, removedM ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.<span class="apidocCodeKeywordSpan">apply</span>(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.MemoryOutputFileSystem" id="apidoc.module.webpack.MemoryOutputFileSystem">module webpack.MemoryOutputFileSystem</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.MemoryOutputFileSystem" id="apidoc.element.webpack.MemoryOutputFileSystem.MemoryOutputFileSystem">
        function <span class="apidocSignatureSpan">webpack.</span>MemoryOutputFileSystem
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryFileSystem(data) {
	this.data = data || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.MemoryOutputFileSystem.prototype" id="apidoc.module.webpack.MemoryOutputFileSystem.prototype">module webpack.MemoryOutputFileSystem.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype._remove" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype._remove">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>_remove
        <span class="apidocSignatureSpan">(_path, name, testFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_remove = function (_path, name, testFn) {
	var path = pathToArray(_path);
	if(path.length === 0) {
		throw new MemoryFileSystemError(errors.code.EPERM, _path);
	}
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	}
	if(!testFn(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	delete current[path[i]];
	return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.createReadStream" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.createReadStream">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>createReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createReadStream = function (path, options) {
	var stream = new ReadableStream();
	var done = false;
	var data;
	try {
		data = this.readFileSync(path);
	} catch (e) {
		stream._read = function() {
			if (done) {
				return;
			}
			done = true;
			this.emit('error', e);
			this.push(null);
		};
		return stream;
	}
	options = options || { };
	options.start = options.start || 0;
	options.end = options.end || data.length;
	stream._read = function() {
		if (done) {
			return;
		}
		done = true;
		this.push(data.slice(options.start, options.end));
		this.push(null);
	};
	return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.createWriteStream" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.createWriteStream">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>createWriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWriteStream = function (path, options) {
	var stream = new WritableStream(), self = this;
	try {
		// Zero the file and make sure it is writable
		this.writeFileSync(path, new Buffer(0));
	} catch(e) {
		// This or setImmediate?
		stream.once('prefinish', function() {
			stream.emit('error', e);
		});
		return stream;
	}
	var bl = [ ], len = 0;
	stream._write = function(chunk, encoding, callback) {
		bl.push(chunk);
		len += chunk.length;
		self.writeFile(path, Buffer.concat(bl, len), callback);
	}
	return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.exists" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.exists">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>exists
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (path, callback) {
	return callback(this.existsSync(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.existsSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.existsSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>existsSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existsSync = function (_path) {
	return !!this.meta(_path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.join" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.join">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>join
        <span class="apidocSignatureSpan">(path, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function join(path, request) {
	if(!request) return normalize(path);
	if(absoluteWinRegExp.test(request)) return normalize(request.replace(/\//g, "\\"));
	if(absoluteNixRegExp.test(request)) return normalize(request);
	if(path == "/") return normalize(path + request);
	if(absoluteWinRegExp.test(path)) return normalize(path.replace(/\//g, "\\") + "\\" + request.replace(/\//g, "\\"));
	if(absoluteNixRegExp.test(path)) return normalize(path + "/" + request);
	return normalize(path + "/" + request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		compilation.templatesPlugin("render-with-entry", (source, chunk, hash) =&gt; {
			const externals = chunk.modules.filter((m) =&gt; m.external);
			const externalsDepsArray = JSON.stringify(externals.map((m) =&gt;
				typeof m.request === "object" ? m.request.amd : m.request
			));
			const externalsArguments = externals.map((m) =&gt;
				Template.toIdentifier(`__WEBPACK_EXTERNAL_MODULE_${m.id}__`)
			).<span class="apidocCodeKeywordSpan">join</span>(", ");

			if(this.name) {
				const name = mainTemplate.applyPluginsWaterfall("asset-path", this.name, {
					hash,
					chunk
				});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.meta" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.meta">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>meta
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">meta = function (_path) {
	var path = pathToArray(_path);
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			return;
		current = current[path[i]];
	}
	return current[path[i]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdir" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdir">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdir
        <span class="apidocSignatureSpan">(path, optArg, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdir = function (path, optArg, callback) {
		if(!callback) {
			callback = optArg;
			optArg = undefined;
		}
		try {
			var result = this[fn + "Sync"](path, optArg);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirSync = function (_path) {
	var path = pathToArray(_path);
	if(path.length === 0) return;
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	}
	if(isDir(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.EEXIST, _path);
	else if(isFile(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);
	current[path[i]] = {"":true};
	return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirp" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirp">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirp
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirp = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
								};
							}
						}
						return obj;
					}, {})
				};
				const content = new Buffer(JSON.stringify(manifest, null, 2), "utf8"); //eslint-disable-line
				compiler.outputFileSystem.<span class="apidocCodeKeywordSpan">mkdirp</span>(path.dirname(targetPath), err =&gt; {
					if(err) return callback(err);
					compiler.outputFileSystem.writeFile(targetPath, content, callback);
				});
			}, callback);
		});
	}
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirpSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirpSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirpSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirpSync = function (_path) {
	var path = pathToArray(_path);
	if(path.length === 0) return;
	var current = this.data;
	for(var i = 0; i &lt; path.length; i++) {
		if(isFile(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);
		else if(!isDir(current[path[i]]))
			current[path[i]] = {"":true};
		current = current[path[i]];
	}
	return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.normalize" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.normalize">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>normalize
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalize(path) {
	var parts = path.split(/(\\+|\/+)/);
	if(parts.length === 1)
		return path;
	var result = [];
	var absolutePathStart = 0;
	for(var i = 0, sep = false; i &lt; parts.length; i++, sep = !sep) {
		var part = parts[i];
		if(i === 0 &amp;&amp; /^([A-Z]:)?$/i.test(part)) {
			result.push(part);
			absolutePathStart = 2;
		} else if(sep) {
			result.push(part[0]);
		} else if(part === "..") {
			switch(result.length) {
				case 0:
					// i. e. ".." =&gt; ".."
					// i. e. "../a/b/c" =&gt; "../a/b/c"
					result.push(part);
					break;
				case 2:
					// i. e. "a/.." =&gt; ""
					// i. e. "/.." =&gt; "/"
					// i. e. "C:\.." =&gt; "C:\"
					// i. e. "a/../b/c" =&gt; "b/c"
					// i. e. "/../b/c" =&gt; "/b/c"
					// i. e. "C:\..\a\b\c" =&gt; "C:\a\b\c"
					i++;
					sep = !sep;
					result.length = absolutePathStart;
					break;
				case 4:
					// i. e. "a/b/.." =&gt; "a"
					// i. e. "/a/.." =&gt; "/"
					// i. e. "C:\a\.." =&gt; "C:\"
					// i. e. "/a/../b/c" =&gt; "/b/c"
					if(absolutePathStart === 0) {
						result.length -= 3;
					} else {
						i++;
						sep = !sep;
						result.length = 2;
					}
					break;
				default:
					// i. e. "/a/b/.." =&gt; "/a"
					// i. e. "/a/b/../c" =&gt; "/a/c"
					result.length -= 3;
					break;
			}
		} else if(part === ".") {
			switch(result.length) {
				case 0:
					// i. e. "." =&gt; "."
					// i. e. "./a/b/c" =&gt; "./a/b/c"
					result.push(part);
					break;
				case 2:
					// i. e. "a/." =&gt; "a"
					// i. e. "/." =&gt; "/"
					// i. e. "C:\." =&gt; "C:\"
					// i. e. "C:\.\a\b\c" =&gt; "C:\a\b\c"
					if(absolutePathStart === 0) {
						result.length--;
					} else {
						i++;
						sep = !sep;
					}
					break;
				default:
					// i. e. "a/b/." =&gt; "a/b"
					// i. e. "/a/." =&gt; "/"
					// i. e. "C:\a\." =&gt; "C:\"
					// i. e. "a/./b/c" =&gt; "a/b/c"
					// i. e. "/a/./b/c" =&gt; "/a/b/c"
					result.length--;
					break;
			}
		} else if(part) {
			result.push(part);
		}
	}
	if(result.length === 1 &amp;&amp; /^[A-Za-z]:$/.test(result))
		return result[0] + "\\";
	return result.join("");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.pathToArray" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.pathToArray">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>pathToArray
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pathToArray(path) {
	path = normalize(path);
	var nix = /^\//.test(path);
	if(!nix) {
		if(!/^[A-Za-z]:/.test(path)) {
			throw new MemoryFileSystemError(errors.code.EINVAL, path);
		}
		path = path.replace(/[\\\/]+/g, "\\"); // multi slashs
		path = path.split(/[\\\/]/);
		path[0] = path[0].toUpperCase();
	} else {
		path = path.replace(/\/+/g, "/"); // multi slashs
		path = path.substr(1).split("/");
	}
	if(!path[path.length-1]) path.pop();
	return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFile" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFile">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readFile
        <span class="apidocSignatureSpan">(path, optArg, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFile = function (path, optArg, callback) {
		if(!callback) {
			callback = optArg;
			optArg = undefined;
		}
		try {
			var result = this[fn + "Sync"](path, optArg);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			compilation.dependencyFactories.set(DelegatedSourceDependency, normalModuleFactory);
		});

		compiler.plugin("before-compile", (params, callback) =&gt; {
			const manifest = this.options.manifest;
			if(typeof manifest === "string") {
				params.compilationDependencies.push(manifest);
				compiler.inputFileSystem.<span class="apidocCodeKeywordSpan">readFile</span>(manifest, function(err, result) {
					if(err) return callback(err);
					params["dll reference " + manifest] = JSON.parse(result.toString("utf-8"));
					return callback();
				});
			} else {
				return callback();
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFileSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFileSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readFileSync
        <span class="apidocSignatureSpan">(_path, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFileSync = function (_path, encoding) {
	var path = pathToArray(_path);
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	}
	if(!isFile(current[path[i]])) {
		if(isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.EISDIR, _path);
		else
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	}
	current = current[path[i]];
	return encoding ? current.toString(encoding) : current;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdir" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdir">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readdir
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdir = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	});
};

ContextModuleFactory.prototype.resolveDependencies = function resolveDependencies(fs, resource, recursive, regExp, callback) {
	if(!regExp || !resource)
		return callback(null, []);
	(function addDirectory(directory, callback) {
		fs.<span class="apidocCodeKeywordSpan">readdir</span>(directory, function(err, files) {
			if(err) return callback(err);
			if(!files || files.length === 0) return callback(null, []);
			asyncLib.map(files.filter(function(p) {
				return p.indexOf(".") !== 0;
			}), function(seqment, callback) {

				var subResource = path.join(directory, seqment);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdirSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdirSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readdirSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdirSync = function (_path) {
	if(_path === "/") return Object.keys(this.data).filter(Boolean);
	var path = pathToArray(_path);
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	}
	if(!isDir(current[path[i]])) {
		if(isFile(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);
		else
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	}
	return Object.keys(current[path[i]]).filter(Boolean);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlink" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlink">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readlink
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlink = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlinkSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlinkSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readlinkSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlinkSync = function (_path) {
	throw new MemoryFileSystemError(errors.code.ENOSYS, _path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdir" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdir">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>rmdir
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdir = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdirSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdirSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>rmdirSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdirSync = function (_path) {
	return this._remove(_path, "Directory", isDir);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.stat" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.stat">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>stat
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stat = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				callback();
			});
			compiler.plugin("run", (compiler, callback) =&gt; {
				if(!compiler._lastCompilationFileDependencies) return callback();
				const fs = compiler.inputFileSystem;
				const fileTs = compiler.fileTimestamps = {};
				asyncLib.forEach(compiler._lastCompilationFileDependencies, (file, callback) =&gt; {
					fs.<span class="apidocCodeKeywordSpan">stat</span>(file, (err, stat) =&gt; {
						if(err) {
							if(err.code === "ENOENT") return callback();
							return callback(err);
						}

						if(stat.mtime)
							this.applyMtime(+stat.mtime);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.statSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.statSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>statSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statSync = function (_path) {
	var current = this.meta(_path);
	if(_path === "/" || isDir(current)) {
		return {
			isFile: falseFn,
			isDirectory: trueFn,
			isBlockDevice: falseFn,
			isCharacterDevice: falseFn,
			isSymbolicLink: falseFn,
			isFIFO: falseFn,
			isSocket: falseFn
		};
	} else if(isFile(current)) {
		return {
			isFile: trueFn,
			isDirectory: falseFn,
			isBlockDevice: falseFn,
			isCharacterDevice: falseFn,
			isSymbolicLink: falseFn,
			isFIFO: falseFn,
			isSocket: falseFn
		};
	} else {
		throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlink" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlink">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>unlink
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlinkSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlinkSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>unlinkSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlinkSync = function (_path) {
	return this._remove(_path, "File", isFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFile" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFile">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>writeFile
        <span class="apidocSignatureSpan">(path, content, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFile = function (path, content, encoding, callback) {
	if(!callback) {
		callback = encoding;
		encoding = undefined;
	}
	try {
		this.writeFileSync(path, content, encoding);
	} catch(e) {
		return callback(e);
	}
	return callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFileSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFileSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>writeFileSync
        <span class="apidocSignatureSpan">(_path, content, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFileSync = function (_path, content, encoding) {
	if(!content &amp;&amp; !encoding) throw new Error("No content");
	var path = pathToArray(_path);
	if(path.length === 0) {
		throw new MemoryFileSystemError(errors.code.EISDIR, _path);
	}
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	}
	if(isDir(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.EISDIR, _path);
	current[path[i]] = encoding || typeof content === "string" ? new Buffer(content, encoding) : content;
	return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ModuleFilenameHelpers" id="apidoc.module.webpack.ModuleFilenameHelpers">module webpack.ModuleFilenameHelpers</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ModuleFilenameHelpers.createFilename" id="apidoc.element.webpack.ModuleFilenameHelpers.createFilename">
        function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>createFilename
        <span class="apidocSignatureSpan">(module, moduleFilenameTemplate, requestShortener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFilename(module, moduleFilenameTemplate, requestShortener) {
	let absoluteResourcePath;
	let hash;
	let identifier;
	let moduleId;
	let shortIdentifier;
	if(module === undefined) module = "";
	if(typeof module === "string") {
		shortIdentifier = requestShortener.shorten(module);
		identifier = shortIdentifier;
		moduleId = "";
		absoluteResourcePath = module.split("!").pop();
		hash = getHash(identifier);
	} else {
		shortIdentifier = module.readableIdentifier(requestShortener);
		identifier = requestShortener.shorten(module.identifier());
		moduleId = module.id;
		absoluteResourcePath = module.identifier().split("!").pop();
		hash = getHash(identifier);
	}
	const resource = shortIdentifier.split("!").pop();
	const loaders = getBefore(shortIdentifier, "!");
	const allLoaders = getBefore(identifier, "!");
	const query = getAfter(resource, "?");
	const resourcePath = resource.substr(0, resource.length - query.length);
	if(typeof moduleFilenameTemplate === "function") {
		return moduleFilenameTemplate({
			identifier: identifier,
			shortIdentifier: shortIdentifier,
			resource: resource,
			resourcePath: resourcePath,
			absoluteResourcePath: absoluteResourcePath,
			allLoaders: allLoaders,
			query: query,
			moduleId: moduleId,
			hash: hash
		});
	}
	return moduleFilenameTemplate
		.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE, identifier)
		.replace(ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE, shortIdentifier)
		.replace(ModuleFilenameHelpers.REGEXP_RESOURCE, resource)
		.replace(ModuleFilenameHelpers.REGEXP_RESOURCE_PATH, resourcePath)
		.replace(ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH, absoluteResourcePath)
		.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS, allLoaders)
		.replace(ModuleFilenameHelpers.REGEXP_LOADERS, loaders)
		.replace(ModuleFilenameHelpers.REGEXP_QUERY, query)
		.replace(ModuleFilenameHelpers.REGEXP_ID, moduleId)
		.replace(ModuleFilenameHelpers.REGEXP_HASH, hash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.sourceUrlComment = sourceUrlComment || "\n//# sourceURL=[url]";
		this.moduleFilenameTemplate = moduleFilenameTemplate || "webpack:///[resourcePath]?[loaders]";
	}

	apply(moduleTemplate) {
		moduleTemplate.plugin("module", (source, module) =&gt; {
			const content = source.source();
			const str = ModuleFilenameHelpers.<span class="apidocCodeKeywordSpan">createFilename</span>(module, this.moduleFilenameTemplate
, moduleTemplate.requestShortener);
			const footer = ["\n",
				ModuleFilenameHelpers.createFooter(module, moduleTemplate.requestShortener),
				this.sourceUrlComment.replace(/\[url\]/g, encodeURI(str).replace(/%2F/g, "/").replace(/%20/g, "_").replace
(/%5E/g, "^").replace(/%5C/g, "\\").replace(/^\//, ""))
			].join("\n");
			return new RawSource(`eval(${JSON.stringify(content + footer)});`);
		});
		moduleTemplate.plugin("hash", hash =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ModuleFilenameHelpers.createFooter" id="apidoc.element.webpack.ModuleFilenameHelpers.createFooter">
        function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>createFooter
        <span class="apidocSignatureSpan">(module, requestShortener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFooter(module, requestShortener) {
	if(!module) module = "";
	if(typeof module === "string") {
		return [
			"// WEBPACK FOOTER //",
			`// ${requestShortener.shorten(module)}`
		].join("\n");
	} else {
		return [
			"//////////////////",
			"// WEBPACK FOOTER",
			`// ${module.readableIdentifier(requestShortener)}`,
			`// module id = ${module.id}`,
			`// module chunks = ${module.chunks.map(c =&gt; c.id).join(" ")}`
		].join("\n");
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	apply(moduleTemplate) {
		moduleTemplate.plugin("module", (source, module) =&gt; {
			const content = source.source();
			const str = ModuleFilenameHelpers.createFilename(module, this.moduleFilenameTemplate, moduleTemplate.requestShortener);
			const footer = ["\n",
				ModuleFilenameHelpers.<span class="apidocCodeKeywordSpan">createFooter</span>(module, moduleTemplate.requestShortener),
				this.sourceUrlComment.replace(/\[url\]/g, encodeURI(str).replace(/%2F/g, "/").replace(/%20/g, "_").replace
(/%5E/g, "^").replace(/%5C/g, "\\").replace(/^\//, ""))
			].join("\n");
			return new RawSource(`eval(${JSON.stringify(content + footer)});`);
		});
		moduleTemplate.plugin("hash", hash =&gt; {
			hash.update("EvalDevToolModuleTemplatePlugin");
			hash.update("2");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ModuleFilenameHelpers.matchObject" id="apidoc.element.webpack.ModuleFilenameHelpers.matchObject">
        function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>matchObject
        <span class="apidocSignatureSpan">(obj, str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchObject(obj, str) {
	if(obj.test)
		if(!ModuleFilenameHelpers.matchPart(str, obj.test)) return false;
	if(obj.include)
		if(!ModuleFilenameHelpers.matchPart(str, obj.include)) return false;
	if(obj.exclude)
		if(ModuleFilenameHelpers.matchPart(str, obj.exclude)) return false;
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("normal-module-loader", (context, module) =&gt; {
				const resource = module.resource;
				if(!resource) return;
				const i = resource.indexOf("?");
				if(ModuleFilenameHelpers.<span class="apidocCodeKeywordSpan">matchObject</span>(options, i &lt; 0 ? resource : resource.substr
(0, i))) {
					const filterSet = new Set(["include", "exclude", "test"]);
					Object.keys(options)
						.filter((key) =&gt; !filterSet.has(key))
						.forEach((key) =&gt; context[key] = options[key]);
				}
			});
		});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ModuleFilenameHelpers.matchPart" id="apidoc.element.webpack.ModuleFilenameHelpers.matchPart">
        function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>matchPart
        <span class="apidocSignatureSpan">(str, test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchPart(str, test) {
	if(!test) return true;
	test = asRegExp(test);
	if(Array.isArray(test)) {
		return test.map(asRegExp).filter(function(regExp) {
			return regExp.test(str);
		}).length &gt; 0;
	} else {
		return test.test(str);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ModuleFilenameHelpers.replaceDuplicates" id="apidoc.element.webpack.ModuleFilenameHelpers.replaceDuplicates">
        function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>replaceDuplicates
        <span class="apidocSignatureSpan">(array, fn, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceDuplicates(array, fn, comparator) {
	const countMap = Object.create(null);
	const posMap = Object.create(null);
	array.forEach((item, idx) =&gt; {
		countMap[item] = (countMap[item] || []);
		countMap[item].push(idx);
		posMap[item] = 0;
	});
	if(comparator) {
		Object.keys(countMap).forEach(item =&gt; {
			countMap[item].sort(comparator);
		});
	}
	return array.map((item, i) =&gt; {
		if(countMap[item].length &gt; 1) {
			if(comparator &amp;&amp; countMap[item][0] === i)
				return item;
			return fn(item, i, posMap[item]++);
		} else return item;
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			const modules = sourceMap.sources.map(function(source) {
				const module = self.compilation.findModule(source);
				return module || source;
			});
			let moduleFilenames = modules.map(function(module) {
				return ModuleFilenameHelpers.createFilename(module, self.moduleFilenameTemplate, this.requestShortener);
			}, this);
			moduleFilenames = ModuleFilenameHelpers.<span class="apidocCodeKeywordSpan">replaceDuplicates</span>(moduleFilenames, function
(filename, i, n) {
				for(let j = 0; j &lt; n; j++)
					filename += "*";
				return filename;
			});
			sourceMap.sources = moduleFilenames;
			if(sourceMap.sourcesContent) {
				sourceMap.sourcesContent = sourceMap.sourcesContent.map(function(content, i) {
...</pre></li>
    </ul>










































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.MultiCompiler" id="apidoc.module.webpack.MultiCompiler">module webpack.MultiCompiler</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler.MultiCompiler" id="apidoc.element.webpack.MultiCompiler.MultiCompiler">
        function <span class="apidocSignatureSpan">webpack.</span>MultiCompiler
        <span class="apidocSignatureSpan">(compilers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiCompiler(compilers) {
	Tapable.call(this);
	if(!Array.isArray(compilers)) {
		compilers = Object.keys(compilers).map(function(name) {
			compilers[name].name = name;
			return compilers[name];
		});
	}
	this.compilers = compilers;

	function delegateProperty(name) {
		Object.defineProperty(this, name, {
			configurable: false,
			get: function() {
				throw new Error("Cannot read " + name + " of a MultiCompiler");
			},
			set: function(value) {
				this.compilers.forEach(function(compiler) {
					compiler[name] = value;
				});
			}.bind(this)
		});
	}
	delegateProperty.call(this, "outputFileSystem");
	delegateProperty.call(this, "inputFileSystem");

	Object.defineProperty(this, "outputPath", {
		configurable: false,
		get: function() {
			var commonPath = compilers[0].outputPath;
			for(var i = 1; i &lt; compilers.length; i++) {
				while(compilers[i].outputPath.indexOf(commonPath) !== 0 &amp;&amp; /[\/\\]/.test(commonPath)) {
					commonPath = commonPath.replace(/[\/\\][^\/\\]*$/, "");
				}
			}
			if(!commonPath &amp;&amp; compilers[0].outputPath[0] === "/") return "/";
			return commonPath;
		}
	});

	var doneCompilers = 0;
	var compilerStats = [];
	this.compilers.forEach(function(compiler, idx) {
		var compilerDone = false;
		compiler.plugin("done", function(stats) {
			if(!compilerDone) {
				compilerDone = true;
				doneCompilers++;
			}
			compilerStats[idx] = stats;
			if(doneCompilers === this.compilers.length) {
				this.applyPlugins("done", new MultiStats(compilerStats));
			}
		}.bind(this));
		compiler.plugin("invalid", function() {
			if(compilerDone) {
				compilerDone = false;
				doneCompilers--;
			}
			this.applyPlugins("invalid");
		}.bind(this));
	}, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.MultiCompiler.prototype" id="apidoc.module.webpack.MultiCompiler.prototype">module webpack.MultiCompiler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler.prototype.constructor" id="apidoc.element.webpack.MultiCompiler.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>constructor
        <span class="apidocSignatureSpan">(compilers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiCompiler(compilers) {
	Tapable.call(this);
	if(!Array.isArray(compilers)) {
		compilers = Object.keys(compilers).map(function(name) {
			compilers[name].name = name;
			return compilers[name];
		});
	}
	this.compilers = compilers;

	function delegateProperty(name) {
		Object.defineProperty(this, name, {
			configurable: false,
			get: function() {
				throw new Error("Cannot read " + name + " of a MultiCompiler");
			},
			set: function(value) {
				this.compilers.forEach(function(compiler) {
					compiler[name] = value;
				});
			}.bind(this)
		});
	}
	delegateProperty.call(this, "outputFileSystem");
	delegateProperty.call(this, "inputFileSystem");

	Object.defineProperty(this, "outputPath", {
		configurable: false,
		get: function() {
			var commonPath = compilers[0].outputPath;
			for(var i = 1; i &lt; compilers.length; i++) {
				while(compilers[i].outputPath.indexOf(commonPath) !== 0 &amp;&amp; /[\/\\]/.test(commonPath)) {
					commonPath = commonPath.replace(/[\/\\][^\/\\]*$/, "");
				}
			}
			if(!commonPath &amp;&amp; compilers[0].outputPath[0] === "/") return "/";
			return commonPath;
		}
	});

	var doneCompilers = 0;
	var compilerStats = [];
	this.compilers.forEach(function(compiler, idx) {
		var compilerDone = false;
		compiler.plugin("done", function(stats) {
			if(!compilerDone) {
				compilerDone = true;
				doneCompilers++;
			}
			compilerStats[idx] = stats;
			if(doneCompilers === this.compilers.length) {
				this.applyPlugins("done", new MultiStats(compilerStats));
			}
		}.bind(this));
		compiler.plugin("invalid", function() {
			if(compilerDone) {
				compilerDone = false;
				doneCompilers--;
			}
			this.applyPlugins("invalid");
		}.bind(this));
	}, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler.prototype.purgeInputFileSystem" id="apidoc.element.webpack.MultiCompiler.prototype.purgeInputFileSystem">
        function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>purgeInputFileSystem
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purgeInputFileSystem = function () {
	this.compilers.forEach(function(compiler) {
		if(compiler.inputFileSystem &amp;&amp; compiler.inputFileSystem.purge)
			compiler.inputFileSystem.purge();
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler.prototype.run" id="apidoc.element.webpack.MultiCompiler.prototype.run">
        function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>run
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (callback) {
	var allStats = this.compilers.map(function() {
		return null;
	});

	runWithDependencies(this.compilers, function(compiler, callback) {
		var compilerIdx = this.compilers.indexOf(compiler);
		compiler.run(function(err, stats) {
			if(err) return callback(err);
			allStats[compilerIdx] = stats;
			callback();
		});
	}.bind(this), function(err) {
		if(err) return callback(err);
		callback(null, new MultiStats(allStats));
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	new WebpackOptionsDefaulter().process(options);

	const compiler = new Compiler();
	compiler.options = options;
	compiler.options = new WebpackOptionsApply().process(options, compiler);
	new WebEnvironmentPlugin(options.inputFileSystem, options.outputFileSystem).apply(compiler);
	if(callback) {
		compiler.<span class="apidocCodeKeywordSpan">run</span>(callback);
	}
	return compiler;
}
module.exports = webpack;

webpack.WebpackOptionsDefaulter = WebpackOptionsDefaulter;
webpack.WebpackOptionsApply = WebpackOptionsApply;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler.prototype.watch" id="apidoc.element.webpack.MultiCompiler.prototype.watch">
        function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>watch
        <span class="apidocSignatureSpan">(watchOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watch = function (watchOptions, handler) {
	var watchings = [];
	var allStats = this.compilers.map(function() {
		return null;
	});
	var compilerStatus = this.compilers.map(function() {
		return false;
	});
	runWithDependencies(this.compilers, function(compiler, callback) {
		var compilerIdx = this.compilers.indexOf(compiler);
		var firstRun = true;
		var watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[compilerIdx] : watchOptions, function(err, stats) {
			if(err)
				handler(err);
			if(stats) {
				allStats[compilerIdx] = stats;
				compilerStatus[compilerIdx] = "new";
				if(compilerStatus.every(Boolean)) {
					var freshStats = allStats.filter(function(s, idx) {
						return compilerStatus[idx] === "new";
					});
					compilerStatus.fill(true);
					var multiStats = new MultiStats(freshStats);
					handler(null, multiStats);
				}
			}
			if(firstRun &amp;&amp; !err) {
				firstRun = false;
				callback();
			}
		});
		watchings.push(watching);
	}.bind(this), function() {
		// ignore
	});

	return new MultiWatching(watchings, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		const ignored = path =&gt; this.paths.some(p =&gt; p instanceof RegExp ? p.test(path) : path.indexOf(p) === 0);

		const notIgnored = path =&gt; !ignored(path);

		const ignoredFiles = files.filter(ignored);
		const ignoredDirs = dirs.filter(ignored);

		this.wfs.<span class="apidocCodeKeywordSpan">watch</span>(files.filter(notIgnored), dirs.filter(notIgnored), missing, startTime
, options, (err, filesModified, dirsModified, missingModified, fileTimestamps, dirTimestamps) =&gt; {
			if(err) return callback(err);

			ignoredFiles.forEach(path =&gt; {
				fileTimestamps[path] = 1;
			});

			ignoredDirs.forEach(path =&gt; {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ParserHelpers" id="apidoc.module.webpack.ParserHelpers">module webpack.ParserHelpers</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.addParsedVariableToModule" id="apidoc.element.webpack.ParserHelpers.addParsedVariableToModule">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>addParsedVariableToModule
        <span class="apidocSignatureSpan">(parser, name, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addParsedVariableToModule = function (parser, name, expression) {
	if(!parser.state.current.addVariable) return false;
	var deps = [];
	parser.parse(expression, {
		current: {
			addDependency: function(dep) {
				dep.userRequest = name;
				deps.push(dep);
			}
		},
		module: parser.state.module
	});
	parser.state.current.addVariable(name, expression, deps);
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						let expression = `require(${JSON.stringify(request[0])})`;
						if(scopedName) {
							nameIdentifier = `__webpack_provided_${name.replace(/\./g, "_dot_")}`;
						}
						if(request.length &gt; 1) {
							expression += request.slice(1).map(r =&gt; `[${JSON.stringify(r)}]`).join("");
						}
						if(!ParserHelpers.<span class="apidocCodeKeywordSpan">addParsedVariableToModule</span>(this, nameIdentifier, expression)) {
							return false;
						}
						if(scopedName) {
							ParserHelpers.toConstantDependency(nameIdentifier).bind(this)(expr);
						}
						return true;
					});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.approve" id="apidoc.element.webpack.ParserHelpers.approve">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>approve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function approve() {
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.evaluateToBoolean" id="apidoc.element.webpack.ParserHelpers.evaluateToBoolean">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>evaluateToBoolean
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluateToBoolean = function (value) {
	return function booleanExpression(expr) {
		return new BasicEvaluatedExpression().setBoolean(value).setRange(expr.range);
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				parser.plugin("expression module.id", ParserHelpers.toConstantDependency("module.i"));
				parser.plugin("expression module.exports", function() {
					const module = this.state.module;
					const isHarmony = module.meta &amp;&amp; module.meta.harmonyModule;
					if(!isHarmony)
						return true;
				});
				parser.plugin("evaluate Identifier module.hot", ParserHelpers.<span class="apidocCodeKeywordSpan">evaluateToBoolean
</span>(false));
				parser.plugin("expression module", function() {
					const module = this.state.module;
					const isHarmony = module.meta &amp;&amp; module.meta.harmonyModule;
					let moduleJsPath = path.join(__dirname, "..", "buildin", isHarmony ? "harmony-module.js" : &amp;#
x22;module.js");
					if(module.context) {
						moduleJsPath = path.relative(this.state.module.context, moduleJsPath);
						if(!/^[A-Z]:/i.test(moduleJsPath)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.evaluateToString" id="apidoc.element.webpack.ParserHelpers.evaluateToString">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>evaluateToString
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluateToString = function (value) {
	return function stringExpression(expr) {
		return new BasicEvaluatedExpression().setString(value).setRange(expr.range);
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		compiler.plugin("compilation", (compilation, params) =&gt; {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

			params.normalModuleFactory.plugin("parser", parser =&gt; {
				Object.keys(REPLACEMENTS).forEach(key =&gt; {
					parser.plugin(`expression ${key}`, ParserHelpers.toConstantDependency(REPLACEMENTS[key]));
					parser.plugin(`evaluate typeof ${key}`, ParserHelpers.<span class="apidocCodeKeywordSpan">evaluateToString</span>(REPLACEMENT_TYPES
[key]));
				});
			});
		});
	}
}

module.exports = APIPlugin;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.expressionIsUnsupported" id="apidoc.element.webpack.ParserHelpers.expressionIsUnsupported">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>expressionIsUnsupported
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expressionIsUnsupported = function (message) {
	return function unsupportedExpression(expr) {
		var dep = new ConstDependency("(void 0)", expr.range);
		dep.loc = expr.loc;
		this.state.current.addDependency(dep);
		if(!this.state.module) return;
		this.state.module.warnings.push(new UnsupportedFeatureWarning(this.state.module, message));
		return true;
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				parser.plugin("evaluate Identifier __dirname", function(expr) {
					if(!this.state.module) return;
					return ParserHelpers.evaluateToString(this.state.module.context)(expr);
				});
				parser.plugin("expression require.main", ParserHelpers.toConstantDependency("__webpack_require__.c[__webpack_require__
.s]"));
				parser.plugin(
					"expression require.extensions",
					ParserHelpers.<span class="apidocCodeKeywordSpan">expressionIsUnsupported</span>("require.extensions is not supported
by webpack. Use a loader instead.")
				);
				parser.plugin("expression module.loaded", ParserHelpers.toConstantDependency("module.l"));
				parser.plugin("expression module.id", ParserHelpers.toConstantDependency("module.i"));
				parser.plugin("expression module.exports", function() {
					const module = this.state.module;
					const isHarmony = module.meta &amp;&amp; module.meta.harmonyModule;
					if(!isHarmony)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.requireFileAsExpression" id="apidoc.element.webpack.ParserHelpers.requireFileAsExpression">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>requireFileAsExpression
        <span class="apidocSignatureSpan">(context, pathToModule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requireFileAsExpression = function (context, pathToModule) {
	var moduleJsPath = path.relative(context, pathToModule);
	if(!/^[A-Z]:/i.test(moduleJsPath)) {
		moduleJsPath = "./" + moduleJsPath.replace(/\\/g, "/");
	}
	return "require(" + JSON.stringify(moduleJsPath) + ")";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.skipTraversal" id="apidoc.element.webpack.ParserHelpers.skipTraversal">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>skipTraversal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipTraversal() {
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.toConstantDependency" id="apidoc.element.webpack.ParserHelpers.toConstantDependency">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>toConstantDependency
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toConstantDependency = function (value) {
	return function constDependency(expr) {
		var dep = new ConstDependency(value, expr.range);
		dep.loc = expr.loc;
		this.state.current.addDependency(dep);
		return true;
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

			params.normalModuleFactory.plugin("parser", parser =&gt; {
				Object.keys(REPLACEMENTS).forEach(key =&gt; {
					parser.plugin(`expression ${key}`, ParserHelpers.<span class="apidocCodeKeywordSpan">toConstantDependency</span>(REPLACEMENTS
[key]));
					parser.plugin(`evaluate typeof ${key}`, ParserHelpers.evaluateToString(REPLACEMENT_TYPES[key]));
				});
			});
		});
	}
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.SizeFormatHelpers" id="apidoc.module.webpack.SizeFormatHelpers">module webpack.SizeFormatHelpers</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.SizeFormatHelpers.formatSize" id="apidoc.element.webpack.SizeFormatHelpers.formatSize">
        function <span class="apidocSignatureSpan">webpack.SizeFormatHelpers.</span>formatSize
        <span class="apidocSignatureSpan">(size &lt;= 0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size =&gt; {
	if(size &lt;= 0) {
		return "0 bytes";
	}

	const abbreviations = ["bytes", "kB", "MB", "GB"];
	const index = Math.floor(Math.log(size) / Math.log(1000));

	return `${+(size / Math.pow(1000, index)).toPrecision(3)} ${abbreviations[index]}`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				}]
			];
			obj.assets.forEach(asset =&gt; {
				t.push([{
					value: asset.name,
					color: getAssetColor(asset, colors.green)
				}, {
					value: SizeFormatHelpers.<span class="apidocCodeKeywordSpan">formatSize</span>(asset.size),
					color: getAssetColor(asset, colors.normal)
				}, {
					value: asset.chunks.join(", "),
					color: colors.bold
				}, {
					value: asset.emitted ? "[emitted]" : "",
					color: colors.green
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.optimize" id="apidoc.module.webpack.optimize">module webpack.optimize</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.optimize.AggressiveMergingPlugin" id="apidoc.element.webpack.optimize.AggressiveMergingPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>AggressiveMergingPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AggressiveMergingPlugin {
	constructor(options) {
		if(options !== undefined &amp;&amp; typeof options !== "object" || Array.isArray(options)) {
			throw new Error("Argument should be an options object. To use defaults, pass in nothing.\nFor more info on options, see https
://webpack.js.org/plugins/");
		}
		this.options = options || {};
	}

	apply(compiler) {
		const options = this.options;
		const minSizeReduce = options.minSizeReduce || 1.5;

		function getParentsWeight(chunk) {
			return chunk.parents.map((p) =&gt; {
				return p.isInitial() ? options.entryChunkMultiplicator || 10 : 1;
			}).reduce((a, b) =&gt; {
				return a + b;
			}, 0);
		}
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-chunks-advanced", (chunks) =&gt; {
				let combinations = [];
				chunks.forEach((a, idx) =&gt; {
					if(a.isInitial()) return;
					for(let i = 0; i &lt; idx; i++) {
						const b = chunks[i];
						if(b.isInitial()) continue;
						combinations.push([b, a]);
					}
				});

				combinations.forEach((pair) =&gt; {
					const a = pair[0].size({
						chunkOverhead: 0
					});
					const b = pair[1].size({
						chunkOverhead: 0
					});
					const ab = pair[0].integratedSize(pair[1], {
						chunkOverhead: 0
					});
					pair.push({
						a: a,
						b: b,
						ab: ab
					});
					let newSize;
					if(ab === false) {
						pair.unshift(false);
					} else if(options.moveToParents) {
						const aOnly = ab - b;
						const bOnly = ab - a;
						const common = a + b - ab;
						newSize = common + getParentsWeight(pair[0]) * aOnly + getParentsWeight(pair[1]) * bOnly;
						pair.push({
							aOnly: aOnly,
							bOnly: bOnly,
							common: common,
							newSize: newSize
						});
					} else {
						newSize = ab;
					}

					pair.unshift((a + b) / newSize);
				});
				combinations = combinations.filter((pair) =&gt; {
					return pair[0] !== false;
				});
				combinations.sort((a, b) =&gt; {
					return b[0] - a[0];
				});

				const pair = combinations[0];

				if(!pair) return;
				if(pair[0] &lt; minSizeReduce) return;

				if(options.moveToParents) {
					const commonModules = pair[1].modules.filter((m) =&gt; {
						return pair[2].modules.indexOf(m) &gt;= 0;
					});
					const aOnlyModules = pair[1].modules.filter((m) =&gt; {
						return commonModules.indexOf(m) &lt; 0;
					});
					const bOnlyModules = pair[2].modules.filter((m) =&gt; {
						return commonModules.indexOf(m) &lt; 0;
					});
					aOnlyModules.forEach((m) =&gt; {
						pair[1].removeModule(m);
						m.removeChunk(pair[1]);
						pair[1].parents.forEach((c) =&gt; {
							c.addModule(m);
							m.addChunk(c);
						});
					});
					bOnlyModules.forEach((m) =&gt; {
						pair[2].removeModule(m);
						m.removeChunk(pair[2]);
						pair[2].parents.forEach((c) =&gt; {
							c.addModule(m);
							m.addChunk(c);
						});
					});
				}
				if(pair[1].integrate(pair[2], "aggressive-merge")) {
					chunks.splice(chunks.indexOf(pair[2]), 1);
					return true;
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.AggressiveSplittingPlugin" id="apidoc.element.webpack.optimize.AggressiveSplittingPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>AggressiveSplittingPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AggressiveSplittingPlugin {
	constructor(options) {
		this.options = options || {};
		if(typeof this.options.minSize !== "number") this.options.minSize = 30 * 1024;
		if(typeof this.options.maxSize !== "number") this.options.maxSize = 50 * 1024;
		if(typeof this.options.chunkOverhead !== "number") this.options.chunkOverhead = 0;
		if(typeof this.options.entryChunkMultiplicator !== "number") this.options.entryChunkMultiplicator = 1;
	}
	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-chunks-advanced", (chunks) =&gt; {
				const savedSplits = compilation.records &amp;&amp; compilation.records.aggressiveSplits || [];
				const usedSplits = compilation._aggressiveSplittingSplits ?
					savedSplits.concat(compilation._aggressiveSplittingSplits) : savedSplits;

				const minSize = this.options.minSize;
				const maxSize = this.options.maxSize;
				// 1. try to restore to recorded splitting
				for(let j = 0; j &lt; usedSplits.length; j++) {
					const splitData = usedSplits[j];
					for(let i = 0; i &lt; chunks.length; i++) {
						const chunk = chunks[i];
						const chunkModuleNames = chunk.modules.map(m =&gt; identifierUtils.makePathsRelative(compiler.context, m.identifier()));

						if(chunkModuleNames.length &lt; splitData.modules.length)
							continue;
						const moduleIndicies = splitData.modules.map(toIndexOf(chunkModuleNames));
						const hasAllModules = moduleIndicies.every((idx) =&gt; {
							return idx &gt;= 0;
						});
						if(hasAllModules) {
							if(chunkModuleNames.length &gt; splitData.modules.length) {
								const selectedModules = moduleIndicies.map(toChunkModuleIndices(chunk.modules));
								const newChunk = compilation.addChunk();
								selectedModules.forEach(moveModuleBetween(chunk, newChunk));
								chunk.split(newChunk);
								chunk.name = null;
								newChunk._fromAggressiveSplitting = true;
								if(j &lt; savedSplits.length)
									newChunk._fromAggressiveSplittingIndex = j;
								if(splitData.id !== null &amp;&amp; splitData.id !== undefined) {
									newChunk.id = splitData.id;
								}
								newChunk.origins = chunk.origins.map(copyWithReason);
								chunk.origins = chunk.origins.map(copyWithReason);
								return true;
							} else {
								if(j &lt; savedSplits.length)
									chunk._fromAggressiveSplittingIndex = j;
								chunk.name = null;
								if(splitData.id !== null &amp;&amp; splitData.id !== undefined) {
									chunk.id = splitData.id;
								}
							}
						}
					}
				}
				// 2. for any other chunk which isn't splitted yet, split it
				for(let i = 0; i &lt; chunks.length; i++) {
					const chunk = chunks[i];
					const size = chunk.size(this.options);
					if(size &gt; maxSize &amp;&amp; chunk.modules.length &gt; 1) {
						const newChunk = compilation.addChunk();
						const modules = chunk.modules
							.filter(isNotAEntryModule(chunk.entryModule))
							.sort((a, b) =&gt; {
								a = a.identifier();
								b = b.identifier();
								if(a &gt; b) return 1;
								if(a &lt; b) return -1;
								return 0;
							});
						for(let k = 0; k &lt; modules.length; k++) {
							chunk.moveModule(modules[k], newChunk);
							const newSize = newChunk.size(this.options);
							const chunkSize = chunk.size(this.options);
							// break early if it's fine
							if(chunkSize &lt; maxSize &amp;&amp; newSize &lt; maxSize &amp;&amp; newSize &gt;= minSize &amp;&amp; chunkSize &gt;= minSize)
								break;
							if(newSize &gt; maxSize &amp;&amp; k === 0) {
								// break if there is a single module which is bigger than maxSize
								break;
							}
							if(newSize &gt; maxSize || chunkSize &lt; minSize) {
								// move it back
								newChunk.moveModule(modules[k], chunk);
								// check if it's fine now
								if(newSize &lt; maxSize &amp;&amp; newSize &gt;= minSize &amp;&amp; chunkSize &gt;= minSize)
									break;
							}
						}
						if(newChunk.modules.length &gt; 0) {
							chunk.split(newChunk);
							chunk.name = null;
							newChunk.origins = chunk.origins.map(copyWithReason);
							chunk.origins = chunk.origins.map(cop ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.ChunkModuleIdRangePlugin" id="apidoc.element.webpack.optimize.ChunkModuleIdRangePlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>ChunkModuleIdRangePlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ChunkModuleIdRangePlugin {
	constructor(options) {
		this.options = options;
	}
	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("module-ids", (modules) =&gt; {
				const chunk = this.chunks.filter((chunk) =&gt; {
					return chunk.name === options.name;
				})[0];
				if(!chunk) throw new Error("ChunkModuleIdRangePlugin: Chunk with name '" + options.name + "' was not found");
				let currentId = options.start;
				let chunkModules;
				if(options.order) {
					chunkModules = chunk.modules.slice();
					switch(options.order) {
						case "index":
							chunkModules.sort((a, b) =&gt; {
								return a.index - b.index;
							});
							break;
						case "index2":
							chunkModules.sort((a, b) =&gt; {
								return a.index2 - b.index2;
							});
							break;
						default:
							throw new Error("ChunkModuleIdRangePlugin: unexpected value of order");
					}

				} else {
					chunkModules = modules.filter((m) =&gt; {
						return m.chunks.indexOf(chunk) &gt;= 0;
					});
				}

				for(let i = 0; i &lt; chunkModules.length; i++) {
					const m = chunkModules[i];
					if(m.id === null) {
						m.id = currentId++;
					}
					if(options.end &amp;&amp; currentId &gt; options.end)
						break;
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.CommonsChunkPlugin" id="apidoc.element.webpack.optimize.CommonsChunkPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>CommonsChunkPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CommonsChunkPlugin {
	constructor(options) {
		if(arguments.length &gt; 1) {
			throw new Error(`Deprecation notice: CommonsChunkPlugin now only takes a single argument. Either an options
object *or* the name of the chunk.
Example: if your old code looked like this:
	new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js')
You would change it to:
	new webpack.optimize.CommonsChunkPlugin({ name: 'vendor', filename: 'vendor.bundle.js' })
The available options are:
	name: string
	names: string[]
	filename: string
	minChunks: number
	chunks: string[]
	children: boolean
	async: boolean
	minSize: number`);
		}

		const normalizedOptions = this.normalizeOptions(options);

		this.chunkNames = normalizedOptions.chunkNames;
		this.filenameTemplate = normalizedOptions.filenameTemplate;
		this.minChunks = normalizedOptions.minChunks;
		this.selectedChunks = normalizedOptions.selectedChunks;
		this.children = normalizedOptions.children;
		this.async = normalizedOptions.async;
		this.minSize = normalizedOptions.minSize;
		this.ident = __filename + (nextIdent++);
	}

	normalizeOptions(options) {
		if(Array.isArray(options)) {
			return {
				chunkNames: options,
			};
		}

		if(typeof options === "string") {
			return {
				chunkNames: [options],
			};
		}

		// options.children and options.chunk may not be used together
		if(options.children &amp;&amp; options.chunks) {
			throw new Error("You can't and it does not make any sense to use \"children\" and \"chunk\" options together.");
		}

		/**
		 * options.async and options.filename are also not possible together
		 * as filename specifies how the chunk is called but "async" implies
		 * that webpack will take care of loading this file.
		 */
		if(options.async &amp;&amp; options.filename) {
			throw new Error(`You can not specify a filename if you use the \"async\" option.
You can however specify the name of the async chunk by passing the desired string as the \"async\" option.`);
		}

		/**
		 * Make sure this is either an array or undefined.
		 * "name" can be a string and
		 * "names" a string or an array
		 */
		const chunkNames = options.name || options.names ? [].concat(options.name || options.names) : undefined;
		return {
			chunkNames: chunkNames,
			filenameTemplate: options.filename,
			minChunks: options.minChunks,
			selectedChunks: options.chunks,
			children: options.children,
			async: options.async,
			minSize: options.minSize
		};
	}

	apply(compiler) {
		compiler.plugin("this-compilation", (compilation) =&gt; {
			compilation.plugin(["optimize-chunks", "optimize-extracted-chunks"], (chunks) =&gt; {
				// only optimize once
				if(compilation[this.ident]) return;
				compilation[this.ident] = true;

				/**
				 * Creates a list of "common"" chunks based on the options.
				 * The list is made up of preexisting or newly created chunks.
				 * - If chunk has the name as specified in the chunkNames it is put in the list
				 * - If no chunk with the name as given in chunkNames exists a new chunk is created and added to the list
				 *
				 * These chunks are the "targets" for extracted modules.
				 */
				const targetChunks = this.getTargetChunks(chunks, compilation, this.chunkNames, this.children, this.async);

				// iterate over all our new chunks
				targetChunks.forEach((targetChunk, idx) =&gt; {

					/**
					 * These chunks are subject to get "common" modules extracted and moved to the common chunk
					 */
					const affectedChunks = this.getAffectedChunks(compilation, chunks, targetChunk, targetChunks, idx, this.selectedChunks, this
.async, this.children);

					// bail if no chunk is affected
					if(!affectedChunks) {
						return;
					}

					// If we are async create an async chunk now
					// override the "commonChunk" with the newly created async one and use it as commonChunk from now on
					let asyncChunk;
					if(this.async) {
						asyncChunk = this.createAsyncChunk(compilation, this.async, targetChunk);
						targetChunk = asyncChunk;
					} ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.DedupePlugin" id="apidoc.element.webpack.optimize.DedupePlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>DedupePlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DedupePlugin {
	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.warnings.push(new Error("DedupePlugin: This plugin was removed from webpack. Remove it from your configuration."));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.LimitChunkCountPlugin" id="apidoc.element.webpack.optimize.LimitChunkCountPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>LimitChunkCountPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LimitChunkCountPlugin {
	constructor(options) {
		if(options !== undefined &amp;&amp; typeof options !== "object" || Array.isArray(options)) {
			throw new Error("Argument should be an options object.\nFor more info on options, see https://webpack.js.org/plugins/");
		}
		this.options = options || {};
	}
	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-chunks-advanced", (chunks) =&gt; {
				const maxChunks = options.maxChunks;
				if(!maxChunks) return;
				if(maxChunks &lt; 1) return;
				if(chunks.length &lt;= maxChunks) return;

				if(chunks.length &gt; maxChunks) {
					const sortedExtendedPairCombinations = chunks.reduce((combinations, a, idx) =&gt; {
						// create combination pairs
						for(let i = 0; i &lt; idx; i++) {
							const b = chunks[i];
							combinations.push([b, a]);
						}
						return combinations;
					}, []).map((pair) =&gt; {
						// extend combination pairs with size and integrated size
						const a = pair[0].size(options);
						const b = pair[1].size(options);
						const ab = pair[0].integratedSize(pair[1], options);
						return [a + b - ab, ab, pair[0], pair[1], a, b];
					}).filter((extendedPair) =&gt; {
						// filter pairs that do not have an integratedSize
						// meaning they can NOT be integrated!
						return extendedPair[1] !== false;
					}).sort((a, b) =&gt; { // sadly javascript does an inplace sort here
						// sort them by size
						const diff = b[0] - a[0];
						if(diff !== 0) return diff;
						return a[1] - b[1];
					});

					const pair = sortedExtendedPairCombinations[0];

					if(pair &amp;&amp; pair[2].integrate(pair[3], "limit")) {
						chunks.splice(chunks.indexOf(pair[3]), 1);
						return true;
					}
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.MinChunkSizePlugin" id="apidoc.element.webpack.optimize.MinChunkSizePlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>MinChunkSizePlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class MinChunkSizePlugin {
	constructor(options) {
		if(typeof options !== "object" || Array.isArray(options)) {
			throw new Error("Argument should be an options object.\nFor more info on options, see https://webpack.js.org/plugins/");
		}
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		const minChunkSize = options.minChunkSize;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-chunks-advanced", (chunks) =&gt; {
				const equalOptions = {
					chunkOverhead: 1,
					entryChunkMultiplicator: 1
				};

				const sortedSizeFilteredExtendedPairCombinations = chunks.reduce((combinations, a, idx) =&gt; {
					// create combination pairs
					for(let i = 0; i &lt; idx; i++) {
						const b = chunks[i];
						combinations.push([b, a]);
					}
					return combinations;
				}, []).filter((pair) =&gt; {
					// check if one of the chunks sizes is smaller than the minChunkSize
					const p0SmallerThanMinChunkSize = pair[0].size(equalOptions) &lt; minChunkSize;
					const p1SmallerThanMinChunkSize = pair[1].size(equalOptions) &lt; minChunkSize;
					return p0SmallerThanMinChunkSize || p1SmallerThanMinChunkSize;
				}).map((pair) =&gt; {
					// extend combination pairs with size and integrated size
					const a = pair[0].size(options);
					const b = pair[1].size(options);
					const ab = pair[0].integratedSize(pair[1], options);
					return [a + b - ab, ab, pair[0], pair[1]];
				}).filter((pair) =&gt; {
					// filter pairs that do not have an integratedSize
					// meaning they can NOT be integrated!
					return pair[1] !== false;
				}).sort((a, b) =&gt; { // sadly javascript does an inplace sort here
					// sort by size
					const diff = b[0] - a[0];
					if(diff !== 0) return diff;
					return a[1] - b[1];
				});

				if(sortedSizeFilteredExtendedPairCombinations.length === 0) return;

				const pair = sortedSizeFilteredExtendedPairCombinations[0];

				pair[2].integrate(pair[3], "min-size");
				chunks.splice(chunks.indexOf(pair[3]), 1);
				return true;
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.OccurrenceOrderPlugin" id="apidoc.element.webpack.optimize.OccurrenceOrderPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>OccurrenceOrderPlugin
        <span class="apidocSignatureSpan">(preferEntry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class OccurrenceOrderPlugin {
	constructor(preferEntry) {
		if(preferEntry !== undefined &amp;&amp; typeof preferEntry !== "boolean") {
			throw new Error("Argument should be a boolean.\nFor more info on this plugin, see https://webpack.js.org/plugins/");
		}
		this.preferEntry = preferEntry;
	}
	apply(compiler) {
		const preferEntry = this.preferEntry;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-module-order", (modules) =&gt; {
				function entryChunks(m) {
					return m.chunks.map((c) =&gt; {
						const sum = (c.isInitial() ? 1 : 0) + (c.entryModule === m ? 1 : 0);
						return sum;
					}).reduce((a, b) =&gt; {
						return a + b;
					}, 0);
				}

				function occursInEntry(m) {
					if(typeof m.__OccurenceOrderPlugin_occursInEntry === "number") return m.__OccurenceOrderPlugin_occursInEntry;
					const result = m.reasons.map((r) =&gt; {
						if(!r.module) return 0;
						return entryChunks(r.module);
					}).reduce((a, b) =&gt; {
						return a + b;
					}, 0) + entryChunks(m);
					return m.__OccurenceOrderPlugin_occursInEntry = result;
				}

				function occurs(m) {
					if(typeof m.__OccurenceOrderPlugin_occurs === "number") return m.__OccurenceOrderPlugin_occurs;
					const result = m.reasons.map((r) =&gt; {
						if(!r.module) return 0;
						return r.module.chunks.length;
					}).reduce((a, b) =&gt; {
						return a + b;
					}, 0) + m.chunks.length + m.chunks.filter((c) =&gt; {
						return c.entryModule === m;
					}).length;
					return m.__OccurenceOrderPlugin_occurs = result;
				}
				modules.sort((a, b) =&gt; {
					if(preferEntry) {
						const aEntryOccurs = occursInEntry(a);
						const bEntryOccurs = occursInEntry(b);
						if(aEntryOccurs &gt; bEntryOccurs) return -1;
						if(aEntryOccurs &lt; bEntryOccurs) return 1;
					}
					const aOccurs = occurs(a);
					const bOccurs = occurs(b);
					if(aOccurs &gt; bOccurs) return -1;
					if(aOccurs &lt; bOccurs) return 1;
					if(a.identifier() &gt; b.identifier()) return 1;
					if(a.identifier() &lt; b.identifier()) return -1;
					return 0;
				});
				// TODO refactor to Map
				modules.forEach((m) =&gt; {
					m.__OccurenceOrderPlugin_occursInEntry = undefined;
					m.__OccurenceOrderPlugin_occurs = undefined;
				});
			});
			compilation.plugin("optimize-chunk-order", (chunks) =&gt; {
				function occursInEntry(c) {
					if(typeof c.__OccurenceOrderPlugin_occursInEntry === "number") return c.__OccurenceOrderPlugin_occursInEntry;
					const result = c.parents.filter((p) =&gt; {
						return p.isInitial();
					}).length;
					return c.__OccurenceOrderPlugin_occursInEntry = result;
				}

				function occurs(c) {
					return c.blocks.length;
				}
				chunks.forEach((c) =&gt; {
					c.modules.sort((a, b) =&gt; {
						if(a.identifier() &gt; b.identifier()) return 1;
						if(a.identifier() &lt; b.identifier()) return -1;
						return 0;
					});
				});
				chunks.sort((a, b) =&gt; {
					const aEntryOccurs = occursInEntry(a);
					const bEntryOccurs = occursInEntry(b);
					if(aEntryOccurs &gt; bEntryOccurs) return -1;
					if(aEntryOccurs &lt; bEntryOccurs) return 1;
					const aOccurs = occurs(a);
					const bOccurs = occurs(b);
					if(aOccurs &gt; bOccurs) return -1;
					if(aOccurs &lt; bOccurs) return 1;
					if(a.modules.length &gt; b.modules.length) return -1;
					if(a.modules.length &lt; b.modules.length) return 1;
					for(let i = 0; i &lt; a.modules.length; i++) {
						if(a.modules[i].identifier() &gt; b.modules[i].identifier()) return -1;
						if(a.modules[i].identifier() &lt; b.modules[i].identifier()) return 1;
					}
					return 0;
				});
				// TODO refactor to Map
				chunks.forEach((c) =&gt; {
					c.__OccurenceOrderPlugin_occursInEntry = undefined;
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.UglifyJsPlugin" id="apidoc.element.webpack.optimize.UglifyJsPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>UglifyJsPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class UglifyJsPlugin {
	constructor(options) {
		if(typeof options !== "object" || Array.isArray(options)) options = {};
		if(typeof options.compressor !== "undefined") options.compress = options.compressor;
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		options.test = options.test || /\.js($|\?)/i;
		const warningsFilter = options.warningsFilter || (() =&gt; true);

		const requestShortener = new RequestShortener(compiler.context);
		compiler.plugin("compilation", (compilation) =&gt; {
			if(options.sourceMap) {
				compilation.plugin("build-module", (module) =&gt; {
					// to get detailed location info about errors
					module.useSourceMap = true;
				});
			}
			compilation.plugin("optimize-chunk-assets", (chunks, callback) =&gt; {
				const files = [];
				chunks.forEach((chunk) =&gt; files.push.apply(files, chunk.files));
				files.push.apply(files, compilation.additionalChunkAssets);
				const filterdFiles = files.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options));
				filterdFiles.forEach((file) =&gt; {
					const oldWarnFunction = uglify.AST_Node.warn_function;
					const warnings = [];
					let sourceMap;
					try {
						const asset = compilation.assets[file];
						if(asset.__UglifyJsPlugin) {
							compilation.assets[file] = asset.__UglifyJsPlugin;
							return;
						}
						let input;
						let inputSourceMap;
						if(options.sourceMap) {
							if(asset.sourceAndMap) {
								const sourceAndMap = asset.sourceAndMap();
								inputSourceMap = sourceAndMap.map;
								input = sourceAndMap.source;
							} else {
								inputSourceMap = asset.map();
								input = asset.source();
							}
							sourceMap = new SourceMapConsumer(inputSourceMap);
							uglify.AST_Node.warn_function = (warning) =&gt; { // eslint-disable-line camelcase
								const match = /\[.+:([0-9]+),([0-9]+)\]/.exec(warning);
								const line = +match[1];
								const column = +match[2];
								const original = sourceMap.originalPositionFor({
									line: line,
									column: column
								});
								if(!original || !original.source || original.source === file) return;
								if(!warningsFilter(original.source)) return;
								warnings.push(warning.replace(/\[.+:([0-9]+),([0-9]+)\]/, "") +
									"[" + requestShortener.shorten(original.source) + ":" + original.line + "," + original.column + "]");
							};
						} else {
							input = asset.source();
							uglify.AST_Node.warn_function = (warning) =&gt; { // eslint-disable-line camelcase
								warnings.push(warning);
							};
						}
						uglify.base54.reset();
						let ast = uglify.parse(input, {
							filename: file
						});
						if(options.compress !== false) {
							ast.figure_out_scope();
							const compress = uglify.Compressor(options.compress || {
								warnings: false
							}); // eslint-disable-line new-cap
							ast = compress.compress(ast);
						}
						if(options.mangle !== false) {
							ast.figure_out_scope(options.mangle || {});
							ast.compute_char_frequency(options.mangle || {});
							ast.mangle_names(options.mangle || {});
							if(options.mangle &amp;&amp; options.mangle.props) {
								uglify.mangle_properties(ast, options.mangle.props);
							}
						}
						const output = {};
						output.comments = Object.prototype.hasOwnProperty.call(options, "comments") ? options.comments : /^\**!|@preserve|@license
/;
						output.beautify = options.beautify;
						for(let k in options.output) {
							output[k] = options.output[k];
						}
						const extractedComments = [];
						if(options.extractComments) {
							const condition = {};
							if(typeof options.extractComments === "string" || options.extractComments instanceof RegExp) {
								// extractComments specifies the extract condition and output.comments specifies the preserve condition
								condition.preserve = output.comments;
								condition.extract = options.extractComments;
							} else if(Object.prototype.hasOwnProperty.call(options.extractC ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.system" id="apidoc.module.webpack.system">module webpack.system</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.system.import" id="apidoc.element.webpack.system.import">
        function <span class="apidocSignatureSpan">webpack.system.</span>import
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function () {
		throw new Error("System.import cannot be used indirectly");
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.webpack_web" id="apidoc.module.webpack.webpack_web">module webpack.webpack_web</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.webpack_web.webpack_web" id="apidoc.element.webpack.webpack_web.webpack_web">
        function <span class="apidocSignatureSpan">webpack.</span>webpack_web
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function webpack(options, callback) {
	new WebpackOptionsDefaulter().process(options);

	const compiler = new Compiler();
	compiler.options = options;
	compiler.options = new WebpackOptionsApply().process(options, compiler);
	new WebEnvironmentPlugin(options.inputFileSystem, options.outputFileSystem).apply(compiler);
	if(callback) {
		compiler.run(callback);
	}
	return compiler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.webpack_web.Compiler" id="apidoc.element.webpack.webpack_web.Compiler">
        function <span class="apidocSignatureSpan">webpack.webpack_web.</span>Compiler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler() {
	Tapable.call(this);

	this.outputPath = "";
	this.outputFileSystem = null;
	this.inputFileSystem = null;

	this.recordsInputPath = null;
	this.recordsOutputPath = null;
	this.records = {};

	this.fileTimestamps = {};
	this.contextTimestamps = {};

	this.resolvers = {
		normal: null,
		loader: null,
		context: null
	};
	var deprecationReported = false;
	this.parser = {
		plugin: function(hook, fn) {
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.plugin(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.plugin(hook, fn);
				});
			});
		}.bind(this),
		apply: function() {
			var args = arguments;
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.apply(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.apply.apply(parser, args);
				});
			});
		}.bind(this)
	};

	this.options = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.webpack_web.WebEnvironmentPlugin" id="apidoc.element.webpack.webpack_web.WebEnvironmentPlugin">
        function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebEnvironmentPlugin
        <span class="apidocSignatureSpan">(inputFileSystem, outputFileSystem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebEnvironmentPlugin {
	constructor(inputFileSystem, outputFileSystem) {
		this.inputFileSystem = inputFileSystem;
		this.outputFileSystem = outputFileSystem;
	}

	apply(compiler) {
		compiler.outputFileSystem = this.outputFileSystem;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.webpack_web.WebpackOptionsApply" id="apidoc.element.webpack.webpack_web.WebpackOptionsApply">
        function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebpackOptionsApply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebpackOptionsApply extends OptionsApply {
	constructor() {
		super();
	}

	process(options, compiler) {
		let ExternalsPlugin;
		compiler.outputPath = options.output.path;
		compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;
		compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath;
		compiler.name = options.name;
		compiler.dependencies = options.dependencies;
		if(typeof options.target === "string") {
			let JsonpTemplatePlugin;
			let NodeSourcePlugin;
			let NodeTargetPlugin;
			let NodeTemplatePlugin;

			switch(options.target) {
				case "web":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeSourcePlugin = require("./node/NodeSourcePlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeSourcePlugin(options.node),
						new LoaderTargetPlugin("web")
					);
					break;
				case "webworker":
					{
						let WebWorkerTemplatePlugin = require("./webworker/WebWorkerTemplatePlugin");
						NodeSourcePlugin = require("./node/NodeSourcePlugin");
						compiler.apply(
							new WebWorkerTemplatePlugin(),
							new FunctionModulePlugin(options.output),
							new NodeSourcePlugin(options.node),
							new LoaderTargetPlugin("webworker")
						);
						break;
					}
				case "node":
				case "async-node":
					NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					compiler.apply(
						new NodeTemplatePlugin({
							asyncChunkLoading: options.target === "async-node"
						}),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new LoaderTargetPlugin("node")
					);
					break;
				case "node-webkit":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", "nw.gui"),
						new LoaderTargetPlugin("node-webkit")
					);
					break;
				case "atom":
				case "electron":
				case "electron-main":
					NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new NodeTemplatePlugin({
							asyncChunkLoading: true
						}),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"app",
							"auto-updater",
							"browser-window",
							"content-tracing",
							"dialog",
							"electron",
							"global-shortcut",
							"ipc",
							"ipc-main",
							"menu",
							"menu-item",
							"power-monitor",
							"power-save-blocker",
							"protocol",
							"session",
							"web-contents",
							"tray",
							"clipboard",
							"crash-reporter",
							"native-image",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				case "electron-renderer":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"desktop-capturer",
							"electron",
							"ipc",
							"ipc-renderer",
							"remote",
							"web-frame",
							"clipboard",
							"crash-reporter",
							"native-image",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				default:
					throw new Error("Unsupported target '" + options.target + "'."); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.webpack_web.WebpackOptionsDefaulter" id="apidoc.element.webpack.webpack_web.WebpackOptionsDefaulter">
        function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebpackOptionsDefaulter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebpackOptionsDefaulter extends OptionsDefaulter {
	constructor() {
		super();
		this.set("devtool", false);
		this.set("cache", true);

		this.set("context", process.cwd());
		this.set("target", "web");

		this.set("module.unknownContextRequest", ".");
		this.set("module.unknownContextRegExp", false);
		this.set("module.unknownContextRecursive", true);
		this.set("module.unknownContextCritical", true);
		this.set("module.exprContextRequest", ".");
		this.set("module.exprContextRegExp", false);
		this.set("module.exprContextRecursive", true);
		this.set("module.exprContextCritical", true);
		this.set("module.wrappedContextRegExp", /.*/);
		this.set("module.wrappedContextRecursive", true);
		this.set("module.wrappedContextCritical", false);
		this.set("module.strictExportPresence", false);

		this.set("module.unsafeCache", true);

		this.set("output", "call", (value, options) =&gt; {
			if(typeof value === "string") {
				return {
					filename: value
				};
			} else if(typeof value !== "object") {
				return {};
			} else {
				return value;
			}
		});
		this.set("output.filename", "[name].js");
		this.set("output.chunkFilename", "make", (options) =&gt; {
			const filename = options.output.filename;
			return filename.indexOf("[name]") &gt;= 0 ? filename.replace("[name]", "[id]") : "[id]." + filename;
		});
		this.set("output.library", "");
		this.set("output.hotUpdateFunction", "make", (options) =&gt; {
			return Template.toIdentifier("webpackHotUpdate" + options.output.library);
		});
		this.set("output.jsonpFunction", "make", (options) =&gt; {
			return Template.toIdentifier("webpackJsonp" + options.output.library);
		});
		this.set("output.libraryTarget", "var");
		this.set("output.path", process.cwd());
		this.set("output.sourceMapFilename", "[file].map[query]");
		this.set("output.hotUpdateChunkFilename", "[id].[hash].hot-update.js");
		this.set("output.hotUpdateMainFilename", "[hash].hot-update.json");
		this.set("output.crossOriginLoading", false);
		this.set("output.hashFunction", "md5");
		this.set("output.hashDigest", "hex");
		this.set("output.hashDigestLength", 20);
		this.set("output.devtoolLineToLine", false);
		this.set("output.strictModuleExceptionHandling", false);

		this.set("node", {});
		this.set("node.console", false);
		this.set("node.process", true);
		this.set("node.global", true);
		this.set("node.Buffer", true);
		this.set("node.setImmediate", true);
		this.set("node.__filename", "mock");
		this.set("node.__dirname", "mock");

		this.set("performance.maxAssetSize", 250000);
		this.set("performance.maxEntrypointSize", 250000);
		this.set("performance.hints", false);

		this.set("resolve", {});
		this.set("resolve.unsafeCache", true);
		this.set("resolve.modules", ["node_modules"]);
		this.set("resolve.extensions", [".js", ".json"]);
		this.set("resolve.aliasFields", "make", (options) =&gt; {
			if(options.target === "web" || options.target === "webworker")
				return ["browser"];
			else
				return [];
		});
		this.set("resolve.mainFields", "make", (options) =&gt; {
			if(options.target === "web" || options.target === "webworker")
				return ["browser", "module", "main"];
			else
				return ["module", "main"];
		});
		this.set("resolveLoader", {});
		this.set("resolveLoader.unsafeCache", true);
		this.set("resolveLoader.mainFields", ["loader", "main"]);
		this.set("resolveLoader.extensions", [".js", ".json"]);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>