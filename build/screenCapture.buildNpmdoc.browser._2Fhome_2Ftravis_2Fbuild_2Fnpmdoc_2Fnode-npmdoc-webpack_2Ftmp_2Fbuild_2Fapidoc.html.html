<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/webpack/webpack">webpack (v2.3.3)</a>
</h1>
<h4>Packs CommonJs/AMD modules for the browser. Allows to split your codebase into multiple bundles, which can be loaded on demand. Support loaders to preprocess files, i.e. json, jsx, es7, css, less, ... and your custom stuff.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack">module webpack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.AutomaticPrefetchPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>AutomaticPrefetchPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.BannerPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>BannerPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.CachePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>CachePlugin
            <span class="apidocSignatureSpan">(cache)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler">
            function <span class="apidocSignatureSpan">webpack.</span>Compiler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching">
            function <span class="apidocSignatureSpan">webpack.</span>Compiler.Watching
            <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextModuleFactory">
            function <span class="apidocSignatureSpan">webpack.</span>ContextModuleFactory
            <span class="apidocSignatureSpan">(resolvers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextReplacementPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ContextReplacementPlugin
            <span class="apidocSignatureSpan">(resourceRegExp, newContentResource, newContentRecursive, newContentRegExp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DefinePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>DefinePlugin
            <span class="apidocSignatureSpan">(definitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DelegatedModule">
            function <span class="apidocSignatureSpan">webpack.</span>DelegatedModule
            <span class="apidocSignatureSpan">(sourceRequest, data, type, userRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DependenciesBlock">
            function <span class="apidocSignatureSpan">webpack.</span>DependenciesBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Dependency">
            function <span class="apidocSignatureSpan">webpack.</span>Dependency
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DllPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>DllPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DllReferencePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>DllReferencePlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DynamicEntryPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>DynamicEntryPlugin
            <span class="apidocSignatureSpan">(context, entry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.EntryModuleNotFoundError">
            function <span class="apidocSignatureSpan">webpack.</span>EntryModuleNotFoundError
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.EnvironmentPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>EnvironmentPlugin
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.EvalDevToolModulePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>EvalDevToolModulePlugin
            <span class="apidocSignatureSpan">(sourceUrlComment, moduleFilenameTemplate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.EvalSourceMapDevToolPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>EvalSourceMapDevToolPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ExtendedAPIPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ExtendedAPIPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ExternalModuleFactoryPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ExternalModuleFactoryPlugin
            <span class="apidocSignatureSpan">(type, externals)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ExternalsPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ExternalsPlugin
            <span class="apidocSignatureSpan">(type, externals)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.FlagDependencyUsagePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>FlagDependencyUsagePlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.HashedModuleIdsPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>HashedModuleIdsPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.HotModuleReplacementPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>HotModuleReplacementPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.IgnorePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>IgnorePlugin
            <span class="apidocSignatureSpan">(resourceRegExp, contextRegExp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.JsonpChunkTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>JsonpChunkTemplatePlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.JsonpMainTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>JsonpMainTemplatePlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.JsonpTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>JsonpTemplatePlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.LibManifestPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>LibManifestPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.LibraryTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>LibraryTemplatePlugin
            <span class="apidocSignatureSpan">(name, target, umdNamedDefine, auxiliaryComment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.LoaderOptionsPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>LoaderOptionsPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.LoaderTargetPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>LoaderTargetPlugin
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem">
            function <span class="apidocSignatureSpan">webpack.</span>MemoryOutputFileSystem
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module">
            function <span class="apidocSignatureSpan">webpack.</span>Module
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler">
            function <span class="apidocSignatureSpan">webpack.</span>MultiCompiler
            <span class="apidocSignatureSpan">(compilers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NamedModulesPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NamedModulesPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NewWatchingPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NewWatchingPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NoEmitOnErrorsPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NoEmitOnErrorsPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NoErrorsPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NoErrorsPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NodeEnvironmentPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NodeEnvironmentPlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NodeStuffPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NodeStuffPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NormalModuleFactory">
            function <span class="apidocSignatureSpan">webpack.</span>NormalModuleFactory
            <span class="apidocSignatureSpan">(context, resolvers, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NormalModuleReplacementPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NormalModuleReplacementPlugin
            <span class="apidocSignatureSpan">(resourceRegExp, newResource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser">
            function <span class="apidocSignatureSpan">webpack.</span>Parser
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.PrefetchPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>PrefetchPlugin
            <span class="apidocSignatureSpan">(context, request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ProgressPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ProgressPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ProvidePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ProvidePlugin
            <span class="apidocSignatureSpan">(definitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.SetVarMainTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>SetVarMainTemplatePlugin
            <span class="apidocSignatureSpan">(varExpression, copyObject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.SourceMapDevToolPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>SourceMapDevToolPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.UmdMainTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>UmdMainTemplatePlugin
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.WatchIgnorePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>WatchIgnorePlugin
            <span class="apidocSignatureSpan">(paths)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.WebpackOptionsApply">
            function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsApply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.WebpackOptionsDefaulter">
            function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsDefaulter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.WebpackOptionsValidationError">
            function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsValidationError
            <span class="apidocSignatureSpan">(validationErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.validate">
            function <span class="apidocSignatureSpan">webpack.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.validateSchema">
            function <span class="apidocSignatureSpan">webpack.</span>validateSchema
            <span class="apidocSignatureSpan">(schema, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web">
            function <span class="apidocSignatureSpan">webpack.</span>webpack_web
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>Compiler.Watching.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>Compiler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>ContextModuleFactory.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>DelegatedModule.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>DependenciesBlock.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>EntryModuleNotFoundError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>ErrorHelpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>ExternalModuleFactoryPlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>FlagDependencyUsagePlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>HotModuleReplacementPlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>JsonpChunkTemplatePlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>JsonpMainTemplatePlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>LibManifestPlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>MemoryOutputFileSystem.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>Module.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>ModuleFilenameHelpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>MultiCompiler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>NodeStuffPlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>NormalModuleFactory.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>ParserHelpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>SizeFormatHelpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>SourceMapDevToolPlugin.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>dependencies</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>optimize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.</span>system</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Compiler">module webpack.Compiler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Compiler">
            function <span class="apidocSignatureSpan">webpack.</span>Compiler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching">
            function <span class="apidocSignatureSpan">webpack.Compiler.</span>Watching
            <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Compiler.Watching">module webpack.Compiler.Watching</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.Watching">
            function <span class="apidocSignatureSpan">webpack.Compiler.</span>Watching
            <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Compiler.Watching.prototype">module webpack.Compiler.Watching.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.prototype._done">
            function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>_done
            <span class="apidocSignatureSpan">(err, compilation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.prototype._go">
            function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>_go
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.prototype.close">
            function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.prototype.invalidate">
            function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>invalidate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.Watching.prototype.watch">
            function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>watch
            <span class="apidocSignatureSpan">(files, dirs, missing)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Compiler.prototype">module webpack.Compiler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.compile">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>compile
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.createChildCompiler">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createChildCompiler
            <span class="apidocSignatureSpan">(compilation, compilerName, outputOptions, plugins)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.createCompilation">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createCompilation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.createContextModuleFactory">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createContextModuleFactory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.createNormalModuleFactory">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createNormalModuleFactory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.emitAssets">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>emitAssets
            <span class="apidocSignatureSpan">(compilation, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.emitRecords">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>emitRecords
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.isChild">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>isChild
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.newCompilation">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>newCompilation
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.newCompilationParams">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>newCompilationParams
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.purgeInputFileSystem">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>purgeInputFileSystem
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.readRecords">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>readRecords
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.run">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>run
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.runAsChild">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>runAsChild
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Compiler.prototype.watch">
            function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>watch
            <span class="apidocSignatureSpan">(watchOptions, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ContextModuleFactory">module webpack.ContextModuleFactory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextModuleFactory.ContextModuleFactory">
            function <span class="apidocSignatureSpan">webpack.</span>ContextModuleFactory
            <span class="apidocSignatureSpan">(resolvers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ContextModuleFactory.prototype">module webpack.ContextModuleFactory.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextModuleFactory.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>constructor
            <span class="apidocSignatureSpan">(resolvers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextModuleFactory.prototype.create">
            function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ContextModuleFactory.prototype.resolveDependencies">
            function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>resolveDependencies
            <span class="apidocSignatureSpan">(fs, resource, recursive, regExp, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.DelegatedModule">module webpack.DelegatedModule</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DelegatedModule.DelegatedModule">
            function <span class="apidocSignatureSpan">webpack.</span>DelegatedModule
            <span class="apidocSignatureSpan">(sourceRequest, data, type, userRequest)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.DelegatedModule.prototype">module webpack.DelegatedModule.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>delegated</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DelegatedModule.prototype.build">
            function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>build
            <span class="apidocSignatureSpan">(options, compilation, resolver, fs, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DelegatedModule.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>constructor
            <span class="apidocSignatureSpan">(sourceRequest, data, type, userRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DelegatedModule.prototype.identifier">
            function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>identifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DelegatedModule.prototype.needRebuild">
            function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>needRebuild
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DelegatedModule.prototype.readableIdentifier">
            function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>readableIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DelegatedModule.prototype.size">
            function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DelegatedModule.prototype.source">
            function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>source
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DelegatedModule.prototype.unbuild">
            function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>unbuild
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.DependenciesBlock">module webpack.DependenciesBlock</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DependenciesBlock.DependenciesBlock">
            function <span class="apidocSignatureSpan">webpack.</span>DependenciesBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.DependenciesBlock.prototype">module webpack.DependenciesBlock.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DependenciesBlock.prototype.addBlock">
            function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>addBlock
            <span class="apidocSignatureSpan">(block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DependenciesBlock.prototype.addDependency">
            function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>addDependency
            <span class="apidocSignatureSpan">(dependency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DependenciesBlock.prototype.addVariable">
            function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>addVariable
            <span class="apidocSignatureSpan">(name, expression, dependencies)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DependenciesBlock.prototype.disconnect">
            function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DependenciesBlock.prototype.hasDependencies">
            function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>hasDependencies
            <span class="apidocSignatureSpan">(filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DependenciesBlock.prototype.sortItems">
            function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>sortItems
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DependenciesBlock.prototype.unseal">
            function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>unseal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DependenciesBlock.prototype.updateHash">
            function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>updateHash
            <span class="apidocSignatureSpan">(hash)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Dependency">module webpack.Dependency</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Dependency.Dependency">
            function <span class="apidocSignatureSpan">webpack.</span>Dependency
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Dependency.compare">
            function <span class="apidocSignatureSpan">webpack.Dependency.</span>compare
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.DynamicEntryPlugin">module webpack.DynamicEntryPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DynamicEntryPlugin.DynamicEntryPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>DynamicEntryPlugin
            <span class="apidocSignatureSpan">(context, entry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.DynamicEntryPlugin.createDependency">
            function <span class="apidocSignatureSpan">webpack.DynamicEntryPlugin.</span>createDependency
            <span class="apidocSignatureSpan">(entry, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.EntryModuleNotFoundError">module webpack.EntryModuleNotFoundError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.EntryModuleNotFoundError.EntryModuleNotFoundError">
            function <span class="apidocSignatureSpan">webpack.</span>EntryModuleNotFoundError
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.EntryModuleNotFoundError.prototype">module webpack.EntryModuleNotFoundError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.EntryModuleNotFoundError.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.EntryModuleNotFoundError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ErrorHelpers">module webpack.ErrorHelpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ErrorHelpers.cleanUp">
            function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cleanUp
            <span class="apidocSignatureSpan">(stack, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ErrorHelpers.cutOffLoaderExecution">
            function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cutOffLoaderExecution
            <span class="apidocSignatureSpan">(stack)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ErrorHelpers.cutOffMessage">
            function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cutOffMessage
            <span class="apidocSignatureSpan">(stack, message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ExternalModuleFactoryPlugin">module webpack.ExternalModuleFactoryPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ExternalModuleFactoryPlugin.ExternalModuleFactoryPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>ExternalModuleFactoryPlugin
            <span class="apidocSignatureSpan">(type, externals)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ExternalModuleFactoryPlugin.prototype">module webpack.ExternalModuleFactoryPlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ExternalModuleFactoryPlugin.prototype.apply">
            function <span class="apidocSignatureSpan">webpack.ExternalModuleFactoryPlugin.prototype.</span>apply
            <span class="apidocSignatureSpan">(normalModuleFactory)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.FlagDependencyUsagePlugin">module webpack.FlagDependencyUsagePlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.FlagDependencyUsagePlugin.FlagDependencyUsagePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>FlagDependencyUsagePlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.FlagDependencyUsagePlugin.prototype">module webpack.FlagDependencyUsagePlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.FlagDependencyUsagePlugin.prototype.apply">
            function <span class="apidocSignatureSpan">webpack.FlagDependencyUsagePlugin.prototype.</span>apply
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.HotModuleReplacementPlugin">module webpack.HotModuleReplacementPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.HotModuleReplacementPlugin.HotModuleReplacementPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>HotModuleReplacementPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.HotModuleReplacementPlugin.prototype">module webpack.HotModuleReplacementPlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.HotModuleReplacementPlugin.prototype.apply">
            function <span class="apidocSignatureSpan">webpack.HotModuleReplacementPlugin.prototype.</span>apply
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.JsonpChunkTemplatePlugin">module webpack.JsonpChunkTemplatePlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.JsonpChunkTemplatePlugin.JsonpChunkTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>JsonpChunkTemplatePlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.JsonpChunkTemplatePlugin.prototype">module webpack.JsonpChunkTemplatePlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.JsonpChunkTemplatePlugin.prototype.apply">
            function <span class="apidocSignatureSpan">webpack.JsonpChunkTemplatePlugin.prototype.</span>apply
            <span class="apidocSignatureSpan">(chunkTemplate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.JsonpMainTemplatePlugin">module webpack.JsonpMainTemplatePlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.JsonpMainTemplatePlugin.JsonpMainTemplatePlugin">
            function <span class="apidocSignatureSpan">webpack.</span>JsonpMainTemplatePlugin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.JsonpMainTemplatePlugin.prototype">module webpack.JsonpMainTemplatePlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.JsonpMainTemplatePlugin.prototype.apply">
            function <span class="apidocSignatureSpan">webpack.JsonpMainTemplatePlugin.prototype.</span>apply
            <span class="apidocSignatureSpan">(mainTemplate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.LibManifestPlugin">module webpack.LibManifestPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.LibManifestPlugin.LibManifestPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>LibManifestPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.LibManifestPlugin.prototype">module webpack.LibManifestPlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.LibManifestPlugin.prototype.apply">
            function <span class="apidocSignatureSpan">webpack.LibManifestPlugin.prototype.</span>apply
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.MemoryOutputFileSystem">module webpack.MemoryOutputFileSystem</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.MemoryOutputFileSystem">
            function <span class="apidocSignatureSpan">webpack.</span>MemoryOutputFileSystem
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.MemoryOutputFileSystem.prototype">module webpack.MemoryOutputFileSystem.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype._remove">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>_remove
            <span class="apidocSignatureSpan">(_path, name, testFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.createReadStream">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>createReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.createWriteStream">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>createWriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.exists">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>exists
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.existsSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>existsSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.join">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>join
            <span class="apidocSignatureSpan">(path, request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.meta">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>meta
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdir">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdir
            <span class="apidocSignatureSpan">(path, optArg, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirp">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirp
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirpSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirpSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.normalize">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>normalize
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.pathToArray">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>pathToArray
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFile">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readFile
            <span class="apidocSignatureSpan">(path, optArg, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFileSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readFileSync
            <span class="apidocSignatureSpan">(_path, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdir">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readdir
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdirSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readdirSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlink">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readlink
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlinkSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readlinkSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdir">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>rmdir
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdirSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>rmdirSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.stat">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>stat
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.statSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>statSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlink">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>unlink
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlinkSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>unlinkSync
            <span class="apidocSignatureSpan">(_path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFile">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>writeFile
            <span class="apidocSignatureSpan">(path, content, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFileSync">
            function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>writeFileSync
            <span class="apidocSignatureSpan">(_path, content, encoding)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Module">module webpack.Module</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.Module">
            function <span class="apidocSignatureSpan">webpack.</span>Module
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Module.prototype">module webpack.Module.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.addChunk">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>addChunk
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.addReason">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>addReason
            <span class="apidocSignatureSpan">(module, dependency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.disconnect">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.hasReasonForChunk">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>hasReasonForChunk
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.isProvided">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>isProvided
            <span class="apidocSignatureSpan">(exportName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.isUsed">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>isUsed
            <span class="apidocSignatureSpan">(exportName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.needRebuild">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>needRebuild
            <span class="apidocSignatureSpan">(fileTimestamps, contextTimestamps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.removeChunk">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>removeChunk
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.removeReason">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>removeReason
            <span class="apidocSignatureSpan">(module, dependency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.rewriteChunkInReasons">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>rewriteChunkInReasons
            <span class="apidocSignatureSpan">(oldChunk, newChunks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.sortItems">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>sortItems
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.toString">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.unbuild">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>unbuild
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.unseal">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>unseal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Module.prototype.updateHash">
            function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>updateHash
            <span class="apidocSignatureSpan">(hash)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.Module.prototype.</span>build</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.Module.prototype.</span>identifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.Module.prototype.</span>nameForCondition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.Module.prototype.</span>readableIdentifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.Module.prototype.</span>size</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.Module.prototype.</span>source</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ModuleFilenameHelpers">module webpack.ModuleFilenameHelpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ModuleFilenameHelpers.createFilename">
            function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>createFilename
            <span class="apidocSignatureSpan">(module, moduleFilenameTemplate, requestShortener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ModuleFilenameHelpers.createFooter">
            function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>createFooter
            <span class="apidocSignatureSpan">(module, requestShortener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ModuleFilenameHelpers.matchObject">
            function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>matchObject
            <span class="apidocSignatureSpan">(obj, str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ModuleFilenameHelpers.matchPart">
            function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>matchPart
            <span class="apidocSignatureSpan">(str, test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ModuleFilenameHelpers.replaceDuplicates">
            function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>replaceDuplicates
            <span class="apidocSignatureSpan">(array, fn, comparator)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_ABSOLUTE_RESOURCE_PATH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_ALL_LOADERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_ALL_LOADERS_RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_HASH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_ID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_LOADERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_LOADERS_RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_QUERY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>REGEXP_RESOURCE_PATH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>ABSOLUTE_RESOURCE_PATH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>ALL_LOADERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>ALL_LOADERS_RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>HASH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>ID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>LOADERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>LOADERS_RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>QUERY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>RESOURCE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>RESOURCE_PATH</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.MultiCompiler">module webpack.MultiCompiler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler.MultiCompiler">
            function <span class="apidocSignatureSpan">webpack.</span>MultiCompiler
            <span class="apidocSignatureSpan">(compilers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.MultiCompiler.prototype">module webpack.MultiCompiler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>constructor
            <span class="apidocSignatureSpan">(compilers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler.prototype.purgeInputFileSystem">
            function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>purgeInputFileSystem
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler.prototype.run">
            function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>run
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.MultiCompiler.prototype.watch">
            function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>watch
            <span class="apidocSignatureSpan">(watchOptions, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.NodeStuffPlugin">module webpack.NodeStuffPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NodeStuffPlugin.NodeStuffPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>NodeStuffPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.NodeStuffPlugin.prototype">module webpack.NodeStuffPlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NodeStuffPlugin.prototype.apply">
            function <span class="apidocSignatureSpan">webpack.NodeStuffPlugin.prototype.</span>apply
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.NormalModuleFactory">module webpack.NormalModuleFactory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NormalModuleFactory.NormalModuleFactory">
            function <span class="apidocSignatureSpan">webpack.</span>NormalModuleFactory
            <span class="apidocSignatureSpan">(context, resolvers, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.NormalModuleFactory.prototype">module webpack.NormalModuleFactory.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NormalModuleFactory.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.NormalModuleFactory.prototype.</span>constructor
            <span class="apidocSignatureSpan">(context, resolvers, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NormalModuleFactory.prototype.create">
            function <span class="apidocSignatureSpan">webpack.NormalModuleFactory.prototype.</span>create
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NormalModuleFactory.prototype.createParser">
            function <span class="apidocSignatureSpan">webpack.NormalModuleFactory.prototype.</span>createParser
            <span class="apidocSignatureSpan">(parserOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NormalModuleFactory.prototype.getParser">
            function <span class="apidocSignatureSpan">webpack.NormalModuleFactory.prototype.</span>getParser
            <span class="apidocSignatureSpan">(parserOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.NormalModuleFactory.prototype.resolveRequestArray">
            function <span class="apidocSignatureSpan">webpack.NormalModuleFactory.prototype.</span>resolveRequestArray
            <span class="apidocSignatureSpan">(contextInfo, context, array, resolver, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Parser">module webpack.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.Parser">
            function <span class="apidocSignatureSpan">webpack.</span>Parser
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.Parser.prototype">module webpack.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.constructor">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.enterArrayPattern">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterArrayPattern
            <span class="apidocSignatureSpan">(pattern, onIdent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.enterAssignmentPattern">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterAssignmentPattern
            <span class="apidocSignatureSpan">(pattern, onIdent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.enterIdentifier">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterIdentifier
            <span class="apidocSignatureSpan">(pattern, onIdent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.enterObjectPattern">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterObjectPattern
            <span class="apidocSignatureSpan">(pattern, onIdent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.enterPattern">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterPattern
            <span class="apidocSignatureSpan">(pattern, onIdent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.enterRestElement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterRestElement
            <span class="apidocSignatureSpan">(pattern, onIdent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.evaluate">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>evaluate
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.evaluateExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>evaluateExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.getRenameIdentifier">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>getRenameIdentifier
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.inScope">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>inScope
            <span class="apidocSignatureSpan">(params, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.initializeEvaluating">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>initializeEvaluating
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.isHoistedStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>isHoistedStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">(source, initialState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.parseCalculatedString">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>parseCalculatedString
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.parseCalculatedStringArray">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>parseCalculatedStringArray
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.parseString">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>parseString
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.parseStringArray">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>parseStringArray
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkArrayExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkArrayExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkArrayPattern">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkArrayPattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkArrowFunctionExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkArrowFunctionExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkAssignmentExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkAssignmentExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkAwaitExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkAwaitExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkBinaryExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkBinaryExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkBlockStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkBlockStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkCallExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkCallExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkCatchClause">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkCatchClause
            <span class="apidocSignatureSpan">(catchClause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkClass">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkClass
            <span class="apidocSignatureSpan">(classy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkClassDeclaration">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkClassDeclaration
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkClassExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkClassExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkConditionalExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkConditionalExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkDoWhileStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkDoWhileStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkExportAllDeclaration">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExportAllDeclaration
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkExportDefaultDeclaration">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExportDefaultDeclaration
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkExportNamedDeclaration">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExportNamedDeclaration
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkExpressionStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExpressionStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkExpressions">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExpressions
            <span class="apidocSignatureSpan">(expressions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkForInStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkForInStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkForOfStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkForOfStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkForStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkForStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkFunctionDeclaration">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkFunctionDeclaration
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkFunctionExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkFunctionExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkIdentifier">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkIdentifier
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkIfStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkIfStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkImportDeclaration">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkImportDeclaration
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkLabeledStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkLabeledStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkLogicalExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkLogicalExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkMemberExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkMemberExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkMethodDefinition">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkMethodDefinition
            <span class="apidocSignatureSpan">(methodDefinition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkNewExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkNewExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkObjectExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkObjectExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkObjectPattern">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkObjectPattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkPattern">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkPattern
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkRestElement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkRestElement
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkReturnStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkReturnStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkSequenceExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkSequenceExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkSpreadElement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkSpreadElement
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkStatements">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkStatements
            <span class="apidocSignatureSpan">(statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkSwitchCases">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkSwitchCases
            <span class="apidocSignatureSpan">(switchCases)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkSwitchStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkSwitchStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkTaggedTemplateExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkTaggedTemplateExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkTemplateLiteral">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkTemplateLiteral
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkThrowStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkThrowStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkTryStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkTryStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkUnaryExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkUnaryExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkUpdateExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkUpdateExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkVariableDeclaration">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkVariableDeclaration
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkVariableDeclarators">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkVariableDeclarators
            <span class="apidocSignatureSpan">(declarators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkWhileStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkWhileStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkWithStatement">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkWithStatement
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.Parser.prototype.walkYieldExpression">
            function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkYieldExpression
            <span class="apidocSignatureSpan">(expression)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.ParserHelpers">module webpack.ParserHelpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.addParsedVariableToModule">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>addParsedVariableToModule
            <span class="apidocSignatureSpan">(parser, name, expression)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.approve">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>approve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.evaluateToBoolean">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>evaluateToBoolean
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.evaluateToString">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>evaluateToString
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.expressionIsUnsupported">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>expressionIsUnsupported
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.requireFileAsExpression">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>requireFileAsExpression
            <span class="apidocSignatureSpan">(context, pathToModule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.skipTraversal">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>skipTraversal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.ParserHelpers.toConstantDependency">
            function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>toConstantDependency
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.SizeFormatHelpers">module webpack.SizeFormatHelpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.SizeFormatHelpers.formatSize">
            function <span class="apidocSignatureSpan">webpack.SizeFormatHelpers.</span>formatSize
            <span class="apidocSignatureSpan">(size &lt;= 0)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.SourceMapDevToolPlugin">module webpack.SourceMapDevToolPlugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.SourceMapDevToolPlugin.SourceMapDevToolPlugin">
            function <span class="apidocSignatureSpan">webpack.</span>SourceMapDevToolPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.SourceMapDevToolPlugin.prototype">module webpack.SourceMapDevToolPlugin.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.SourceMapDevToolPlugin.prototype.apply">
            function <span class="apidocSignatureSpan">webpack.SourceMapDevToolPlugin.prototype.</span>apply
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.optimize">module webpack.optimize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.AggressiveMergingPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>AggressiveMergingPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.AggressiveSplittingPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>AggressiveSplittingPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.ChunkModuleIdRangePlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>ChunkModuleIdRangePlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.CommonsChunkPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>CommonsChunkPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.DedupePlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>DedupePlugin
            <span class="apidocSignatureSpan">(compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.LimitChunkCountPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>LimitChunkCountPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.MinChunkSizePlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>MinChunkSizePlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.OccurrenceOrderPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>OccurrenceOrderPlugin
            <span class="apidocSignatureSpan">(preferEntry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.optimize.UglifyJsPlugin">
            function <span class="apidocSignatureSpan">webpack.optimize.</span>UglifyJsPlugin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.system">module webpack.system</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.system.import">
            function <span class="apidocSignatureSpan">webpack.system.</span>import
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webpack.webpack_web">module webpack.webpack_web</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web.webpack_web">
            function <span class="apidocSignatureSpan">webpack.</span>webpack_web
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web.Compiler">
            function <span class="apidocSignatureSpan">webpack.webpack_web.</span>Compiler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web.WebEnvironmentPlugin">
            function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebEnvironmentPlugin
            <span class="apidocSignatureSpan">(inputFileSystem, outputFileSystem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web.WebpackOptionsApply">
            function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebpackOptionsApply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webpack.webpack_web.WebpackOptionsDefaulter">
            function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebpackOptionsDefaulter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack" id="apidoc.module.webpack">module webpack</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.AutomaticPrefetchPlugin" id="apidoc.element.webpack.AutomaticPrefetchPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>AutomaticPrefetchPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AutomaticPrefetchPlugin {
	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			const normalModuleFactory = params.normalModuleFactory;

			compilation.dependencyFactories.set(PrefetchDependency, normalModuleFactory);
		});
		let lastModules = null;
		compiler.plugin("after-compile", (compilation, callback) =&gt; {
			lastModules = compilation.modules
				.filter(m =&gt; m instanceof NormalModule)
				.map(m =&gt; ({
					context: m.context,
					request: m.request
				}));
			callback();
		});
		compiler.plugin("make", (compilation, callback) =&gt; {
			if(!lastModules) return callback();
			async.forEach(lastModules, (m, callback) =&gt; {
				compilation.prefetch(m.context || compiler.context, new PrefetchDependency(m.request), callback);
			}, callback);
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.BannerPlugin" id="apidoc.element.webpack.BannerPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>BannerPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class BannerPlugin {
	constructor(options) {
		if(arguments.length &gt; 1)
			throw new Error("BannerPlugin only takes one argument (pass an options object)");
		if(typeof options === "string")
			options = {
				banner: options
			};
		this.options = options || {};
		this.banner = this.options.raw ? options.banner : wrapComment(options.banner);
	}

	apply(compiler) {
		const options = this.options;
		const banner = this.banner;

		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-chunk-assets", (chunks, callback) =&gt; {
				chunks.forEach((chunk) =&gt; {
					if(options.entryOnly &amp;&amp; !chunk.isInitial()) return;

					chunk.files
						.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options))
						.forEach((file) =&gt;
							compilation.assets[file] = new ConcatSource(
								banner, "\n", compilation.assets[file]
							)
						);
				});
				callback();
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.CachePlugin" id="apidoc.element.webpack.CachePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>CachePlugin
        <span class="apidocSignatureSpan">(cache)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CachePlugin {
	constructor(cache) {
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.apply(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
						new Error(`CachePlugin - Cache cannot be used because of: ${compilation.notCacheable}`)
					);
				}
			});
			compiler.plugin("watch-run", (compiler, callback) =&gt; {
				this.watching = true;
				callback();
			});
			compiler.plugin("run", (compiler, callback) =&gt; {
				if(!compiler._lastCompilationFileDependencies) return callback();
				const fs = compiler.inputFileSystem;
				const fileTs = compiler.fileTimestamps = {};
				async.forEach(compiler._lastCompilationFileDependencies, (file, callback) =&gt; {
					fs.stat(file, (err, stat) =&gt; {
						if(err) {
							if(err.code === "ENOENT") return callback();
							return callback(err);
						}

						if(stat.mtime)
							this.applyMtime(+stat.mtime);

						fileTs[file] = +stat.mtime || Infinity;
						callback();
					});
				}, err =&gt; {
					if(err) return callback(err);
					Object.keys(fileTs).forEach(key =&gt; {
						fileTs[key] += this.FS_ACCURENCY;
					});
					callback();
				});
			});
			compiler.plugin("after-compile", function(compilation, callback) {
				compilation.compiler._lastCompilationFileDependencies = compilation.fileDependencies;
				compilation.compiler._lastCompilationContextDependencies = compilation.contextDependencies;
				callback();
			});
		}
	}

	/* istanbul ignore next */
	applyMtime(mtime) {
		if(this.FS_ACCURENCY &gt; 1 &amp;&amp; mtime % 2 !== 0)
			this.FS_ACCURENCY = 1;
		else if(this.FS_ACCURENCY &gt; 10 &amp;&amp; mtime % 20 !== 0)
			this.FS_ACCURENCY = 10;
		else if(this.FS_ACCURENCY &gt; 100 &amp;&amp; mtime % 200 !== 0)
			this.FS_ACCURENCY = 100;
		else if(this.FS_ACCURENCY &gt; 1000 &amp;&amp; mtime % 2000 !== 0)
			this.FS_ACCURENCY = 1000;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler" id="apidoc.element.webpack.Compiler">
        function <span class="apidocSignatureSpan">webpack.</span>Compiler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler() {
	Tapable.call(this);

	this.outputPath = "";
	this.outputFileSystem = null;
	this.inputFileSystem = null;

	this.recordsInputPath = null;
	this.recordsOutputPath = null;
	this.records = {};

	this.fileTimestamps = {};
	this.contextTimestamps = {};

	this.resolvers = {
		normal: null,
		loader: null,
		context: null
	};
	var deprecationReported = false;
	this.parser = {
		plugin: function(hook, fn) {
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.plugin(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.plugin(hook, fn);
				});
			});
		}.bind(this),
		apply: function() {
			var args = arguments;
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.apply(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.apply.apply(parser, args);
				});
			});
		}.bind(this)
	};

	this.options = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching" id="apidoc.element.webpack.Compiler.Watching">
        function <span class="apidocSignatureSpan">webpack.</span>Compiler.Watching
        <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Watching(compiler, watchOptions, handler) {
	this.startTime = null;
	this.invalid = false;
	this.error = null;
	this.stats = null;
	this.handler = handler;
	this.closed = false;
	if(typeof watchOptions === "number") {
		this.watchOptions = {
			aggregateTimeout: watchOptions
		};
	} else if(watchOptions &amp;&amp; typeof watchOptions === "object") {
		this.watchOptions = Object.assign({}, watchOptions);
	} else {
		this.watchOptions = {};
	}
	this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200;
	this.compiler = compiler;
	this.running = true;
	this.compiler.readRecords(function(err) {
		if(err) return this._done(err);

		this._go();
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ContextModuleFactory" id="apidoc.element.webpack.ContextModuleFactory">
        function <span class="apidocSignatureSpan">webpack.</span>ContextModuleFactory
        <span class="apidocSignatureSpan">(resolvers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ContextModuleFactory(resolvers) {
	Tapable.call(this);
	this.resolvers = resolvers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ContextReplacementPlugin" id="apidoc.element.webpack.ContextReplacementPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ContextReplacementPlugin
        <span class="apidocSignatureSpan">(resourceRegExp, newContentResource, newContentRecursive, newContentRegExp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ContextReplacementPlugin {
	constructor(resourceRegExp, newContentResource, newContentRecursive, newContentRegExp) {
		this.resourceRegExp = resourceRegExp;

		if(typeof newContentResource === "function") {
			this.newContentCallback = newContentResource;
		} else if(typeof newContentResource === "string" &amp;&amp; typeof newContentRecursive === "object") {
			this.newContentResource = newContentResource;
			this.newContentCreateContextMap = (fs, callback) =&gt; {
				callback(null, newContentRecursive);
			};
		} else if(typeof newContentResource === "string" &amp;&amp; typeof newContentRecursive === "function") {
			this.newContentResource = newContentResource;
			this.newContentCreateContextMap = newContentRecursive;
		} else {
			if(typeof newContentResource !== "string") {
				newContentRegExp = newContentRecursive;
				newContentRecursive = newContentResource;
				newContentResource = undefined;
			}
			if(typeof newContentRecursive !== "boolean") {
				newContentRegExp = newContentRecursive;
				newContentRecursive = undefined;
			}
			this.newContentResource = newContentResource;
			this.newContentRecursive = newContentRecursive;
			this.newContentRegExp = newContentRegExp;
		}
	}

	apply(compiler) {
		const resourceRegExp = this.resourceRegExp;
		const newContentCallback = this.newContentCallback;
		const newContentResource = this.newContentResource;
		const newContentRecursive = this.newContentRecursive;
		const newContentRegExp = this.newContentRegExp;
		const newContentCreateContextMap = this.newContentCreateContextMap;

		compiler.plugin("context-module-factory", (cmf) =&gt; {
			cmf.plugin("before-resolve", (result, callback) =&gt; {
				if(!result) return callback();
				if(resourceRegExp.test(result.request)) {
					if(typeof newContentResource !== "undefined")
						result.request = newContentResource;
					if(typeof newContentRecursive !== "undefined")
						result.recursive = newContentRecursive;
					if(typeof newContentRegExp !== "undefined")
						result.regExp = newContentRegExp;
					if(typeof newContentCallback === "function") {
						newContentCallback(result);
					} else {
						result.dependencies.forEach((d) =&gt; {
							if(d.critical)
								d.critical = false;
						});
					}
				}
				return callback(null, result);
			});
			cmf.plugin("after-resolve", (result, callback) =&gt; {
				if(!result) return callback();
				if(resourceRegExp.test(result.resource)) {
					if(typeof newContentResource !== "undefined")
						result.resource = path.resolve(result.resource, newContentResource);
					if(typeof newContentRecursive !== "undefined")
						result.recursive = newContentRecursive;
					if(typeof newContentRegExp !== "undefined")
						result.regExp = newContentRegExp;
					if(typeof newContentCreateContextMap === "function")
						result.resolveDependencies = createResolveDependenciesFromContextMap(newContentCreateContextMap);
					if(typeof newContentCallback === "function") {
						const origResource = result.resource;
						newContentCallback(result);
						if(result.resource !== origResource) {
							result.resource = path.resolve(origResource, result.resource);
						}
					} else {
						result.dependencies.forEach((d) =&gt; {
							if(d.critical)
								d.critical = false;
						});
					}
				}
				return callback(null, result);
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DefinePlugin" id="apidoc.element.webpack.DefinePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>DefinePlugin
        <span class="apidocSignatureSpan">(definitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DefinePlugin {
	constructor(definitions) {
		this.definitions = definitions;
	}

	apply(compiler) {
		const definitions = this.definitions;
		compiler.plugin("compilation", (compilation, params) =&gt; {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

			params.normalModuleFactory.plugin("parser", (parser) =&gt; {
				(function walkDefinitions(definitions, prefix) {
					Object.keys(definitions).forEach((key) =&gt; {
						const code = definitions[key];
						if(code &amp;&amp; typeof code === "object" &amp;&amp; !(code instanceof RegExp)) {
							walkDefinitions(code, prefix + key + ".");
							applyObjectDefine(prefix + key, code);
							return;
						}
						applyDefineKey(prefix, key);
						applyDefine(prefix + key, code);
					});
				}(definitions, ""));

				function stringifyObj(obj) {
					return "__webpack_require__.i({" + Object.keys(obj).map((key) =&gt; {
						const code = obj[key];
						return JSON.stringify(key) + ":" + toCode(code);
					}).join(",") + "})";
				}

				function toCode(code) {
					if(code === null) return "null";
					else if(code === undefined) return "undefined";
					else if(code instanceof RegExp &amp;&amp; code.toString) return code.toString();
					else if(typeof code === "function" &amp;&amp; code.toString) return "(" + code.toString() + ")";
					else if(typeof code === "object") return stringifyObj(code);
					else return code + "";
				}

				function applyDefineKey(prefix, key) {
					const splittedKey = key.split(".");
					splittedKey.slice(1).forEach((_, i) =&gt; {
						const fullKey = prefix + splittedKey.slice(0, i + 1).join(".");
						parser.plugin("can-rename " + fullKey, ParserHelpers.approve);
					});
				}

				function applyDefine(key, code) {
					const isTypeof = /^typeof\s+/.test(key);
					if(isTypeof) key = key.replace(/^typeof\s+/, "");
					let recurse = false;
					let recurseTypeof = false;
					code = toCode(code);
					if(!isTypeof) {
						parser.plugin("can-rename " + key, ParserHelpers.approve);
						parser.plugin("evaluate Identifier " + key, (expr) =&gt; {
							/**
							 * this is needed in case there is a recursion in the DefinePlugin
							 * to prevent an endless recursion
							 * e.g.: new DefinePlugin({
							 * "a": "b",
							 * "b": "a"
							 * });
							 */
							if(recurse) return;
							recurse = true;
							const res = parser.evaluate(code);
							recurse = false;
							res.setRange(expr.range);
							return res;
						});
						parser.plugin("expression " + key, ParserHelpers.toConstantDependency(code));
					}
					const typeofCode = isTypeof ? code : "typeof (" + code + ")";
					parser.plugin("evaluate typeof " + key, (expr) =&gt; {
						/**
						 * this is needed in case there is a recursion in the DefinePlugin
						 * to prevent an endless recursion
						 * e.g.: new DefinePlugin({
						 * "typeof a": "tyepof b",
						 * "typeof b": "typeof a"
						 * });
						 */
						if(recurseTypeof) return;
						recurseTypeof = true;
						const res = parser.evaluate(typeofCode);
						recurseTypeof = false;
						res.setRange(expr.range);
						return res;
					});
					parser.plugin("typeof " + key, (expr) =&gt; {
						const res = parser.evaluate(typeofCode);
						if(!res.isString()) return;
						return ParserHelpers.toConstantDependency(JSON.stringify(res.string)).bind(parser)(expr);
					});
				}

				function applyObjectDefine(key, obj) {
					const code = stringifyObj(obj);
					parser.plugin("can-rename " + key, ParserHelpers.approve);
					parser.plugin("evaluate Identifier " + key, (expr) =&gt; new BasicEvaluatedExpression().setRange(expr.range));
					parser.plugin("evaluate typeof " + key, ParserHelpers.evaluateToString("object"));
					parser.plugin("expression " + key, ParserHelpers.toConstantDependency(code));
					parser.plugin("typeof " + key, ParserHelpers.toConstantDependency(JSON.stringify("object")));
				}
			});
		} ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DelegatedModule" id="apidoc.element.webpack.DelegatedModule">
        function <span class="apidocSignatureSpan">webpack.</span>DelegatedModule
        <span class="apidocSignatureSpan">(sourceRequest, data, type, userRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DelegatedModule(sourceRequest, data, type, userRequest) {
	Module.call(this);
	this.sourceRequest = sourceRequest;
	this.request = data.id;
	this.meta = data.meta;
	this.type = type;
	this.userRequest = userRequest;
	this.built = false;
	this.delegateData = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DependenciesBlock" id="apidoc.element.webpack.DependenciesBlock">
        function <span class="apidocSignatureSpan">webpack.</span>DependenciesBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DependenciesBlock() {
	this.dependencies = [];
	this.blocks = [];
	this.variables = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Dependency" id="apidoc.element.webpack.Dependency">
        function <span class="apidocSignatureSpan">webpack.</span>Dependency
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Dependency {
	constructor() {
		this.module = null;
	}

	isEqualResource() {
		return false;
	}

	// Returns the referenced module and export
	getReference() {
		if(!this.module) return null;
		return {
			module: this.module,
			importedNames: true, // true: full object, false: only sideeffects/no export, array of strings: the exports with this names
		};
	}

	// Returns the exported names
	getExports() {
		return null;
	}

	getWarnings() {
		return null;
	}

	getErrors() {
		return null;
	}

	updateHash(hash) {
		hash.update((this.module &amp;&amp; this.module.id) + "");
	}

	disconnect() {
		this.module = null;
	}

	compare(a, b) {
		return compareLocations(a.loc, b.loc);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DllPlugin" id="apidoc.element.webpack.DllPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>DllPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DllPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.plugin("entry-option", (context, entry) =&gt; {
			function itemToPlugin(item, name) {
				if(Array.isArray(item))
					return new DllEntryPlugin(context, item, name);
				else
					throw new Error("DllPlugin: supply an Array as entry");
			}
			if(typeof entry === "object" &amp;&amp; !Array.isArray(entry)) {
				Object.keys(entry).forEach(name =&gt; {
					compiler.apply(itemToPlugin(entry[name], name));
				});
			} else {
				compiler.apply(itemToPlugin(entry, "main"));
			}
			return true;
		});
		compiler.apply(new LibManifestPlugin(this.options));
		compiler.apply(new FlagInitialModulesAsUsedPlugin());
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DllReferencePlugin" id="apidoc.element.webpack.DllReferencePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>DllReferencePlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DllReferencePlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			const normalModuleFactory = params.normalModuleFactory;
			compilation.dependencyFactories.set(DelegatedSourceDependency, normalModuleFactory);
		});

		compiler.plugin("before-compile", (params, callback) =&gt; {
			const manifest = this.options.manifest;
			if(typeof manifest === "string") {
				params.compilationDependencies.push(manifest);
				compiler.inputFileSystem.readFile(manifest, function(err, result) {
					if(err) return callback(err);
					params["dll reference " + manifest] = JSON.parse(result.toString("utf-8"));
					return callback();
				});
			} else {
				return callback();
			}
		});

		compiler.plugin("compile", (params) =&gt; {
			let manifest = this.options.manifest;
			if(typeof manifest === "string") {
				manifest = params["dll reference " + manifest];
			}
			const name = this.options.name || manifest.name;
			const sourceType = this.options.sourceType || "var";
			const externals = {};
			const source = "dll-reference " + name;
			externals[source] = name;
			params.normalModuleFactory.apply(new ExternalModuleFactoryPlugin(sourceType, externals));
			params.normalModuleFactory.apply(new DelegatedModuleFactoryPlugin({
				source: source,
				type: this.options.type,
				scope: this.options.scope,
				context: this.options.context || compiler.options.context,
				content: this.options.content || manifest.content,
				extensions: this.options.extensions
			}));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DynamicEntryPlugin" id="apidoc.element.webpack.DynamicEntryPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>DynamicEntryPlugin
        <span class="apidocSignatureSpan">(context, entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DynamicEntryPlugin {
	constructor(context, entry) {
		this.context = context;
		this.entry = entry;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			const multiModuleFactory = new MultiModuleFactory();
			const normalModuleFactory = params.normalModuleFactory;

			compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);
			compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
		});

		compiler.plugin("make", (compilation, callback) =&gt; {
			const addEntry = (entry, name) =&gt; {
				const dep = DynamicEntryPlugin.createDependency(entry, name);
				return new Promise((resolve, reject) =&gt; {
					compilation.addEntry(this.context, dep, name, (err) =&gt; {
						if(err) return reject(err);
						resolve();
					});
				});
			};

			Promise.resolve(this.entry()).then((entry) =&gt; {
				if(typeof entry === "string" || Array.isArray(entry)) {
					addEntry(entry, "main").then(() =&gt; callback(), callback);
				} else if(typeof entry === "object") {
					Promise.all(Object.keys(entry).map((name) =&gt; {
						return addEntry(entry[name], name);
					})).then(() =&gt; callback(), callback);
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.EntryModuleNotFoundError" id="apidoc.element.webpack.EntryModuleNotFoundError">
        function <span class="apidocSignatureSpan">webpack.</span>EntryModuleNotFoundError
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EntryModuleNotFoundError(err) {
	Error.call(this);
	this.name = "EntryModuleNotFoundError";
	this.message = "Entry module not found: " + err;
	this.details = err.details;
	this.error = err;
	Error.captureStackTrace(this, EntryModuleNotFoundError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.EnvironmentPlugin" id="apidoc.element.webpack.EnvironmentPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>EnvironmentPlugin
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class EnvironmentPlugin {
	constructor(keys) {
		if(Array.isArray(keys)) {
			this.keys = keys;
			this.defaultValues = {};
		} else if(keys &amp;&amp; typeof keys === "object") {
			this.keys = Object.keys(keys);
			this.defaultValues = keys;
		} else {
			this.keys = Array.prototype.slice.call(arguments);
			this.defaultValues = {};
		}
	}

	apply(compiler) {
		const definitions = this.keys.reduce((defs, key) =&gt; {
			const value = process.env[key] !== undefined ? process.env[key] : this.defaultValues[key];

			if(value === undefined) {
				compiler.plugin("this-compilation", compilation =&gt; {
					const error = new Error(
						`EnvironmentPlugin - ${key} environment variable is undefined.\n\n` +
						"You can pass an object with default values to suppress this warning.\n" +
						"See https://webpack.js.org/plugins/environment-plugin for example."
					);

					error.name = "EnvVariableNotDefinedError";
					compilation.warnings.push(error);
				});
			}

			defs[`process.env.${key}`] = typeof value === "undefined" ? "undefined" : JSON.stringify(value);

			return defs;
		}, {});

		compiler.apply(new DefinePlugin(definitions));
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.EvalDevToolModulePlugin" id="apidoc.element.webpack.EvalDevToolModulePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>EvalDevToolModulePlugin
        <span class="apidocSignatureSpan">(sourceUrlComment, moduleFilenameTemplate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class EvalDevToolModulePlugin {
	constructor(sourceUrlComment, moduleFilenameTemplate) {
		this.sourceUrlComment = sourceUrlComment;
		this.moduleFilenameTemplate = moduleFilenameTemplate;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.moduleTemplate.apply(new EvalDevToolModuleTemplatePlugin(this.sourceUrlComment, this.moduleFilenameTemplate));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.EvalSourceMapDevToolPlugin" id="apidoc.element.webpack.EvalSourceMapDevToolPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>EvalSourceMapDevToolPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class EvalSourceMapDevToolPlugin {
	constructor(options) {
		if(arguments.length &gt; 1)
			throw new Error("EvalSourceMapDevToolPlugin only takes one argument (pass an options object)");
		if(typeof options === "string") {
			options = {
				append: options
			};
		}
		if(!options) options = {};
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
			compilation.moduleTemplate.apply(new EvalSourceMapDevToolModuleTemplatePlugin(compilation, options));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ExtendedAPIPlugin" id="apidoc.element.webpack.ExtendedAPIPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ExtendedAPIPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ExtendedAPIPlugin {
	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
			compilation.mainTemplate.plugin("require-extensions", function(source, chunk, hash) {
				const buf = [source];
				buf.push("");
				buf.push("// __webpack_hash__");
				buf.push(`${this.requireFn}.h = ${JSON.stringify(hash)};`);
				return this.asString(buf);
			});
			compilation.mainTemplate.plugin("global-hash", () =&gt; true);

			params.normalModuleFactory.plugin("parser", (parser, parserOptions) =&gt; {
				Object.keys(REPLACEMENTS).forEach(key =&gt; {
					parser.plugin(`expression ${key}`, ParserHelpers.toConstantDependency(REPLACEMENTS[key]));
					parser.plugin(`evaluate typeof ${key}`, ParserHelpers.evaluateToString(REPLACEMENT_TYPES[key]));
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ExternalModuleFactoryPlugin" id="apidoc.element.webpack.ExternalModuleFactoryPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ExternalModuleFactoryPlugin
        <span class="apidocSignatureSpan">(type, externals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ExternalModuleFactoryPlugin(type, externals) {
	this.type = type;
	this.externals = externals;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ExternalsPlugin" id="apidoc.element.webpack.ExternalsPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ExternalsPlugin
        <span class="apidocSignatureSpan">(type, externals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ExternalsPlugin {
	constructor(type, externals) {
		this.type = type;
		this.externals = externals;
	}
	apply(compiler) {
		compiler.plugin("compile", (params) =&gt; {
			params.normalModuleFactory.apply(new ExternalModuleFactoryPlugin(this.type, this.externals));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.FlagDependencyUsagePlugin" id="apidoc.element.webpack.FlagDependencyUsagePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>FlagDependencyUsagePlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FlagDependencyUsagePlugin() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.HashedModuleIdsPlugin" id="apidoc.element.webpack.HashedModuleIdsPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>HashedModuleIdsPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class HashedModuleIdsPlugin {
	constructor(options) {
		this.options = Object.assign({
			hashFunction: "md5",
			hashDigest: "base64",
			hashDigestLength: 4
		}, options);
	}

	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			const usedIds = new Set();
			compilation.plugin("before-module-ids", (modules) =&gt; {
				modules.forEach((module) =&gt; {
					if(module.id === null &amp;&amp; module.libIdent) {
						const id = module.libIdent({
							context: this.options.context || compiler.options.context
						});
						const hash = createHash(options.hashFunction);
						hash.update(id);
						const hashId = hash.digest(options.hashDigest);
						let len = options.hashDigestLength;
						while(usedIds.has(hashId.substr(0, len)))
							len++;
						module.id = hashId.substr(0, len);
						usedIds.add(module.id);
					}
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.HotModuleReplacementPlugin" id="apidoc.element.webpack.HotModuleReplacementPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>HotModuleReplacementPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HotModuleReplacementPlugin(options) {
	options = options || {};
	this.multiStep = options.multiStep;
	this.fullBuildTimeout = options.fullBuildTimeout || 200;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.IgnorePlugin" id="apidoc.element.webpack.IgnorePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>IgnorePlugin
        <span class="apidocSignatureSpan">(resourceRegExp, contextRegExp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class IgnorePlugin {
	constructor(resourceRegExp, contextRegExp) {
		this.resourceRegExp = resourceRegExp;
		this.contextRegExp = contextRegExp;
	}

	apply(compiler) {
		const resourceRegExp = this.resourceRegExp;
		const contextRegExp = this.contextRegExp;
		compiler.plugin("normal-module-factory", (nmf) =&gt; {
			nmf.plugin("before-resolve", (result, callback) =&gt; {
				if(!result) return callback();
				if(resourceRegExp.test(result.request) &amp;&amp;
					(!contextRegExp || contextRegExp.test(result.context))) {
					return callback();
				}
				return callback(null, result);
			});
		});
		compiler.plugin("context-module-factory", (cmf) =&gt; {
			cmf.plugin("before-resolve", (result, callback) =&gt; {
				if(!result) return callback();
				if(resourceRegExp.test(result.request)) {
					return callback();
				}
				return callback(null, result);
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.JsonpChunkTemplatePlugin" id="apidoc.element.webpack.JsonpChunkTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>JsonpChunkTemplatePlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JsonpChunkTemplatePlugin() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.JsonpMainTemplatePlugin" id="apidoc.element.webpack.JsonpMainTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>JsonpMainTemplatePlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JsonpMainTemplatePlugin() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.JsonpTemplatePlugin" id="apidoc.element.webpack.JsonpTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>JsonpTemplatePlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class JsonpTemplatePlugin {
	apply(compiler) {
		compiler.plugin("this-compilation", (compilation) =&gt; {
			compilation.mainTemplate.apply(new JsonpMainTemplatePlugin());
			compilation.chunkTemplate.apply(new JsonpChunkTemplatePlugin());
			compilation.hotUpdateChunkTemplate.apply(new JsonpHotUpdateChunkTemplatePlugin());
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.LibManifestPlugin" id="apidoc.element.webpack.LibManifestPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>LibManifestPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LibManifestPlugin(options) {
	this.options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.LibraryTemplatePlugin" id="apidoc.element.webpack.LibraryTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>LibraryTemplatePlugin
        <span class="apidocSignatureSpan">(name, target, umdNamedDefine, auxiliaryComment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LibraryTemplatePlugin {

	constructor(name, target, umdNamedDefine, auxiliaryComment) {
		this.name = name;
		this.target = target;
		this.umdNamedDefine = umdNamedDefine;
		this.auxiliaryComment = auxiliaryComment;
	}

	apply(compiler) {
		compiler.plugin("this-compilation", (compilation) =&gt; {
			switch(this.target) {
				case "var":
					compilation.apply(new SetVarMainTemplatePlugin(`var ${accessorAccess(false, this.name)}`));
					break;
				case "assign":
					compilation.apply(new SetVarMainTemplatePlugin(accessorAccess(undefined, this.name)));
					break;
				case "this":
				case "window":
				case "global":
					if(this.name)
						compilation.apply(new SetVarMainTemplatePlugin(accessorAccess(this.target, this.name)));
					else
						compilation.apply(new SetVarMainTemplatePlugin(this.target, true));
					break;
				case "commonjs":
					if(this.name)
						compilation.apply(new SetVarMainTemplatePlugin(accessorAccess("exports", this.name)));
					else
						compilation.apply(new SetVarMainTemplatePlugin("exports", true));
					break;
				case "commonjs2":
				case "commonjs-module":
					compilation.apply(new SetVarMainTemplatePlugin("module.exports"));
					break;
				case "amd":
					var AmdMainTemplatePlugin = require("./AmdMainTemplatePlugin");
					compilation.apply(new AmdMainTemplatePlugin(this.name));
					break;
				case "umd":
				case "umd2":
					var UmdMainTemplatePlugin = require("./UmdMainTemplatePlugin");
					compilation.apply(new UmdMainTemplatePlugin(this.name, {
						optionalAmdExternalAsGlobal: this.target === "umd2",
						namedDefine: this.umdNamedDefine,
						auxiliaryComment: this.auxiliaryComment
					}));
					break;
				case "jsonp":
					var JsonpExportMainTemplatePlugin = require("./JsonpExportMainTemplatePlugin");
					compilation.apply(new JsonpExportMainTemplatePlugin(this.name));
					break;
				default:
					throw new Error(`${this.target} is not a valid Library target`);
			}
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.LoaderOptionsPlugin" id="apidoc.element.webpack.LoaderOptionsPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>LoaderOptionsPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LoaderOptionsPlugin {
	constructor(options) {
		if(typeof options !== "object") options = {};
		if(!options.test) options.test = {
			test: () =&gt; true
		};
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("normal-module-loader", (context, module) =&gt; {
				const resource = module.resource;
				if(!resource) return;
				const i = resource.indexOf("?");
				if(ModuleFilenameHelpers.matchObject(options, i &lt; 0 ? resource : resource.substr(0, i))) {
					const filterSet = new Set(["include", "exclude", "test"]);
					Object.keys(options)
						.filter((key) =&gt; !filterSet.has(key))
						.forEach((key) =&gt; context[key] = options[key]);
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				switch(err.params.additionalProperty) {
					case "debug":
						return `${baseMessage}\n` +
							"The 'debug' property was removed in webpack 2.\n" +
							"Loaders should be updated to allow passing this option via loader options in module.rules.\n" +
							"Until loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\n" +
							"plugins: [\n" +
							"  new webpack.<span class="apidocCodeKeywordSpan">LoaderOptionsPlugin</span>({\n" +
							"    debug: true\n" +
							"  })\n" +
							"]";
				}
				return baseMessage + "\n" +
					"For typos: please correct them.\n" +
					"For loader options: webpack 2 no longer allows custom properties in configuration.\n" +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.LoaderTargetPlugin" id="apidoc.element.webpack.LoaderTargetPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>LoaderTargetPlugin
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LoaderTargetPlugin {
	constructor(target) {
		this.target = target;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("normal-module-loader", (loaderContext) =&gt; loaderContext.target = this.target);
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem" id="apidoc.element.webpack.MemoryOutputFileSystem">
        function <span class="apidocSignatureSpan">webpack.</span>MemoryOutputFileSystem
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryFileSystem(data) {
	this.data = data || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module" id="apidoc.element.webpack.Module">
        function <span class="apidocSignatureSpan">webpack.</span>Module
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module() {
	DependenciesBlock.call(this);
	this.context = null;
	this.reasons = [];
	this.debugId = debugId++;
	this.lastId = -1;
	this.id = null;
	this.portableId = null;
	this.index = null;
	this.index2 = null;
	this.depth = null;
	this.used = null;
	this.usedExports = null;
	this.providedExports = null;
	this.chunks = [];
	this.warnings = [];
	this.dependenciesWarnings = [];
	this.errors = [];
	this.dependenciesErrors = [];
	this.strict = false;
	this.meta = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler" id="apidoc.element.webpack.MultiCompiler">
        function <span class="apidocSignatureSpan">webpack.</span>MultiCompiler
        <span class="apidocSignatureSpan">(compilers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiCompiler(compilers) {
	Tapable.call(this);
	if(!Array.isArray(compilers)) {
		compilers = Object.keys(compilers).map(function(name) {
			compilers[name].name = name;
			return compilers[name];
		});
	}
	this.compilers = compilers;

	function delegateProperty(name) {
		Object.defineProperty(this, name, {
			configurable: false,
			get: function() {
				throw new Error("Cannot read " + name + " of a MultiCompiler");
			},
			set: function(value) {
				this.compilers.forEach(function(compiler) {
					compiler[name] = value;
				});
			}.bind(this)
		});
	}
	delegateProperty.call(this, "outputFileSystem");
	delegateProperty.call(this, "inputFileSystem");

	Object.defineProperty(this, "outputPath", {
		configurable: false,
		get: function() {
			var commonPath = compilers[0].outputPath;
			for(var i = 1; i &lt; compilers.length; i++) {
				while(compilers[i].outputPath.indexOf(commonPath) !== 0 &amp;&amp; /[\/\\]/.test(commonPath)) {
					commonPath = commonPath.replace(/[\/\\][^\/\\]*$/, "");
				}
			}
			if(!commonPath &amp;&amp; compilers[0].outputPath[0] === "/") return "/";
			return commonPath;
		}
	});

	var doneCompilers = 0;
	var compilerStats = [];
	this.compilers.forEach(function(compiler, idx) {
		var compilerDone = false;
		compiler.plugin("done", function(stats) {
			if(!compilerDone) {
				compilerDone = true;
				doneCompilers++;
			}
			compilerStats[idx] = stats;
			if(doneCompilers === this.compilers.length) {
				this.applyPlugins("done", new MultiStats(compilerStats));
			}
		}.bind(this));
		compiler.plugin("invalid", function() {
			if(compilerDone) {
				compilerDone = false;
				doneCompilers--;
			}
			this.applyPlugins("invalid");
		}.bind(this));
	}, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NamedModulesPlugin" id="apidoc.element.webpack.NamedModulesPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NamedModulesPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NamedModulesPlugin {
	constructor(options) {
		this.options = options || {};
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("before-module-ids", (modules) =&gt; {
				modules.forEach((module) =&gt; {
					if(module.id === null &amp;&amp; module.libIdent) {
						module.id = module.libIdent({
							context: this.options.context || compiler.options.context
						});
					}
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NewWatchingPlugin" id="apidoc.element.webpack.NewWatchingPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NewWatchingPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NewWatchingPlugin {
	apply(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.warnings.push(new Error("The 'NewWatchingPlugin' is no longer necessary (now default)"));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NoEmitOnErrorsPlugin" id="apidoc.element.webpack.NoEmitOnErrorsPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NoEmitOnErrorsPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NoEmitOnErrorsPlugin {
	apply(compiler) {
		compiler.plugin("should-emit", (compilation) =&gt; {
			if(compilation.errors.length &gt; 0)
				return false;
		});
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("should-record", () =&gt; {
				if(compilation.errors.length &gt; 0)
					return false;
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NoErrorsPlugin" id="apidoc.element.webpack.NoErrorsPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NoErrorsPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NoErrorsPlugin {
	apply(compiler) {
		compiler.plugin("should-emit", (compilation) =&gt; {
			if(!deprecationReported) {
				compilation.warnings.push("webpack: Using NoErrorsPlugin is deprecated.\n" +
					"Use NoEmitOnErrorsPlugin instead.\n");
				deprecationReported = true;
			}
			if(compilation.errors.length &gt; 0)
				return false;
		});
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("should-record", () =&gt; {
				if(compilation.errors.length &gt; 0)
					return false;
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NodeEnvironmentPlugin" id="apidoc.element.webpack.NodeEnvironmentPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NodeEnvironmentPlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NodeEnvironmentPlugin {
	apply(compiler) {
		compiler.inputFileSystem = new CachedInputFileSystem(new NodeJsInputFileSystem(), 60000);
		const inputFileSystem = compiler.inputFileSystem;
		compiler.outputFileSystem = new NodeOutputFileSystem();
		compiler.watchFileSystem = new NodeWatchFileSystem(compiler.inputFileSystem);
		compiler.plugin("before-run", (compiler, callback) =&gt; {
			if(compiler.inputFileSystem === inputFileSystem)
				inputFileSystem.purge();
			callback();
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NodeStuffPlugin" id="apidoc.element.webpack.NodeStuffPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NodeStuffPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodeStuffPlugin(options) {
	this.options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NormalModuleFactory" id="apidoc.element.webpack.NormalModuleFactory">
        function <span class="apidocSignatureSpan">webpack.</span>NormalModuleFactory
        <span class="apidocSignatureSpan">(context, resolvers, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NormalModuleFactory(context, resolvers, options) {
	Tapable.call(this);
	this.resolvers = resolvers;
	this.ruleSet = new RuleSet(options.rules || options.loaders);
	this.cachePredicate = typeof options.unsafeCache === "function" ? options.unsafeCache : Boolean.bind(null, options.unsafeCache);
	this.context = context || "";
	this.parserCache = {};
	this.plugin("factory", function() {
		var _this = this;
		return function(result, callback) {
			var resolver = _this.applyPluginsWaterfall0("resolver", null);

			// Ignored
			if(!resolver) return callback();

			resolver(result, function onDoneResolving(err, data) {
				if(err) return callback(err);

				// Ignored
				if(!data) return callback();

				// direct module
				if(typeof data.source === "function")
					return callback(null, data);

				_this.applyPluginsAsyncWaterfall("after-resolve", data, function(err, result) {
					if(err) return callback(err);

					// Ignored
					if(!result) return callback();

					var createdModule = _this.applyPluginsBailResult("create-module", result);
					if(!createdModule) {

						if(!result.request) {
							return callback(new Error("Empty dependency (no request)"));
						}

						createdModule = new NormalModule(
							result.request,
							result.userRequest,
							result.rawRequest,
							result.loaders,
							result.resource,
							result.parser
						);
					}

					createdModule = _this.applyPluginsWaterfall0("module", createdModule);

					return callback(null, createdModule);
				});
			});
		};
	});
	this.plugin("resolver", function() {
		var _this = this;
		return function(data, callback) {
			var contextInfo = data.contextInfo;
			var context = data.context;
			var request = data.request;
			var resolveContextInfo = {};

			var noAutoLoaders = /^-?!/.test(request);
			var noPrePostAutoLoaders = /^!!/.test(request);
			var noPostAutoLoaders = /^-!/.test(request);
			var elements = request.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!");
			var resource = elements.pop();
			elements = elements.map(identToLoaderRequest);

			async.parallel([
				function(callback) {
					_this.resolveRequestArray(resolveContextInfo, context, elements, _this.resolvers.loader, callback);
				},
				function(callback) {
					if(resource === "" || resource[0] === "?")
						return callback(null, {
							resource: resource
						});

					_this.resolvers.normal.resolve(resolveContextInfo, context, resource, function(err, resource, resourceResolveData) {
						if(err) return callback(err);
						callback(null, {
							resourceResolveData: resourceResolveData,
							resource: resource,
						});
					});
				}
			], function(err, results) {
				if(err) return callback(err);
				var loaders = results[0];
				var resourceResolveData = results[1].resourceResolveData;
				resource = results[1].resource;

				// translate option idents
				try {
					loaders.forEach(function(item) {
						if(typeof item.options === "string" &amp;&amp; /^\?/.test(item.options)) {
							item.options = _this.ruleSet.findOptionsByIdent(item.options.substr(1));
						}
					});
				} catch(e) {
					return callback(e);
				}

				if(resource === false)
					return callback(null,
						new RawModule("/* (ignored) */",
							"ignored " + context + " " + request,
							request + " (ignored)")); // ignored

				var userRequest = loaders.map(loaderToIdent).concat([resource]).join("!");

				var resourcePath = resource;
				var resourceQuery = "";
				var queryIndex = resourcePath.indexOf("?");
				if(queryIndex &gt;= 0) {
					resourceQuery = resourcePath.substr(queryIndex);
					resourcePath = resourcePath.substr(0, queryIndex);
				}

				var result = _this.ruleSet.exec({
					resource: resourcePath,
					resourceQuery: resourceQuery,
					issuer: contextInfo.issuer,
					compiler: contextInfo.compiler
				});
				var settings = {};
				var useLoadersPost = [];
				var useLoaders = [];
				var useLoadersPre = [];
				result.forEac ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NormalModuleReplacementPlugin" id="apidoc.element.webpack.NormalModuleReplacementPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NormalModuleReplacementPlugin
        <span class="apidocSignatureSpan">(resourceRegExp, newResource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class NormalModuleReplacementPlugin {
	constructor(resourceRegExp, newResource) {
		this.resourceRegExp = resourceRegExp;
		this.newResource = newResource;
	}

	apply(compiler) {
		const resourceRegExp = this.resourceRegExp;
		const newResource = this.newResource;
		compiler.plugin("normal-module-factory", (nmf) =&gt; {
			nmf.plugin("before-resolve", (result, callback) =&gt; {
				if(!result) return callback();
				if(resourceRegExp.test(result.request)) {
					if(typeof newResource === "function") {
						newResource(result);
					} else {
						result.request = newResource;
					}
				}
				return callback(null, result);
			});
			nmf.plugin("after-resolve", (result, callback) =&gt; {
				if(!result) return callback();
				if(resourceRegExp.test(result.resource)) {
					if(typeof newResource === "function") {
						newResource(result);
					} else {
						result.resource = path.resolve(path.dirname(result.resource), newResource);
					}
				}
				return callback(null, result);
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser" id="apidoc.element.webpack.Parser">
        function <span class="apidocSignatureSpan">webpack.</span>Parser
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options) {
	Tapable.call(this);
	this.options = options;
	this.initializeEvaluating();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.PrefetchPlugin" id="apidoc.element.webpack.PrefetchPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>PrefetchPlugin
        <span class="apidocSignatureSpan">(context, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PrefetchPlugin {

	constructor(context, request) {
		if(!request) {
			this.request = context;
		} else {
			this.context = context;
			this.request = request;
		}
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			const normalModuleFactory = params.normalModuleFactory;

			compilation.dependencyFactories.set(PrefetchDependency, normalModuleFactory);
		});
		compiler.plugin("make", (compilation, callback) =&gt; {
			compilation.prefetch(this.context || compiler.context, new PrefetchDependency(this.request), callback);
		});
	}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ProgressPlugin" id="apidoc.element.webpack.ProgressPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ProgressPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ProgressPlugin {

	constructor(options) {
		if(typeof options === "function") {
			options = {
				handler: options
			};
		}
		options = options || {};
		this.profile = options.profile;
		this.handler = options.handler;
	}

	apply(compiler) {
		const handler = this.handler || defaultHandler;
		const profile = this.profile;
		if(compiler.compilers) {
			const states = new Array(compiler.compilers.length);
			compiler.compilers.forEach(function(compiler, idx) {
				compiler.apply(new ProgressPlugin(function(p, msg) {
					states[idx] = Array.prototype.slice.apply(arguments);
					handler.apply(null, [
						states.map(state =&gt; state &amp;&amp; state[0] || 0).reduce((a, b) =&gt; a + b) / states.length,
						`[${idx}] ${msg}`
					].concat(Array.prototype.slice.call(arguments, 2)));
				}));
			});
		} else {
			let lastModulesCount = 0;
			let moduleCount = 500;
			let doneModules = 0;
			const activeModules = [];

			const update = function update(module) {
				handler(
					0.1 + (doneModules / Math.max(lastModulesCount, moduleCount)) * 0.6,
					"building modules",
					`${doneModules}/${moduleCount} modules`,
					`${activeModules.length} active`,
					activeModules[activeModules.length - 1]
				);
			};

			const moduleDone = function moduleDone(module) {
				doneModules++;
				const ident = module.identifier();
				if(ident) {
					const idx = activeModules.indexOf(ident);
					if(idx &gt;= 0) activeModules.splice(idx, 1);
				}
				update();
			};
			compiler.plugin("compilation", function(compilation) {
				if(compilation.compiler.isChild()) return;
				lastModulesCount = moduleCount;
				moduleCount = 0;
				doneModules = 0;
				handler(0, "compiling");
				compilation.plugin("build-module", function(module) {
					moduleCount++;
					const ident = module.identifier();
					if(ident) {
						activeModules.push(ident);
					}
					update();
				});
				compilation.plugin("failed-module", moduleDone);
				compilation.plugin("succeed-module", moduleDone);
				const syncHooks = {
					"seal": [0.71, "sealing"],
					"optimize": [0.72, "optimizing"],
					"optimize-modules-basic": [0.73, "basic module optimization"],
					"optimize-modules": [0.74, "module optimization"],
					"optimize-modules-advanced": [0.75, "advanced module optimization"],
					"optimize-chunks-basic": [0.76, "basic chunk optimization"],
					"optimize-chunks": [0.77, "chunk optimization"],
					"optimize-chunks-advanced": [0.78, "advanced chunk optimization"],
					// optimize-tree
					"revive-modules": [0.80, "module reviving"],
					"optimize-module-order": [0.81, "module order optimization"],
					"optimize-module-ids": [0.82, "module id optimization"],
					"revive-chunks": [0.83, "chunk reviving"],
					"optimize-chunk-order": [0.84, "chunk order optimization"],
					"optimize-chunk-ids": [0.85, "chunk id optimization"],
					"before-hash": [0.86, "hashing"],
					"before-module-assets": [0.87, "module assets processing"],
					"before-chunk-assets": [0.88, "chunk assets processing"],
					"additional-chunk-assets": [0.89, "additional chunk assets processing"],
					"record": [0.90, "recording"]
				};
				Object.keys(syncHooks).forEach(name =&gt; {
					let pass = 0;
					const settings = syncHooks[name];
					compilation.plugin(name, () =&gt; {
						if(pass++ &gt; 0)
							handler(settings[0], settings[1], `pass ${pass}`);
						else
							handler(settings[0], settings[1]);
					});
				});
				compilation.plugin("optimize-tree", (chunks, modules, callback) =&gt; {
					handler(0.79, "module and chunk tree optimization");
					callback();
				});
				compilation.plugin("additional-assets", callback =&gt; {
					handler(0.91, "additional asset processing");
					callback();
				});
				compilation.plugin("optimize-chunk-assets", (chunks, callback) =&gt; {
					handler(0.92, "chunk asset optimization");
					callback();
				});
				compilation.plugin("optimize-assets", (assets, callback) =&gt; {
					handler(0.94, "asset optimization");
					callback(); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ProvidePlugin" id="apidoc.element.webpack.ProvidePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ProvidePlugin
        <span class="apidocSignatureSpan">(definitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ProvidePlugin {
	constructor(definitions) {
		this.definitions = definitions;
	}

	apply(compiler) {
		const definitions = this.definitions;
		compiler.plugin("compilation", (compilation, params) =&gt; {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
			params.normalModuleFactory.plugin("parser", (parser, parserOptions) =&gt; {
				Object.keys(definitions).forEach(name =&gt; {
					var request = [].concat(definitions[name]);
					var splittedName = name.split(".");
					if(splittedName.length &gt; 0) {
						splittedName.slice(1).forEach((_, i) =&gt; {
							const name = splittedName.slice(0, i + 1).join(".");
							parser.plugin(`can-rename ${name}`, ParserHelpers.approve);
						});
					}
					parser.plugin(`expression ${name}`, function(expr) {
						let nameIdentifier = name;
						const scopedName = name.indexOf(".") &gt;= 0;
						let expression = `require(${JSON.stringify(request[0])})`;
						if(scopedName) {
							nameIdentifier = `__webpack_provided_${name.replace(/\./g, "_dot_")}`;
						}
						if(request.length &gt; 1) {
							expression += request.slice(1).map(r =&gt; `[${JSON.stringify(r)}]`).join("");
						}
						if(!ParserHelpers.addParsedVariableToModule(this, nameIdentifier, expression)) {
							return false;
						}
						if(scopedName) {
							ParserHelpers.toConstantDependency(nameIdentifier).bind(this)(expr);
						}
						return true;
					});
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.SetVarMainTemplatePlugin" id="apidoc.element.webpack.SetVarMainTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>SetVarMainTemplatePlugin
        <span class="apidocSignatureSpan">(varExpression, copyObject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SetVarMainTemplatePlugin {
	constructor(varExpression, copyObject) {
		this.varExpression = varExpression;
		this.copyObject = copyObject;
	}

	apply(compilation) {
		const mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", (source, chunk, hash) =&gt; {
			const varExpression = mainTemplate.applyPluginsWaterfall("asset-path", this.varExpression, {
				hash,
				chunk
			});
			if(this.copyObject) {
				return new ConcatSource(`(function(e, a) { for(var i in a) e[i] = a[i]; }(${varExpression}, `, source, "))");
			} else {
				const prefix = `${varExpression} =\n`;
				return new ConcatSource(prefix, source);
			}
		});
		mainTemplate.plugin("global-hash-paths", function(paths) {
			if(this.varExpression) paths.push(this.varExpression);
			return paths;
		});
		mainTemplate.plugin("hash", hash =&gt; {
			hash.update("set var");
			hash.update(`${this.varExpression}`);
			hash.update(`${this.copyObject}`);
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.SourceMapDevToolPlugin" id="apidoc.element.webpack.SourceMapDevToolPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>SourceMapDevToolPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceMapDevToolPlugin(options) {
	if(arguments.length &gt; 1)
		throw new Error("SourceMapDevToolPlugin only takes one argument (pass an options object)");
	if(typeof options === "string") {
		options = {
			sourceMapFilename: options
		};
	}
	if(!options) options = {};
	this.sourceMapFilename = options.filename;
	this.sourceMappingURLComment = options.append === false ? false : options.append || "\n//# sourceMappingURL=[url]";
	this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack:///[resourcePath]";
	this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || "webpack:///[resourcePath]?[hash]";
	this.options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.UmdMainTemplatePlugin" id="apidoc.element.webpack.UmdMainTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>UmdMainTemplatePlugin
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class UmdMainTemplatePlugin {
	constructor(name, options) {
		this.name = name;
		this.optionalAmdExternalAsGlobal = options.optionalAmdExternalAsGlobal;
		this.namedDefine = options.namedDefine;
		this.auxiliaryComment = options.auxiliaryComment;
	}

	apply(compilation) {
		const mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", function(source, chunk, hash) {
			let externals = chunk.modules.filter(m =&gt; m.external);
			const optionalExternals = [];
			let requiredExternals = [];
			if(this.optionalAmdExternalAsGlobal) {
				externals.forEach(m =&gt; {
					if(m.optional) {
						optionalExternals.push(m);
					} else {
						requiredExternals.push(m);
					}
				});
				externals = requiredExternals.concat(optionalExternals);
			} else {
				requiredExternals = externals;
			}

			function replaceKeys(str) {
				return mainTemplate.applyPluginsWaterfall("asset-path", str, {
					hash,
					chunk
				});
			}

			function externalsDepsArray(modules) {
				return `[${replaceKeys(modules.map(m =&gt; JSON.stringify(typeof m.request === "object" ? m.request.amd : m.request)).join(", "))}]`;
			}

			function externalsRootArray(modules) {
				return replaceKeys(modules.map(m =&gt; {
					let request = m.request;
					if(typeof request === "object") request = request.root;
					return `root${accessorToObjectAccess([].concat(request))}`;
				}).join(", "));
			}

			function externalsRequireArray(type) {
				return replaceKeys(externals.map(m =&gt; {
					let expr;
					let request = m.request;
					if(typeof request === "object") request = request[type];
					if(Array.isArray(request)) {
						expr = `require(${JSON.stringify(request[0])})${accessorToObjectAccess(request.slice(1))}`;
					} else
						expr = `require(${JSON.stringify(request)})`;
					if(m.optional) {
						expr = `(function webpackLoadOptionalExternalModule() { try { return ${expr}; } catch(e) {} }())`;
					}
					return expr;
				}).join(", "));
			}

			function externalsArguments(modules) {
				return modules.map(m =&gt; Template.toIdentifier(`__WEBPACK_EXTERNAL_MODULE_${m.id}__`)).join(", ");
			}

			function libraryName(library) {
				return JSON.stringify(replaceKeys([].concat(library).pop()));
			}

			let amdFactory;
			if(optionalExternals.length &gt; 0) {
				const wrapperArguments = externalsArguments(requiredExternals);
				const factoryArguments = requiredExternals.length &gt; 0 ?
					externalsArguments(requiredExternals) + ", " + externalsRootArray(optionalExternals) :
					externalsRootArray(optionalExternals);
				amdFactory = `function webpackLoadOptionalExternalModuleAmd(${wrapperArguments}) {\n` +
					`			return factory(${factoryArguments});\n` +
					"		}";
			} else {
				amdFactory = "factory";
			}

			return new ConcatSource(new OriginalSource(
				"(function webpackUniversalModuleDefinition(root, factory) {\n" +
				(this.auxiliaryComment &amp;&amp;
					typeof this.auxiliaryComment === "string" ?
					"   //" + this.auxiliaryComment + "\n" :
					this.auxiliaryComment.commonjs2 ?
					"   //" + this.auxiliaryComment.commonjs2 + "\n" :
					""
				) +
				"	if(typeof exports === 'object' &amp;&amp; typeof module === 'object')\n" +
				"		module.exports = factory(" + externalsRequireArray("commonjs2") + ");\n" +
				(this.auxiliaryComment &amp;&amp;
					typeof this.auxiliaryComment === "string" ?
					"   //" + this.auxiliaryComment + "\n" :
					this.auxiliaryComment.amd ?
					"   //" + this.auxiliaryComment.amd + "\n" :
					""
				) +
				"	else if(typeof define === 'function' &amp;&amp; define.amd)\n" +
				(requiredExternals.length &gt; 0 ?
					(this.name &amp;&amp; this.namedDefine === true ?
						"		define(" + libraryName(this.name) + ", " + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n" :
						"		define(" + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n"
					) :
					(this.name &amp;&amp; this.namedDefine === true ?
						"		define(" + libraryName(this.name) + ", [], " + amdFactory + ");\n" :
						" ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.WatchIgnorePlugin" id="apidoc.element.webpack.WatchIgnorePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>WatchIgnorePlugin
        <span class="apidocSignatureSpan">(paths)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WatchIgnorePlugin {
	constructor(paths) {
		this.paths = paths;
	}

	apply(compiler) {
		compiler.plugin("after-environment", () =&gt; {
			compiler.watchFileSystem = new IgnoringWatchFileSystem(compiler.watchFileSystem, this.paths);
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.WebpackOptionsApply" id="apidoc.element.webpack.WebpackOptionsApply">
        function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsApply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebpackOptionsApply extends OptionsApply {
	constructor() {
		super();
	}

	process(options, compiler) {
		let ExternalsPlugin;
		compiler.outputPath = options.output.path;
		compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;
		compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath;
		compiler.name = options.name;
		compiler.dependencies = options.dependencies;
		if(typeof options.target === "string") {
			let JsonpTemplatePlugin;
			let NodeSourcePlugin;
			let NodeTargetPlugin;
			let NodeTemplatePlugin;

			switch(options.target) {
				case "web":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeSourcePlugin = require("./node/NodeSourcePlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeSourcePlugin(options.node),
						new LoaderTargetPlugin("web")
					);
					break;
				case "webworker":
					{
						let WebWorkerTemplatePlugin = require("./webworker/WebWorkerTemplatePlugin");
						NodeSourcePlugin = require("./node/NodeSourcePlugin");
						compiler.apply(
							new WebWorkerTemplatePlugin(options.output),
							new FunctionModulePlugin(options.output),
							new NodeSourcePlugin(options.node),
							new LoaderTargetPlugin("webworker")
						);
						break;
					}
				case "node":
				case "async-node":
					NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					compiler.apply(
						new NodeTemplatePlugin({
							asyncChunkLoading: options.target === "async-node"
						}),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new LoaderTargetPlugin("node")
					);
					break;
				case "node-webkit":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", "nw.gui"),
						new LoaderTargetPlugin("node-webkit")
					);
					break;
				case "atom":
				case "electron":
				case "electron-main":
					NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new NodeTemplatePlugin({
							asyncChunkLoading: true
						}),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"app",
							"auto-updater",
							"browser-window",
							"content-tracing",
							"dialog",
							"electron",
							"global-shortcut",
							"ipc",
							"ipc-main",
							"menu",
							"menu-item",
							"power-monitor",
							"power-save-blocker",
							"protocol",
							"session",
							"web-contents",
							"tray",
							"clipboard",
							"crash-reporter",
							"native-image",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				case "electron-renderer":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"desktop-capturer",
							"electron",
							"ipc",
							"ipc-renderer",
							"remote",
							"web-frame",
							"clipboard",
							"crash-reporter",
							"native-image",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				default:
					throw new Error("Unsupported target '" + options.target ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.WebpackOptionsDefaulter" id="apidoc.element.webpack.WebpackOptionsDefaulter">
        function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsDefaulter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebpackOptionsDefaulter extends OptionsDefaulter {
	constructor() {
		super();
		this.set("devtool", false);
		this.set("cache", true);

		this.set("context", process.cwd());
		this.set("target", "web");

		this.set("module.unknownContextRequest", ".");
		this.set("module.unknownContextRegExp", false);
		this.set("module.unknownContextRecursive", true);
		this.set("module.unknownContextCritical", true);
		this.set("module.exprContextRequest", ".");
		this.set("module.exprContextRegExp", false);
		this.set("module.exprContextRecursive", true);
		this.set("module.exprContextCritical", true);
		this.set("module.wrappedContextRegExp", /.*/);
		this.set("module.wrappedContextRecursive", true);
		this.set("module.wrappedContextCritical", false);
		this.set("module.strictExportPresence", false);

		this.set("module.unsafeCache", true);

		this.set("output", "call", (value, options) =&gt; {
			if(typeof value === "string") {
				return {
					filename: value
				};
			} else if(typeof value !== "object") {
				return {};
			} else {
				return value;
			}
		});
		this.set("output.filename", "[name].js");
		this.set("output.chunkFilename", "make", (options) =&gt; {
			const filename = options.output.filename;
			return filename.indexOf("[name]") &gt;= 0 ? filename.replace("[name]", "[id]") : "[id]." + filename;
		});
		this.set("output.library", "");
		this.set("output.hotUpdateFunction", "make", (options) =&gt; {
			return Template.toIdentifier("webpackHotUpdate" + options.output.library);
		});
		this.set("output.jsonpFunction", "make", (options) =&gt; {
			return Template.toIdentifier("webpackJsonp" + options.output.library);
		});
		this.set("output.libraryTarget", "var");
		this.set("output.path", process.cwd());
		this.set("output.sourceMapFilename", "[file].map[query]");
		this.set("output.hotUpdateChunkFilename", "[id].[hash].hot-update.js");
		this.set("output.hotUpdateMainFilename", "[hash].hot-update.json");
		this.set("output.crossOriginLoading", false);
		this.set("output.hashFunction", "md5");
		this.set("output.hashDigest", "hex");
		this.set("output.hashDigestLength", 20);
		this.set("output.devtoolLineToLine", false);
		this.set("output.strictModuleExceptionHandling", false);

		this.set("node", {});
		this.set("node.console", false);
		this.set("node.process", true);
		this.set("node.global", true);
		this.set("node.Buffer", true);
		this.set("node.setImmediate", true);
		this.set("node.__filename", "mock");
		this.set("node.__dirname", "mock");

		this.set("performance.maxAssetSize", 250000);
		this.set("performance.maxEntrypointSize", 250000);
		this.set("performance.hints", false);

		this.set("resolve", {});
		this.set("resolve.unsafeCache", true);
		this.set("resolve.modules", ["node_modules"]);
		this.set("resolve.extensions", [".js", ".json"]);
		this.set("resolve.aliasFields", "make", (options) =&gt; {
			if(options.target === "web" || options.target === "webworker")
				return ["browser"];
			else
				return [];
		});
		this.set("resolve.mainFields", "make", (options) =&gt; {
			if(options.target === "web" || options.target === "webworker")
				return ["browser", "module", "main"];
			else
				return ["module", "main"];
		});
		this.set("resolveLoader", {});
		this.set("resolveLoader.unsafeCache", true);
		this.set("resolveLoader.mainFields", ["loader", "main"]);
		this.set("resolveLoader.extensions", [".js", ".json"]);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.WebpackOptionsValidationError" id="apidoc.element.webpack.WebpackOptionsValidationError">
        function <span class="apidocSignatureSpan">webpack.</span>WebpackOptionsValidationError
        <span class="apidocSignatureSpan">(validationErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebpackOptionsValidationError extends Error {

	constructor(validationErrors) {
		super();

		this.name = "WebpackOptionsValidationError";

		this.message = "Invalid configuration object. " +
			"Webpack has been initialised using a configuration object that does not match the API schema.\n" +
			validationErrors.map(err =&gt; " - " + indent(WebpackOptionsValidationError.formatValidationError(err), "   ", false)).join("\n");
		this.validationErrors = validationErrors;

		Error.captureStackTrace(this, this.constructor);
	}

	static formatSchema(schema, prevSchemas) {
		prevSchemas = prevSchemas || [];

		const formatInnerSchema = (innerSchema, addSelf) =&gt; {
			if(!addSelf) return WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas);
			if(prevSchemas.indexOf(innerSchema) &gt;= 0) return "(recursive)";
			return WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas.concat(schema));
		};

		if(schema.type === "string") {
			if(schema.minLength === 1)
				return "non-empty string";
			else if(schema.minLength &gt; 1)
				return `string (min length ${schema.minLength})`;
			return "string";
		} else if(schema.type === "boolean") {
			return "boolean";
		} else if(schema.type === "number") {
			return "number";
		} else if(schema.type === "object") {
			if(schema.properties) {
				const required = schema.required || [];
				return `object { ${Object.keys(schema.properties).map(property =&gt; {
					if(required.indexOf(property) &lt; 0) return property + "?";
					return property;
				}).concat(schema.additionalProperties ? ["..."] : []).join(", ")} }`;
			}
			if(schema.additionalProperties) {
				return `object { &lt;key&gt;: ${formatInnerSchema(schema.additionalProperties)} }`;
			}
			return "object";
		} else if(schema.type === "array") {
			return `[${formatInnerSchema(schema.items)}]`;
		}

		switch(schema.instanceof) {
			case "Function":
				return "function";
			case "RegExp":
				return "RegExp";
		}
		if(schema.$ref) return formatInnerSchema(getSchemaPart(schema.$ref), true);
		if(schema.allOf) return schema.allOf.map(formatInnerSchema).join(" &amp; ");
		if(schema.oneOf) return schema.oneOf.map(formatInnerSchema).join(" | ");
		if(schema.anyOf) return schema.anyOf.map(formatInnerSchema).join(" | ");
		if(schema.enum) return schema.enum.map(item =&gt; JSON.stringify(item)).join(" | ");
		return JSON.stringify(schema, 0, 2);
	}

	static formatValidationError(err) {
		const dataPath = `configuration${err.dataPath}`;
		if(err.keyword === "additionalProperties") {
			const baseMessage = `${dataPath} has an unknown property '${err.params.additionalProperty}'. These properties are valid:\n${getSchemaPartText
(err.parentSchema)}`;
			if(!err.dataPath) {
				switch(err.params.additionalProperty) {
					case "debug":
						return `${baseMessage}\n` +
							"The 'debug' property was removed in webpack 2.\n" +
							"Loaders should be updated to allow passing this option via loader options in module.rules.\n" +
							"Until loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\n" +
							"plugins: [\n" +
							"  new webpack.LoaderOptionsPlugin({\n" +
							"    debug: true\n" +
							"  })\n" +
							"]";
				}
				return baseMessage + "\n" +
					"For typos: please correct them.\n" +
					"For loader options: webpack 2 no longer allows custom properties in configuration.\n" +
					"  Loaders should be updated to allow passing options via loader options in module.rules.\n" +
					"  Until loaders are updated one can use the LoaderOptionsPlugin to pass these options to the loader:\n" +
					"  plugins: [\n" +
					"    new webpack.LoaderOptionsPlugin({\n" +
					"      // test: /\\.xxx$/, // may apply this only for some modules\n" +
					"      options: {\n" +
					`        ${err.params.additionalProperty}: ...\n` +
					"      }\n" +
					"    })\n" +
					"  ]";
			}
			return baseMessage;
		} else if(err.keyword === "oneOf" || err.keyword === "anyOf") {
			if(err.children &amp;&amp; err ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.validate" id="apidoc.element.webpack.validate">
        function <span class="apidocSignatureSpan">webpack.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.validateSchema" id="apidoc.element.webpack.validateSchema">
        function <span class="apidocSignatureSpan">webpack.</span>validateSchema
        <span class="apidocSignatureSpan">(schema, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateSchema(schema, options) {
	if(Array.isArray(options)) {
		const errors = options.map((options) =&gt; validateObject(schema, options));
		errors.forEach((list, idx) =&gt; {
			list.forEach(function applyPrefix(err) {
				err.dataPath = `[${idx}]${err.dataPath}`;
				if(err.children) {
					err.children.forEach(applyPrefix);
				}
			});
		});
		return errors.reduce((arr, items) =&gt; {
			return arr.concat(items);
		}, []);
	} else {
		return validateObject(schema, options);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.webpack_web" id="apidoc.element.webpack.webpack_web">
        function <span class="apidocSignatureSpan">webpack.</span>webpack_web
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function webpack(options, callback) {
	new WebpackOptionsDefaulter().process(options);

	const compiler = new Compiler();
	compiler.options = options;
	compiler.options = new WebpackOptionsApply().process(options, compiler);
	new WebEnvironmentPlugin(options.inputFileSystem, options.outputFileSystem).apply(compiler);
	if(callback) {
		compiler.run(callback);
	}
	return compiler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Compiler" id="apidoc.module.webpack.Compiler">module webpack.Compiler</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Compiler.Compiler" id="apidoc.element.webpack.Compiler.Compiler">
        function <span class="apidocSignatureSpan">webpack.</span>Compiler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler() {
	Tapable.call(this);

	this.outputPath = "";
	this.outputFileSystem = null;
	this.inputFileSystem = null;

	this.recordsInputPath = null;
	this.recordsOutputPath = null;
	this.records = {};

	this.fileTimestamps = {};
	this.contextTimestamps = {};

	this.resolvers = {
		normal: null,
		loader: null,
		context: null
	};
	var deprecationReported = false;
	this.parser = {
		plugin: function(hook, fn) {
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.plugin(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.plugin(hook, fn);
				});
			});
		}.bind(this),
		apply: function() {
			var args = arguments;
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.apply(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.apply.apply(parser, args);
				});
			});
		}.bind(this)
	};

	this.options = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching" id="apidoc.element.webpack.Compiler.Watching">
        function <span class="apidocSignatureSpan">webpack.Compiler.</span>Watching
        <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Watching(compiler, watchOptions, handler) {
	this.startTime = null;
	this.invalid = false;
	this.error = null;
	this.stats = null;
	this.handler = handler;
	this.closed = false;
	if(typeof watchOptions === "number") {
		this.watchOptions = {
			aggregateTimeout: watchOptions
		};
	} else if(watchOptions &amp;&amp; typeof watchOptions === "object") {
		this.watchOptions = Object.assign({}, watchOptions);
	} else {
		this.watchOptions = {};
	}
	this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200;
	this.compiler = compiler;
	this.running = true;
	this.compiler.readRecords(function(err) {
		if(err) return this._done(err);

		this._go();
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Compiler.Watching" id="apidoc.module.webpack.Compiler.Watching">module webpack.Compiler.Watching</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.Watching" id="apidoc.element.webpack.Compiler.Watching.Watching">
        function <span class="apidocSignatureSpan">webpack.Compiler.</span>Watching
        <span class="apidocSignatureSpan">(compiler, watchOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Watching(compiler, watchOptions, handler) {
	this.startTime = null;
	this.invalid = false;
	this.error = null;
	this.stats = null;
	this.handler = handler;
	this.closed = false;
	if(typeof watchOptions === "number") {
		this.watchOptions = {
			aggregateTimeout: watchOptions
		};
	} else if(watchOptions &amp;&amp; typeof watchOptions === "object") {
		this.watchOptions = Object.assign({}, watchOptions);
	} else {
		this.watchOptions = {};
	}
	this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200;
	this.compiler = compiler;
	this.running = true;
	this.compiler.readRecords(function(err) {
		if(err) return this._done(err);

		this._go();
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Compiler.Watching.prototype" id="apidoc.module.webpack.Compiler.Watching.prototype">module webpack.Compiler.Watching.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.prototype._done" id="apidoc.element.webpack.Compiler.Watching.prototype._done">
        function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>_done
        <span class="apidocSignatureSpan">(err, compilation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_done = function (err, compilation) {
	this.running = false;
	if(this.invalid) return this._go();
	this.error = err || null;
	this.stats = compilation ? compilation.getStats() : null;
	if(this.stats) {
		this.stats.startTime = this.startTime;
		this.stats.endTime = new Date().getTime();
	}
	if(this.stats)
		this.compiler.applyPlugins("done", this.stats);
	else
		this.compiler.applyPlugins("failed", this.error);
	this.handler(this.error, this.stats);
	if(!this.error &amp;&amp; !this.closed)
		this.watch(compilation.fileDependencies, compilation.contextDependencies, compilation.missingDependencies);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.prototype._go" id="apidoc.element.webpack.Compiler.Watching.prototype._go">
        function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>_go
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_go = function () {
	var self = this;
	self.startTime = new Date().getTime();
	self.running = true;
	self.invalid = false;
	self.compiler.applyPluginsAsync("watch-run", self, function(err) {
		if(err) return self._done(err);
		self.compiler.compile(function onCompiled(err, compilation) {
			if(err) return self._done(err);
			if(self.invalid) return self._done();

			if(self.compiler.applyPluginsBailResult("should-emit", compilation) === false) {
				return self._done(null, compilation);
			}

			self.compiler.emitAssets(compilation, function(err) {
				if(err) return self._done(err);
				if(self.invalid) return self._done();

				self.compiler.emitRecords(function(err) {
					if(err) return self._done(err);

					if(compilation.applyPluginsBailResult("need-additional-pass")) {
						compilation.needAdditionalPass = true;

						var stats = compilation.getStats();
						stats.startTime = self.startTime;
						stats.endTime = new Date().getTime();
						self.compiler.applyPlugins("done", stats);

						self.compiler.applyPluginsAsync("additional-pass", function(err) {
							if(err) return self._done(err);
							self.compiler.compile(onCompiled);
						});
						return;
					}
					return self._done(null, compilation);
				});
			});
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.prototype.close" id="apidoc.element.webpack.Compiler.Watching.prototype.close">
        function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
	if(callback === undefined) callback = function() {};

	this.closed = true;
	if(this.watcher) {
		this.watcher.close();
		this.watcher = null;
	}
	if(this.pausedWatcher) {
		this.pausedWatcher.close();
		this.pausedWatcher = null;
	}
	if(this.running) {
		this.invalid = true;
		this._done = () =&gt; {
			this.compiler.applyPlugins("watch-close");
			callback();
		};
	} else {
		this.compiler.applyPlugins("watch-close");
		callback();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.watchings.forEach((watching) =&gt; watching.invalidate());
	}

	close(callback) {
		if(callback === undefined) callback = () =&gt; { /*do nothing*/ };

		async.forEach(this.watchings, (watching, finishedCallback) =&gt; {
			watching.<span class="apidocCodeKeywordSpan">close</span>(finishedCallback);
		}, err =&gt; {
			this.compiler.applyPlugins("watch-close");
			callback(err);
		});

	}
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.prototype.invalidate" id="apidoc.element.webpack.Compiler.Watching.prototype.invalidate">
        function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>invalidate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invalidate = function () {
	if(this.watcher) {
		this.pausedWatcher = this.watcher;
		this.watcher.pause();
		this.watcher = null;
	}
	if(this.running) {
		this.invalid = true;
		return false;
	} else {
		this._go();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
class MultiWatching {
	constructor(watchings, compiler) {
		this.watchings = watchings;
		this.compiler = compiler;
	}

	invalidate() {
		this.watchings.forEach((watching) =&gt; watching.<span class="apidocCodeKeywordSpan">invalidate</span>());
	}

	close(callback) {
		if(callback === undefined) callback = () =&gt; { /*do nothing*/ };

		async.forEach(this.watchings, (watching, finishedCallback) =&gt; {
			watching.close(finishedCallback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.Watching.prototype.watch" id="apidoc.element.webpack.Compiler.Watching.prototype.watch">
        function <span class="apidocSignatureSpan">webpack.Compiler.Watching.prototype.</span>watch
        <span class="apidocSignatureSpan">(files, dirs, missing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watch = function (files, dirs, missing) {
	this.pausedWatcher = null;
	this.watcher = this.compiler.watchFileSystem.watch(files, dirs, missing, this.startTime, this.watchOptions, function(err, filesModified
, contextModified, missingModified, fileTimestamps, contextTimestamps) {
		this.pausedWatcher = this.watcher;
		this.watcher = null;
		if(err) return this.handler(err);

		this.compiler.fileTimestamps = fileTimestamps;
		this.compiler.contextTimestamps = contextTimestamps;
		this.invalidate();
	}.bind(this), function(fileName, changeTime) {
		this.compiler.applyPlugins("invalid", fileName, changeTime);
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		const ignored = path =&gt; this.paths.some(p =&gt; p instanceof RegExp ? p.test(path) : path.indexOf(p) === 0);

		const notIgnored = path =&gt; !ignored(path);

		const ignoredFiles = files.filter(ignored);
		const ignoredDirs = dirs.filter(ignored);

		this.wfs.<span class="apidocCodeKeywordSpan">watch</span>(files.filter(notIgnored), dirs.filter(notIgnored), missing, startTime
, options, (err, filesModified, dirsModified, missingModified, fileTimestamps, dirTimestamps) =&gt; {
			if(err) return callback(err);

			ignoredFiles.forEach(path =&gt; {
				fileTimestamps[path] = 1;
			});

			ignoredDirs.forEach(path =&gt; {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Compiler.prototype" id="apidoc.module.webpack.Compiler.prototype">module webpack.Compiler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.compile" id="apidoc.element.webpack.Compiler.prototype.compile">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>compile
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (callback) {
	var self = this;
	var params = self.newCompilationParams();
	self.applyPluginsAsync("before-compile", params, function(err) {
		if(err) return callback(err);

		self.applyPlugins("compile", params);

		var compilation = self.newCompilation(params);

		self.applyPluginsParallel("make", compilation, function(err) {
			if(err) return callback(err);

			compilation.finish();

			compilation.seal(function(err) {
				if(err) return callback(err);

				self.applyPluginsAsync("after-compile", compilation, function(err) {
					if(err) return callback(err);

					return callback(null, compilation);
				});
			});
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}, []);
	} else {
		return validateObject(schema, options);
	}
}

function validateObject(schema, options) {
	const validate = ajv.<span class="apidocCodeKeywordSpan">compile</span>(schema);
	const valid = validate(options);
	return valid ? [] : filterErrors(validate.errors);
}

function filterErrors(errors) {
	let newErrors = [];
	errors.forEach((err) =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.constructor" id="apidoc.element.webpack.Compiler.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler() {
	Tapable.call(this);

	this.outputPath = "";
	this.outputFileSystem = null;
	this.inputFileSystem = null;

	this.recordsInputPath = null;
	this.recordsOutputPath = null;
	this.records = {};

	this.fileTimestamps = {};
	this.contextTimestamps = {};

	this.resolvers = {
		normal: null,
		loader: null,
		context: null
	};
	var deprecationReported = false;
	this.parser = {
		plugin: function(hook, fn) {
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.plugin(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.plugin(hook, fn);
				});
			});
		}.bind(this),
		apply: function() {
			var args = arguments;
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.apply(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.apply.apply(parser, args);
				});
			});
		}.bind(this)
	};

	this.options = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.createChildCompiler" id="apidoc.element.webpack.Compiler.prototype.createChildCompiler">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createChildCompiler
        <span class="apidocSignatureSpan">(compilation, compilerName, outputOptions, plugins)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChildCompiler = function (compilation, compilerName, outputOptions, plugins) {
	var childCompiler = new Compiler();
	if(Array.isArray(plugins)) {
		plugins.forEach(plugin =&gt; childCompiler.apply(plugin));
	}
	for(var name in this._plugins) {
		if(["make", "compile", "emit", "after-emit", "invalid", "done", "this-compilation"].indexOf(name) &lt; 0)
			childCompiler._plugins[name] = this._plugins[name].slice();
	}
	childCompiler.name = compilerName;
	childCompiler.outputPath = this.outputPath;
	childCompiler.inputFileSystem = this.inputFileSystem;
	childCompiler.outputFileSystem = null;
	childCompiler.resolvers = this.resolvers;
	childCompiler.fileTimestamps = this.fileTimestamps;
	childCompiler.contextTimestamps = this.contextTimestamps;
	if(!this.records[compilerName]) this.records[compilerName] = [];
	this.records[compilerName].push(childCompiler.records = {});
	childCompiler.options = Object.create(this.options);
	childCompiler.options.output = Object.create(childCompiler.options.output);
	for(name in outputOptions) {
		childCompiler.options.output[name] = outputOptions[name];
	}
	childCompiler.parentCompilation = compilation;
	return childCompiler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	getStats() {
		return new Stats(this);
	}

	createChildCompiler(name, outputOptions) {
		return this.compiler.<span class="apidocCodeKeywordSpan">createChildCompiler</span>(this, name, outputOptions);
	}

	checkConstraints() {
		const usedIds = {};

		const modules = this.modules;
		for(let indexModule = 0; indexModule &lt; modules.length; indexModule++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.createCompilation" id="apidoc.element.webpack.Compiler.prototype.createCompilation">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createCompilation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCompilation = function () {
	return new Compilation(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.createContextModuleFactory" id="apidoc.element.webpack.Compiler.prototype.createContextModuleFactory">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createContextModuleFactory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createContextModuleFactory = function () {
	var contextModuleFactory = new ContextModuleFactory(this.resolvers, this.inputFileSystem);
	this.applyPlugins("context-module-factory", contextModuleFactory);
	return contextModuleFactory;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.createNormalModuleFactory" id="apidoc.element.webpack.Compiler.prototype.createNormalModuleFactory">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>createNormalModuleFactory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createNormalModuleFactory = function () {
	var normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolvers, this.options.module || {});
	this.applyPlugins("normal-module-factory", normalModuleFactory);
	return normalModuleFactory;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.emitAssets" id="apidoc.element.webpack.Compiler.prototype.emitAssets">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>emitAssets
        <span class="apidocSignatureSpan">(compilation, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emitAssets = function (compilation, callback) {
	var outputPath;

	this.applyPluginsAsync("emit", compilation, function(err) {
		if(err) return callback(err);
		outputPath = compilation.getPath(this.outputPath);
		this.outputFileSystem.mkdirp(outputPath, emitFiles.bind(this));
	}.bind(this));

	function emitFiles(err) {
		if(err) return callback(err);

		require("async").forEach(Object.keys(compilation.assets), function(file, callback) {

			var targetFile = file;
			var queryStringIdx = targetFile.indexOf("?");
			if(queryStringIdx &gt;= 0) {
				targetFile = targetFile.substr(0, queryStringIdx);
			}

			if(targetFile.match(/\/|\\/)) {
				var dir = path.dirname(targetFile);
				this.outputFileSystem.mkdirp(this.outputFileSystem.join(outputPath, dir), writeOut.bind(this));
			} else writeOut.call(this);

			function writeOut(err) {
				if(err) return callback(err);
				var targetPath = this.outputFileSystem.join(outputPath, targetFile);
				var source = compilation.assets[file];
				if(source.existsAt === targetPath) {
					source.emitted = false;
					return callback();
				}
				var content = source.source();

				if(!Buffer.isBuffer(content)) {
					content = new Buffer(content, "utf8"); //eslint-disable-line
				}

				source.existsAt = targetPath;
				source.emitted = true;
				this.outputFileSystem.writeFile(targetPath, content, callback);
			}

		}.bind(this), function(err) {
			if(err) return callback(err);

			afterEmit.call(this);
		}.bind(this));
	}

	function afterEmit() {
		this.applyPluginsAsyncSeries1("after-emit", compilation, function(err) {
			if(err) return callback(err);

			return callback();
		});
	}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.emitRecords" id="apidoc.element.webpack.Compiler.prototype.emitRecords">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>emitRecords
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitRecords(callback) {
	if(!this.recordsOutputPath) return callback();
	var idx1 = this.recordsOutputPath.lastIndexOf("/");
	var idx2 = this.recordsOutputPath.lastIndexOf("\\");
	var recordsOutputPathDirectory = null;
	if(idx1 &gt; idx2) recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);
	if(idx1 &lt; idx2) recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);
	if(!recordsOutputPathDirectory) return writeFile.call(this);
	this.outputFileSystem.mkdirp(recordsOutputPathDirectory, function(err) {
		if(err) return callback(err);
		writeFile.call(this);
	}.bind(this));

	function writeFile() {
		this.outputFileSystem.writeFile(this.recordsOutputPath, JSON.stringify(this.records, undefined, 2), callback);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.isChild" id="apidoc.element.webpack.Compiler.prototype.isChild">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>isChild
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isChild = function () {
	return !!this.parentCompilation;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				if(ident) {
					const idx = activeModules.indexOf(ident);
					if(idx &gt;= 0) activeModules.splice(idx, 1);
				}
				update();
			};
			compiler.plugin("compilation", function(compilation) {
				if(compilation.compiler.<span class="apidocCodeKeywordSpan">isChild</span>()) return;
				lastModulesCount = moduleCount;
				moduleCount = 0;
				doneModules = 0;
				handler(0, "compiling");
				compilation.plugin("build-module", function(module) {
					moduleCount++;
					const ident = module.identifier();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.newCompilation" id="apidoc.element.webpack.Compiler.prototype.newCompilation">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>newCompilation
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newCompilation = function (params) {
	var compilation = this.createCompilation();
	compilation.fileTimestamps = this.fileTimestamps;
	compilation.contextTimestamps = this.contextTimestamps;
	compilation.name = this.name;
	compilation.records = this.records;
	compilation.compilationDependencies = params.compilationDependencies;
	this.applyPlugins("this-compilation", compilation, params);
	this.applyPlugins("compilation", compilation, params);
	return compilation;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.newCompilationParams" id="apidoc.element.webpack.Compiler.prototype.newCompilationParams">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>newCompilationParams
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newCompilationParams = function () {
	var params = {
		normalModuleFactory: this.createNormalModuleFactory(),
		contextModuleFactory: this.createContextModuleFactory(),
		compilationDependencies: []
	};
	return params;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.purgeInputFileSystem" id="apidoc.element.webpack.Compiler.prototype.purgeInputFileSystem">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>purgeInputFileSystem
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purgeInputFileSystem = function () {
	if(this.inputFileSystem &amp;&amp; this.inputFileSystem.purge)
		this.inputFileSystem.purge();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.readRecords" id="apidoc.element.webpack.Compiler.prototype.readRecords">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>readRecords
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readRecords(callback) {
	var self = this;
	if(!self.recordsInputPath) {
		self.records = {};
		return callback();
	}
	self.inputFileSystem.stat(self.recordsInputPath, function(err) {
		// It doesn't exist
		// We can ignore self.
		if(err) return callback();

		self.inputFileSystem.readFile(self.recordsInputPath, function(err, content) {
			if(err) return callback(err);

			try {
				self.records = JSON.parse(content);
			} catch(e) {
				e.message = "Cannot parse records: " + e.message;
				return callback(e);
			}

			return callback();
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.run" id="apidoc.element.webpack.Compiler.prototype.run">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>run
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (callback) {
	var self = this;
	var startTime = new Date().getTime();

	self.applyPluginsAsync("before-run", self, function(err) {
		if(err) return callback(err);

		self.applyPluginsAsync("run", self, function(err) {
			if(err) return callback(err);

			self.readRecords(function(err) {
				if(err) return callback(err);

				self.compile(function onCompiled(err, compilation) {
					if(err) return callback(err);

					if(self.applyPluginsBailResult("should-emit", compilation) === false) {
						var stats = compilation.getStats();
						stats.startTime = startTime;
						stats.endTime = new Date().getTime();
						self.applyPlugins("done", stats);
						return callback(null, stats);
					}

					self.emitAssets(compilation, function(err) {
						if(err) return callback(err);

						if(compilation.applyPluginsBailResult("need-additional-pass")) {
							compilation.needAdditionalPass = true;

							var stats = compilation.getStats();
							stats.startTime = startTime;
							stats.endTime = new Date().getTime();
							self.applyPlugins("done", stats);

							self.applyPluginsAsync("additional-pass", function(err) {
								if(err) return callback(err);
								self.compile(onCompiled);
							});
							return;
						}

						self.emitRecords(function(err) {
							if(err) return callback(err);

							var stats = compilation.getStats();
							stats.startTime = startTime;
							stats.endTime = new Date().getTime();
							self.applyPlugins("done", stats);
							return callback(null, stats);
						});
					});
				});
			});
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	new WebpackOptionsDefaulter().process(options);

	const compiler = new Compiler();
	compiler.options = options;
	compiler.options = new WebpackOptionsApply().process(options, compiler);
	new WebEnvironmentPlugin(options.inputFileSystem, options.outputFileSystem).apply(compiler);
	if(callback) {
		compiler.<span class="apidocCodeKeywordSpan">run</span>(callback);
	}
	return compiler;
}
module.exports = webpack;

webpack.WebpackOptionsDefaulter = WebpackOptionsDefaulter;
webpack.WebpackOptionsApply = WebpackOptionsApply;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.runAsChild" id="apidoc.element.webpack.Compiler.prototype.runAsChild">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>runAsChild
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runAsChild = function (callback) {
	this.compile(function(err, compilation) {
		if(err) return callback(err);

		this.parentCompilation.children.push(compilation);
		Object.keys(compilation.assets).forEach(function(name) {
			this.parentCompilation.assets[name] = compilation.assets[name];
		}.bind(this));

		var entries = Object.keys(compilation.entrypoints).map(function(name) {
			return compilation.entrypoints[name].chunks;
		}).reduce(function(array, chunks) {
			return array.concat(chunks);
		}, []);

		return callback(null, entries, compilation);
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Compiler.prototype.watch" id="apidoc.element.webpack.Compiler.prototype.watch">
        function <span class="apidocSignatureSpan">webpack.Compiler.prototype.</span>watch
        <span class="apidocSignatureSpan">(watchOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watch = function (watchOptions, handler) {
	this.fileTimestamps = {};
	this.contextTimestamps = {};
	var watching = new Watching(this, watchOptions, handler);
	return watching;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		const ignored = path =&gt; this.paths.some(p =&gt; p instanceof RegExp ? p.test(path) : path.indexOf(p) === 0);

		const notIgnored = path =&gt; !ignored(path);

		const ignoredFiles = files.filter(ignored);
		const ignoredDirs = dirs.filter(ignored);

		this.wfs.<span class="apidocCodeKeywordSpan">watch</span>(files.filter(notIgnored), dirs.filter(notIgnored), missing, startTime
, options, (err, filesModified, dirsModified, missingModified, fileTimestamps, dirTimestamps) =&gt; {
			if(err) return callback(err);

			ignoredFiles.forEach(path =&gt; {
				fileTimestamps[path] = 1;
			});

			ignoredDirs.forEach(path =&gt; {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ContextModuleFactory" id="apidoc.module.webpack.ContextModuleFactory">module webpack.ContextModuleFactory</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ContextModuleFactory.ContextModuleFactory" id="apidoc.element.webpack.ContextModuleFactory.ContextModuleFactory">
        function <span class="apidocSignatureSpan">webpack.</span>ContextModuleFactory
        <span class="apidocSignatureSpan">(resolvers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ContextModuleFactory(resolvers) {
	Tapable.call(this);
	this.resolvers = resolvers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ContextModuleFactory.prototype" id="apidoc.module.webpack.ContextModuleFactory.prototype">module webpack.ContextModuleFactory.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ContextModuleFactory.prototype.constructor" id="apidoc.element.webpack.ContextModuleFactory.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>constructor
        <span class="apidocSignatureSpan">(resolvers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ContextModuleFactory(resolvers) {
	Tapable.call(this);
	this.resolvers = resolvers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ContextModuleFactory.prototype.create" id="apidoc.element.webpack.ContextModuleFactory.prototype.create">
        function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
	var module = this;
	var context = data.context;
	var dependencies = data.dependencies;
	var dependency = dependencies[0];
	this.applyPluginsAsyncWaterfall("before-resolve", {
		context: context,
		request: dependency.request,
		recursive: dependency.recursive,
		regExp: dependency.regExp,
		async: dependency.async,
		dependencies: dependencies
	}, function(err, result) {
		if(err) return callback(err);

		// Ignored
		if(!result) return callback();

		var context = result.context;
		var request = result.request;
		var recursive = result.recursive;
		var regExp = result.regExp;
		var asyncContext = result.async;
		var dependencies = result.dependencies;

		var loaders, resource, loadersPrefix = "";
		var idx = request.lastIndexOf("!");
		if(idx &gt;= 0) {
			loaders = request.substr(0, idx + 1);
			for(var i = 0; i &lt; loaders.length &amp;&amp; loaders[i] === "!"; i++) {
				loadersPrefix += "!";
			}
			loaders = loaders.substr(i).replace(/!+$/, "").replace(/!!+/g, "!");
			if(loaders === "") loaders = [];
			else loaders = loaders.split("!");
			resource = request.substr(idx + 1);
		} else {
			loaders = [];
			resource = request;
		}

		var resolvers = module.resolvers;

		async.parallel([
			function(callback) {
				resolvers.context.resolve({}, context, resource, function(err, result) {
					if(err) return callback(err);
					callback(null, result);
				});
			},
			function(callback) {
				async.map(loaders, function(loader, callback) {
					resolvers.loader.resolve({}, context, loader, function(err, result) {
						if(err) return callback(err);
						callback(null, result);
					});
				}, callback);
			}
		], function(err, result) {
			if(err) return callback(err);

			module.applyPluginsAsyncWaterfall("after-resolve", {
				loaders: loadersPrefix + result[1].join("!") + (result[1].length &gt; 0 ? "!" : ""),
				resource: result[0],
				recursive: recursive,
				regExp: regExp,
				async: asyncContext,
				dependencies: dependencies,
				resolveDependencies: module.resolveDependencies.bind(module)
			}, function(err, result) {
				if(err) return callback(err);

				// Ignored
				if(!result) return callback();

				return callback(null, new ContextModule(result.resolveDependencies, result.resource, result.recursive, result.regExp, result
.loaders, result.async));
			});
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...





module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.<span class="apidocCodeKeywordSpan">create</span>(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ContextModuleFactory.prototype.resolveDependencies" id="apidoc.element.webpack.ContextModuleFactory.prototype.resolveDependencies">
        function <span class="apidocSignatureSpan">webpack.ContextModuleFactory.prototype.</span>resolveDependencies
        <span class="apidocSignatureSpan">(fs, resource, recursive, regExp, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveDependencies(fs, resource, recursive, regExp, callback) {
	if(!regExp || !resource)
		return callback(null, []);
	(function addDirectory(directory, callback) {
		fs.readdir(directory, function(err, files) {
			if(err) return callback(err);
			if(!files || files.length === 0) return callback(null, []);
			async.map(files.filter(function(p) {
				return p.indexOf(".") !== 0;
			}), function(seqment, callback) {

				var subResource = path.join(directory, seqment);

				fs.stat(subResource, function(err, stat) {
					if(err) return callback(err);

					if(stat.isDirectory()) {

						if(!recursive) return callback();
						addDirectory.call(this, subResource, callback);

					} else if(stat.isFile()) {

						var obj = {
							context: resource,
							request: "." + subResource.substr(resource.length).replace(/\\/g, "/")
						};

						this.applyPluginsAsyncWaterfall("alternatives", [obj], function(err, alternatives) {
							if(err) return callback(err);
							alternatives = alternatives.filter(function(obj) {
								return regExp.test(obj.request);
							}).map(function(obj) {
								var dep = new ContextElementDependency(obj.request);
								dep.optional = true;
								return dep;
							});
							callback(null, alternatives);
						});

					} else callback();

				}.bind(this));

			}.bind(this), function(err, result) {
				if(err) return callback(err);

				if(!result) return callback(null, []);

				callback(null, result.filter(function(i) {
					return !!i;
				}).reduce(function(a, i) {
					return a.concat(i);
				}, []));
			});
		}.bind(this));
	}.call(this, resource, callback));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.built = false;
		super.unbuild();
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.builtTime = new Date().getTime();
		this.<span class="apidocCodeKeywordSpan">resolveDependencies</span>(fs, this.context, this.recursive, this.regExp, (err, dependencies
) =&gt; {
			if(err) return callback(err);

			if(!dependencies) {
				this.dependencies = [];
				callback();
				return;
			}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.DelegatedModule" id="apidoc.module.webpack.DelegatedModule">module webpack.DelegatedModule</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.DelegatedModule.DelegatedModule" id="apidoc.element.webpack.DelegatedModule.DelegatedModule">
        function <span class="apidocSignatureSpan">webpack.</span>DelegatedModule
        <span class="apidocSignatureSpan">(sourceRequest, data, type, userRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DelegatedModule(sourceRequest, data, type, userRequest) {
	Module.call(this);
	this.sourceRequest = sourceRequest;
	this.request = data.id;
	this.meta = data.meta;
	this.type = type;
	this.userRequest = userRequest;
	this.built = false;
	this.delegateData = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.DelegatedModule.prototype" id="apidoc.module.webpack.DelegatedModule.prototype">module webpack.DelegatedModule.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.webpack.DelegatedModule.prototype.build" id="apidoc.element.webpack.DelegatedModule.prototype.build">
        function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>build
        <span class="apidocSignatureSpan">(options, compilation, resolver, fs, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function (options, compilation, resolver, fs, callback) {
	this.built = true;
	this.builtTime = new Date().getTime();
	this.usedExports = true;
	this.providedExports = this.delegateData.exports || true;
	this.dependencies.length = 0;
	this.addDependency(new DelegatedSourceDependency(this.sourceRequest));
	callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		if(module.building) return module.building.push(thisCallback);
		const building = module.building = [thisCallback];

		function callback(err) {
			module.building = undefined;
			building.forEach(cb =&gt; cb(err));
		}
		module.<span class="apidocCodeKeywordSpan">build</span>(this.options, this, this.resolvers.normal, this.inputFileSystem, (error
) =&gt; {
			const errors = module.errors;
			for(let indexError = 0; indexError &lt; errors.length; indexError++) {
				const err = errors[indexError];
				err.origin = origin;
				err.dependencies = dependencies;
				if(optional)
					this.warnings.push(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DelegatedModule.prototype.constructor" id="apidoc.element.webpack.DelegatedModule.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>constructor
        <span class="apidocSignatureSpan">(sourceRequest, data, type, userRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DelegatedModule(sourceRequest, data, type, userRequest) {
	Module.call(this);
	this.sourceRequest = sourceRequest;
	this.request = data.id;
	this.meta = data.meta;
	this.type = type;
	this.userRequest = userRequest;
	this.built = false;
	this.delegateData = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DelegatedModule.prototype.identifier" id="apidoc.element.webpack.DelegatedModule.prototype.identifier">
        function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>identifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identifier = function () {
	return "delegated " + JSON.stringify(this.request) + " from " + this.sourceRequest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			`Use equal casing. Compare these module identifiers:\n${modulesList}`;
		this.origin = this.module = sortedModules[0];
		Error.captureStackTrace(this, CaseSensitiveModulesWarning);
	}

	_sort(modules) {
		return modules.slice().sort((a, b) =&gt; {
			a = a.<span class="apidocCodeKeywordSpan">identifier</span>();
			b = b.identifier();
			/* istanbul ignore next */
			if(a &lt; b) return -1;
			/* istanbul ignore next */
			if(a &gt; b) return 1;
			/* istanbul ignore next */
			return 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DelegatedModule.prototype.needRebuild" id="apidoc.element.webpack.DelegatedModule.prototype.needRebuild">
        function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>needRebuild
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">needRebuild = function () {
	return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
		const cacheName = (cacheGroup || "m") + identifier;
		if(this.cache &amp;&amp; this.cache[cacheName]) {
			const cacheModule = this.cache[cacheName];

			let rebuild = true;
			if(!cacheModule.error &amp;&amp; cacheModule.cacheable &amp;&amp; this.fileTimestamps &amp;&amp; this.contextTimestamps
) {
				rebuild = cacheModule.<span class="apidocCodeKeywordSpan">needRebuild</span>(this.fileTimestamps, this.contextTimestamps);
			}

			if(!rebuild) {
				cacheModule.disconnect();
				this._modules[identifier] = cacheModule;
				this.modules.push(cacheModule);
				cacheModule.errors.forEach(err =&gt; this.errors.push(err), this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DelegatedModule.prototype.readableIdentifier" id="apidoc.element.webpack.DelegatedModule.prototype.readableIdentifier">
        function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>readableIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readableIdentifier = function () {
	return "delegated " + this.userRequest + " from " + this.sourceRequest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			source.add("\n\n/***/ })");
			return source;
		});

		moduleTemplate.plugin("package", function(moduleSource, module) {
			if(this.outputOptions.pathinfo) {
				const source = new ConcatSource();
				const req = module.<span class="apidocCodeKeywordSpan">readableIdentifier</span>(this.requestShortener);
				if(Array.isArray(module.providedExports))
					source.add("/* exports provided: " + module.providedExports.join(", ") + " */\n");
				else if(module.providedExports)
					source.add("/* unknown exports provided */\n");
				if(Array.isArray(module.usedExports))
					source.add("/* exports used: " + module.usedExports.join(", ") + " */\n");
				else if(module.usedExports)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DelegatedModule.prototype.size" id="apidoc.element.webpack.DelegatedModule.prototype.size">
        function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
	return 42;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		return size * multiplicator + overhead;
	}

	modulesSize() {
		let count = 0;
		for(let i = 0; i &lt; this.modules.length; i++) {
			count += this.modules[i].<span class="apidocCodeKeywordSpan">size</span>();
		}
		return count;
	}

	size(options) {
		return this.addMultiplierAndOverhead(this.modulesSize(), options);
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DelegatedModule.prototype.source" id="apidoc.element.webpack.DelegatedModule.prototype.source">
        function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>source
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">source = function () {
	var sourceModule = this.dependencies[0].module;
	var str;
	if(!sourceModule) {
		str = WebpackMissingModule.moduleCode(this.sourceRequest);
	} else {
		str = "module.exports = (__webpack_require__(" + sourceModule.id + "))";
		switch(this.type) {
			case "require":
				str += "(" + JSON.stringify(this.request) + ");";
				break;
			case "object":
				str += "[" + JSON.stringify(this.request) + "];";
				break;
		}
	}
	if(this.useSourceMap) {
		return new OriginalSource(str, this.identifier());
	} else {
		return new RawSource(str);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	constructor(sourceUrlComment, moduleFilenameTemplate) {
		this.sourceUrlComment = sourceUrlComment || "\n//# sourceURL=[url]";
		this.moduleFilenameTemplate = moduleFilenameTemplate || "webpack:///[resourcePath]?[loaders]";
	}

	apply(moduleTemplate) {
		moduleTemplate.plugin("module", (source, module) =&gt; {
			const content = source.<span class="apidocCodeKeywordSpan">source</span>();
			const str = ModuleFilenameHelpers.createFilename(module, this.moduleFilenameTemplate, moduleTemplate.requestShortener);
			const footer = ["\n",
				ModuleFilenameHelpers.createFooter(module, moduleTemplate.requestShortener),
				this.sourceUrlComment.replace(/\[url\]/g, encodeURI(str).replace(/%2F/g, "/").replace(/%20/g, "_").replace
(/%5E/g, "^").replace(/%5C/g, "\\").replace(/^\//, ""))
			].join("\n");
			return new RawSource(`eval(${JSON.stringify(content + footer)});`);
		});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DelegatedModule.prototype.unbuild" id="apidoc.element.webpack.DelegatedModule.prototype.unbuild">
        function <span class="apidocSignatureSpan">webpack.DelegatedModule.prototype.</span>unbuild
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbuild = function () {
	this.built = false;
	Module.prototype.unbuild.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				cacheModule.errors.forEach(err =&gt; this.errors.push(err), this);
				cacheModule.warnings.forEach(err =&gt; this.warnings.push(err), this);
				return cacheModule;
			} else {
				module.lastId = cacheModule.id;
			}
		}
		module.<span class="apidocCodeKeywordSpan">unbuild</span>();
		this._modules[identifier] = module;
		if(this.cache) {
			this.cache[cacheName] = module;
		}
		this.modules.push(module);
		return true;
	}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.DependenciesBlock" id="apidoc.module.webpack.DependenciesBlock">module webpack.DependenciesBlock</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.DependenciesBlock.DependenciesBlock" id="apidoc.element.webpack.DependenciesBlock.DependenciesBlock">
        function <span class="apidocSignatureSpan">webpack.</span>DependenciesBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DependenciesBlock() {
	this.dependencies = [];
	this.blocks = [];
	this.variables = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.DependenciesBlock.prototype" id="apidoc.module.webpack.DependenciesBlock.prototype">module webpack.DependenciesBlock.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.DependenciesBlock.prototype.addBlock" id="apidoc.element.webpack.DependenciesBlock.prototype.addBlock">
        function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>addBlock
        <span class="apidocSignatureSpan">(block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBlock = function (block) {
	this.blocks.push(block);
	block.parent = this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		otherChunk.chunks.length = 0;

		otherChunk.blocks.forEach(b =&gt; {
			b.chunks = b.chunks ? b.chunks.map(c =&gt; {
				return c === otherChunk ? this : c;
			}) : [this];
			b.chunkReason = reason;
			this.<span class="apidocCodeKeywordSpan">addBlock</span>(b);
		});
		otherChunk.blocks.length = 0;

		otherChunk.origins.forEach(origin =&gt; {
			this.origins.push(origin);
		});
		this.origins.forEach(origin =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DependenciesBlock.prototype.addDependency" id="apidoc.element.webpack.DependenciesBlock.prototype.addDependency">
        function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>addDependency
        <span class="apidocSignatureSpan">(dependency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDependency = function (dependency) {
	this.dependencies.push(dependency);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					const dep = new ConstDependency("require", expr.callee.range);
					dep.loc = expr.loc;
					if(parser.state.current.dependencies.length &gt; 1) {
						const last = parser.state.current.dependencies[parser.state.current.dependencies.length - 1];
						if(last.critical &amp;&amp; last.request === "." &amp;&amp; last.userRequest === "." &amp;&amp;
last.recursive)
							parser.state.current.dependencies.pop();
					}
					parser.state.current.<span class="apidocCodeKeywordSpan">addDependency</span>(dep);
					return true;
				});
			});

			params.normalModuleFactory.plugin("after-resolve", (data, done) =&gt; {
				// if this is a json file and there are no loaders active, we use the json-loader in order to avoid parse errors
				// @see https://github.com/webpack/webpack/issues/3363
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DependenciesBlock.prototype.addVariable" id="apidoc.element.webpack.DependenciesBlock.prototype.addVariable">
        function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>addVariable
        <span class="apidocSignatureSpan">(name, expression, dependencies)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addVariable = function (name, expression, dependencies) {
	for(var i = 0; i &lt; this.variables.length; i++) {
		var v = this.variables[i];
		if(v.name === name &amp;&amp; v.expression === expression) return;
	}
	this.variables.push(new DependenciesBlockVariable(name, expression, dependencies));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				});
				parser.plugin("evaluate Identifier __resourceQuery", function(expr) {
					if(!this.state.module) return;
					return ParserHelpers.evaluateToString(getQuery(this.state.module.resource))(expr);
				});
				parser.plugin("expression __resourceQuery", function() {
					if(!this.state.module) return;
					this.state.current.<span class="apidocCodeKeywordSpan">addVariable</span>("__resourceQuery", JSON.stringify(getQuery
(this.state.module.resource)));
					return true;
				});
			});
		});
	}
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DependenciesBlock.prototype.disconnect" id="apidoc.element.webpack.DependenciesBlock.prototype.disconnect">
        function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function () {
	function disconnect(i) {
		i.disconnect();
	}
	this.dependencies.forEach(disconnect);
	this.blocks.forEach(disconnect);
	this.variables.forEach(disconnect);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		hash.update(this.chunks &amp;&amp; this.chunks.map((chunk) =&gt; {
			return typeof chunk.id === "number" ? chunk.id : "";
		}).join(",") || "");
		super.updateHash(hash);
	}
	disconnect() {
		this.chunks = null;
		super.<span class="apidocCodeKeywordSpan">disconnect</span>();
	}
	unseal() {
		this.chunks = null;
		super.unseal();
	}
	sortItems() {
		super.sortItems();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DependenciesBlock.prototype.hasDependencies" id="apidoc.element.webpack.DependenciesBlock.prototype.hasDependencies">
        function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>hasDependencies
        <span class="apidocSignatureSpan">(filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasDependencies = function (filter) {
	if(filter) {
		if(this.dependencies.some(filter)) return true;
	} else {
		if(this.dependencies.length &gt; 0) return true;
	}

	return this.blocks.concat(this.variables).some(function(item) {
		return item.hasDependencies(filter);
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if(filter) {
		if(this.dependencies.some(filter)) return true;
	} else {
		if(this.dependencies.length &gt; 0) return true;
	}

	return this.blocks.concat(this.variables).some(function(item) {
		return item.<span class="apidocCodeKeywordSpan">hasDependencies</span>(filter);
	});
};

DependenciesBlock.prototype.sortItems = function() {
	this.blocks.forEach(function(block) {
		block.sortItems();
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DependenciesBlock.prototype.sortItems" id="apidoc.element.webpack.DependenciesBlock.prototype.sortItems">
        function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>sortItems
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sortItems = function () {
	this.blocks.forEach(function(block) {
		block.sortItems();
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		super.disconnect();
	}
	unseal() {
		this.chunks = null;
		super.unseal();
	}
	sortItems() {
		super.<span class="apidocCodeKeywordSpan">sortItems</span>();
		if(this.chunks) {
			this.chunks.sort((a, b) =&gt; {
				let i = 0;
				while(true) { // eslint-disable-line no-constant-condition
					if(!a.modules[i] &amp;&amp; !b.modules[i]) return 0;
					if(!a.modules[i]) return -1;
					if(!b.modules[i]) return 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DependenciesBlock.prototype.unseal" id="apidoc.element.webpack.DependenciesBlock.prototype.unseal">
        function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>unseal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unseal = function () {
	function unseal(i) {
		i.unseal();
	}
	this.blocks.forEach(unseal);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}
	disconnect() {
		this.chunks = null;
		super.disconnect();
	}
	unseal() {
		this.chunks = null;
		super.<span class="apidocCodeKeywordSpan">unseal</span>();
	}
	sortItems() {
		super.sortItems();
		if(this.chunks) {
			this.chunks.sort((a, b) =&gt; {
				let i = 0;
				while(true) { // eslint-disable-line no-constant-condition
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DependenciesBlock.prototype.updateHash" id="apidoc.element.webpack.DependenciesBlock.prototype.updateHash">
        function <span class="apidocSignatureSpan">webpack.DependenciesBlock.prototype.</span>updateHash
        <span class="apidocSignatureSpan">(hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateHash = function (hash) {
	this.dependencies.forEach(function(d) {
		d.updateHash(hash);
	});
	this.blocks.forEach(function(b) {
		b.updateHash(hash);
	});
	this.variables.forEach(function(v) {
		v.updateHash(hash);
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		throw new Error("`chunk` was been renamed to `chunks` and is now an array");
	}
	updateHash(hash) {
		hash.update(this.chunkName || "");
		hash.update(this.chunks &amp;&amp; this.chunks.map((chunk) =&gt; {
			return typeof chunk.id === "number" ? chunk.id : "";
		}).join(",") || "");
		super.<span class="apidocCodeKeywordSpan">updateHash</span>(hash);
	}
	disconnect() {
		this.chunks = null;
		super.disconnect();
	}
	unseal() {
		this.chunks = null;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Dependency" id="apidoc.module.webpack.Dependency">module webpack.Dependency</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Dependency.Dependency" id="apidoc.element.webpack.Dependency.Dependency">
        function <span class="apidocSignatureSpan">webpack.</span>Dependency
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Dependency {
	constructor() {
		this.module = null;
	}

	isEqualResource() {
		return false;
	}

	// Returns the referenced module and export
	getReference() {
		if(!this.module) return null;
		return {
			module: this.module,
			importedNames: true, // true: full object, false: only sideeffects/no export, array of strings: the exports with this names
		};
	}

	// Returns the exported names
	getExports() {
		return null;
	}

	getWarnings() {
		return null;
	}

	getErrors() {
		return null;
	}

	updateHash(hash) {
		hash.update((this.module &amp;&amp; this.module.id) + "");
	}

	disconnect() {
		this.module = null;
	}

	compare(a, b) {
		return compareLocations(a.loc, b.loc);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Dependency.compare" id="apidoc.element.webpack.Dependency.compare">
        function <span class="apidocSignatureSpan">webpack.Dependency.</span>compare
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(a, b) =&gt; compareLocations(a.loc, b.loc)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.DynamicEntryPlugin" id="apidoc.module.webpack.DynamicEntryPlugin">module webpack.DynamicEntryPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.DynamicEntryPlugin.DynamicEntryPlugin" id="apidoc.element.webpack.DynamicEntryPlugin.DynamicEntryPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>DynamicEntryPlugin
        <span class="apidocSignatureSpan">(context, entry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DynamicEntryPlugin {
	constructor(context, entry) {
		this.context = context;
		this.entry = entry;
	}

	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			const multiModuleFactory = new MultiModuleFactory();
			const normalModuleFactory = params.normalModuleFactory;

			compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);
			compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
		});

		compiler.plugin("make", (compilation, callback) =&gt; {
			const addEntry = (entry, name) =&gt; {
				const dep = DynamicEntryPlugin.createDependency(entry, name);
				return new Promise((resolve, reject) =&gt; {
					compilation.addEntry(this.context, dep, name, (err) =&gt; {
						if(err) return reject(err);
						resolve();
					});
				});
			};

			Promise.resolve(this.entry()).then((entry) =&gt; {
				if(typeof entry === "string" || Array.isArray(entry)) {
					addEntry(entry, "main").then(() =&gt; callback(), callback);
				} else if(typeof entry === "object") {
					Promise.all(Object.keys(entry).map((name) =&gt; {
						return addEntry(entry[name], name);
					})).then(() =&gt; callback(), callback);
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.DynamicEntryPlugin.createDependency" id="apidoc.element.webpack.DynamicEntryPlugin.createDependency">
        function <span class="apidocSignatureSpan">webpack.DynamicEntryPlugin.</span>createDependency
        <span class="apidocSignatureSpan">(entry, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDependency = function (entry, name) {
	if(Array.isArray(entry))
		return MultiEntryPlugin.createDependency(entry, name);
	else
		return SingleEntryPlugin.createDependency(entry, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

			compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);
			compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
		});

		compiler.plugin("make", (compilation, callback) =&gt; {
			const addEntry = (entry, name) =&gt; {
				const dep = DynamicEntryPlugin.<span class="apidocCodeKeywordSpan">createDependency</span>(entry, name);
				return new Promise((resolve, reject) =&gt; {
					compilation.addEntry(this.context, dep, name, (err) =&gt; {
						if(err) return reject(err);
						resolve();
					});
				});
			};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.EntryModuleNotFoundError" id="apidoc.module.webpack.EntryModuleNotFoundError">module webpack.EntryModuleNotFoundError</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.EntryModuleNotFoundError.EntryModuleNotFoundError" id="apidoc.element.webpack.EntryModuleNotFoundError.EntryModuleNotFoundError">
        function <span class="apidocSignatureSpan">webpack.</span>EntryModuleNotFoundError
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EntryModuleNotFoundError(err) {
	Error.call(this);
	this.name = "EntryModuleNotFoundError";
	this.message = "Entry module not found: " + err;
	this.details = err.details;
	this.error = err;
	Error.captureStackTrace(this, EntryModuleNotFoundError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.EntryModuleNotFoundError.prototype" id="apidoc.module.webpack.EntryModuleNotFoundError.prototype">module webpack.EntryModuleNotFoundError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.EntryModuleNotFoundError.prototype.constructor" id="apidoc.element.webpack.EntryModuleNotFoundError.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.EntryModuleNotFoundError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EntryModuleNotFoundError(err) {
	Error.call(this);
	this.name = "EntryModuleNotFoundError";
	this.message = "Entry module not found: " + err;
	this.details = err.details;
	this.error = err;
	Error.captureStackTrace(this, EntryModuleNotFoundError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ErrorHelpers" id="apidoc.module.webpack.ErrorHelpers">module webpack.ErrorHelpers</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ErrorHelpers.cleanUp" id="apidoc.element.webpack.ErrorHelpers.cleanUp">
        function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cleanUp
        <span class="apidocSignatureSpan">(stack, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(stack, message) =&gt; {
	stack = exports.cutOffLoaderExecution(stack);
	stack = exports.cutOffMessage(stack, message);
	return stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ErrorHelpers.cutOffLoaderExecution" id="apidoc.element.webpack.ErrorHelpers.cutOffLoaderExecution">
        function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cutOffLoaderExecution
        <span class="apidocSignatureSpan">(stack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(stack) =&gt; {
	stack = stack.split("\n");
	for(let i = 0; i &lt; stack.length; i++)
		if(stack[i].indexOf(loaderFlag) &gt;= 0)
			stack.length = i;
	return stack.join("\n");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ErrorHelpers.cutOffMessage" id="apidoc.element.webpack.ErrorHelpers.cutOffMessage">
        function <span class="apidocSignatureSpan">webpack.ErrorHelpers.</span>cutOffMessage
        <span class="apidocSignatureSpan">(stack, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(stack, message) =&gt; {
	const nextLine = stack.indexOf("\n");
	if(nextLine === -1) {
		return stack === message ? "" : stack;
	} else {
		const firstLine = stack.substr(0, nextLine);
		return firstLine === message ? stack.substr(nextLine + 1) : stack;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ExternalModuleFactoryPlugin" id="apidoc.module.webpack.ExternalModuleFactoryPlugin">module webpack.ExternalModuleFactoryPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ExternalModuleFactoryPlugin.ExternalModuleFactoryPlugin" id="apidoc.element.webpack.ExternalModuleFactoryPlugin.ExternalModuleFactoryPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>ExternalModuleFactoryPlugin
        <span class="apidocSignatureSpan">(type, externals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ExternalModuleFactoryPlugin(type, externals) {
	this.type = type;
	this.externals = externals;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ExternalModuleFactoryPlugin.prototype" id="apidoc.module.webpack.ExternalModuleFactoryPlugin.prototype">module webpack.ExternalModuleFactoryPlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ExternalModuleFactoryPlugin.prototype.apply" id="apidoc.element.webpack.ExternalModuleFactoryPlugin.prototype.apply">
        function <span class="apidocSignatureSpan">webpack.ExternalModuleFactoryPlugin.prototype.</span>apply
        <span class="apidocSignatureSpan">(normalModuleFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (normalModuleFactory) {
	var globalType = this.type;
	normalModuleFactory.plugin("factory", function(factory) {
		return function(data, callback) {
			var context = data.context;
			var dependency = data.dependencies[0];

			function handleExternal(value, type, callback) {
				if(typeof type === "function") {
					callback = type;
					type = undefined;
				}
				if(value === false) return factory(data, callback);
				if(value === true) value = dependency.request;
				if(typeof type === "undefined" &amp;&amp; /^[a-z0-9]+ /.test(value)) {
					var idx = value.indexOf(" ");
					type = value.substr(0, idx);
					value = value.substr(idx + 1);
				}
				callback(null, new ExternalModule(value, type || globalType));
				return true;
			}
			(function handleExternals(externals, callback) {
				if(typeof externals === "string") {
					if(externals === dependency.request) {
						return handleExternal(dependency.request, callback);
					}
				} else if(Array.isArray(externals)) {
					var i = 0;
					(function next() {
						var handleExternalsAndCallback = function handleExternalsAndCallback(err, module) {
							if(err) return callback(err);
							if(!module) {
								if(async) {
									async = false;
									return;
								}
								return next();
							}
							callback(null, module);
						};

						do {
							var async = true;
							if(i &gt;= externals.length) return callback();
							handleExternals(externals[i++], handleExternalsAndCallback);
						} while (!async); // eslint-disable-line keyword-spacing
						async = false;
					}());
					return;
				} else if(externals instanceof RegExp) {
					if(externals.test(dependency.request)) {
						return handleExternal(dependency.request, callback);
					}
				} else if(typeof externals === "function") {
					externals.call(null, context, dependency.request, function(err, value, type) {
						if(err) return callback(err);
						if(typeof value !== "undefined") {
							handleExternal(value, type, callback);
						} else {
							callback();
						}
					});
					return;
				} else if(typeof externals === "object" &amp;&amp; Object.prototype.hasOwnProperty.call(externals, dependency.request)) {
					return handleExternal(externals[dependency.request], callback);
				}
				callback();
			}(this.externals, function(err, module) {
				if(err) return callback(err);
				if(!module) return handleExternal(false, callback);
				return callback(null, module);
			}));
		}.bind(this);
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.<span class="apidocCodeKeywordSpan">apply</span>(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.FlagDependencyUsagePlugin" id="apidoc.module.webpack.FlagDependencyUsagePlugin">module webpack.FlagDependencyUsagePlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.FlagDependencyUsagePlugin.FlagDependencyUsagePlugin" id="apidoc.element.webpack.FlagDependencyUsagePlugin.FlagDependencyUsagePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>FlagDependencyUsagePlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FlagDependencyUsagePlugin() {

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.FlagDependencyUsagePlugin.prototype" id="apidoc.module.webpack.FlagDependencyUsagePlugin.prototype">module webpack.FlagDependencyUsagePlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.FlagDependencyUsagePlugin.prototype.apply" id="apidoc.element.webpack.FlagDependencyUsagePlugin.prototype.apply">
        function <span class="apidocSignatureSpan">webpack.FlagDependencyUsagePlugin.prototype.</span>apply
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (compiler) {
	compiler.plugin("compilation", function(compilation) {
		compilation.plugin("optimize-modules-advanced", function(modules) {

			modules.forEach(function(module) {
				module.used = false;
			});

			var queue = [];
			compilation.chunks.forEach(function(chunk) {
				if(chunk.entryModule) {
					processModule(chunk.entryModule, true);
				}
			});

			while(queue.length) {
				var queueItem = queue.pop();
				processDependenciesBlock(queueItem[0], queueItem[1]);
			}

			function processModule(module, usedExports) {
				module.used = true;
				if(module.usedExports === true)
					return;
				else if(usedExports === true)
					module.usedExports = true;
				else if(Array.isArray(usedExports)) {
					var old = module.usedExports ? module.usedExports.length : -1;
					module.usedExports = addToSet(module.usedExports || [], usedExports);
					if(module.usedExports.length === old)
						return;
				} else if(Array.isArray(module.usedExports))
					return;
				else
					module.usedExports = false;

				queue.push([module, module.usedExports]);
			}

			function processDependenciesBlock(depBlock, usedExports) {
				depBlock.dependencies.forEach(function(dep) {
					processDependency(dep, usedExports);
				});
				depBlock.variables.forEach(function(variable) {
					variable.dependencies.forEach(function(dep) {
						processDependency(dep, usedExports);
					});
				});
				depBlock.blocks.forEach(function(block) {
					queue.push([block, usedExports]);
				});
			}

			function processDependency(dep, usedExports) {
				var reference = dep.getReference &amp;&amp; dep.getReference();
				if(!reference) return;
				var module = reference.module;
				var importedNames = reference.importedNames;
				var oldUsed = module.used;
				var oldUsedExports = module.usedExports;
				if(!oldUsed || (importedNames &amp;&amp; (!oldUsedExports || !isSubset(oldUsedExports, importedNames)))) {
					processModule(module, importedNames);
				}
			}

		});

		function addToSet(a, b) {
			b.forEach(function(item) {
				if(a.indexOf(item) &lt; 0)
					a.push(item);
			});
			return a;
		}

		function isSubset(biggerSet, subset) {
			if(biggerSet === true) return true;
			if(subset === true) return false;
			return subset.every(function(item) {
				return biggerSet.indexOf(item) &gt;= 0;
			});
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.<span class="apidocCodeKeywordSpan">apply</span>(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.HotModuleReplacementPlugin" id="apidoc.module.webpack.HotModuleReplacementPlugin">module webpack.HotModuleReplacementPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.HotModuleReplacementPlugin.HotModuleReplacementPlugin" id="apidoc.element.webpack.HotModuleReplacementPlugin.HotModuleReplacementPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>HotModuleReplacementPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HotModuleReplacementPlugin(options) {
	options = options || {};
	this.multiStep = options.multiStep;
	this.fullBuildTimeout = options.fullBuildTimeout || 200;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.HotModuleReplacementPlugin.prototype" id="apidoc.module.webpack.HotModuleReplacementPlugin.prototype">module webpack.HotModuleReplacementPlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.HotModuleReplacementPlugin.prototype.apply" id="apidoc.element.webpack.HotModuleReplacementPlugin.prototype.apply">
        function <span class="apidocSignatureSpan">webpack.HotModuleReplacementPlugin.prototype.</span>apply
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (compiler) {
	var multiStep = this.multiStep;
	var fullBuildTimeout = this.fullBuildTimeout;
	var hotUpdateChunkFilename = compiler.options.output.hotUpdateChunkFilename;
	var hotUpdateMainFilename = compiler.options.output.hotUpdateMainFilename;
	compiler.plugin("compilation", function(compilation, params) {
		var hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate;
		if(!hotUpdateChunkTemplate) return;

		var normalModuleFactory = params.normalModuleFactory;

		compilation.dependencyFactories.set(ConstDependency, new NullFactory());
		compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

		compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory);
		compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template());

		compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory);
		compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template());

		compilation.plugin("record", function(compilation, records) {
			if(records.hash === this.hash) return;
			records.hash = compilation.hash;
			records.moduleHashs = {};
			this.modules.forEach(function(module) {
				var identifier = module.identifier();
				var hash = require("crypto").createHash("md5");
				module.updateHash(hash);
				records.moduleHashs[identifier] = hash.digest("hex");
			});
			records.chunkHashs = {};
			this.chunks.forEach(function(chunk) {
				records.chunkHashs[chunk.id] = chunk.hash;
			});
			records.chunkModuleIds = {};
			this.chunks.forEach(function(chunk) {
				records.chunkModuleIds[chunk.id] = chunk.modules.map(function(m) {
					return m.id;
				});
			});
		});
		var initialPass = false;
		var recompilation = false;
		compilation.plugin("after-hash", function() {
			var records = this.records;
			if(!records) {
				initialPass = true;
				return;
			}
			if(!records.hash)
				initialPass = true;
			var preHash = records.preHash || "x";
			var prepreHash = records.prepreHash || "x";
			if(preHash === this.hash) {
				recompilation = true;
				this.modifyHash(prepreHash);
				return;
			}
			records.prepreHash = records.hash || "x";
			records.preHash = this.hash;
			this.modifyHash(records.prepreHash);
		});
		compilation.plugin("should-generate-chunk-assets", function() {
			if(multiStep &amp;&amp; !recompilation &amp;&amp; !initialPass)
				return false;
		});
		compilation.plugin("need-additional-pass", function() {
			if(multiStep &amp;&amp; !recompilation &amp;&amp; !initialPass)
				return true;
		});
		compiler.plugin("additional-pass", function(callback) {
			if(multiStep)
				return setTimeout(callback, fullBuildTimeout);
			return callback();
		});
		compilation.plugin("additional-chunk-assets", function() {
			var records = this.records;
			if(records.hash === this.hash) return;
			if(!records.moduleHashs || !records.chunkHashs || !records.chunkModuleIds) return;
			this.modules.forEach(function(module) {
				var identifier = module.identifier();
				var hash = require("crypto").createHash("md5");
				module.updateHash(hash);
				hash = hash.digest("hex");
				module.hotUpdate = records.moduleHashs[identifier] !== hash;
			});
			var hotUpdateMainContent = {
				h: this.hash,
				c: {}
			};
			Object.keys(records.chunkHashs).forEach(function(chunkId) {
				chunkId = +chunkId;
				var currentChunk = this.chunks.filter(function(chunk) {
					return chunk.id === chunkId;
				})[0];
				if(currentChunk) {
					var newModules = currentChunk.modules.filter(function(module) {
						return module.hotUpdate;
					});
					var allModules = {};
					currentChunk.modules.forEach(function(module) {
						allModules[module.id] = true;
					});
					var removedModules = records.chunkModuleIds[chunkId].filter(function(id) {
						return !allModules[id];
					});
					if(newModules.length &gt; 0 || removedModules.length &gt; 0) {
						var source = hotUpdateChunkTemplate.render(chunkId, newModules, r ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.<span class="apidocCodeKeywordSpan">apply</span>(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.JsonpChunkTemplatePlugin" id="apidoc.module.webpack.JsonpChunkTemplatePlugin">module webpack.JsonpChunkTemplatePlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.JsonpChunkTemplatePlugin.JsonpChunkTemplatePlugin" id="apidoc.element.webpack.JsonpChunkTemplatePlugin.JsonpChunkTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>JsonpChunkTemplatePlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JsonpChunkTemplatePlugin() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.JsonpChunkTemplatePlugin.prototype" id="apidoc.module.webpack.JsonpChunkTemplatePlugin.prototype">module webpack.JsonpChunkTemplatePlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.JsonpChunkTemplatePlugin.prototype.apply" id="apidoc.element.webpack.JsonpChunkTemplatePlugin.prototype.apply">
        function <span class="apidocSignatureSpan">webpack.JsonpChunkTemplatePlugin.prototype.</span>apply
        <span class="apidocSignatureSpan">(chunkTemplate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (chunkTemplate) {
	chunkTemplate.plugin("render", function(modules, chunk) {
		var jsonpFunction = this.outputOptions.jsonpFunction;
		var source = new ConcatSource();
		source.add(jsonpFunction + "(" + JSON.stringify(chunk.ids) + ",");
		source.add(modules);
		var entries = [chunk.entryModule].filter(Boolean).map(function(m) {
			return m.id;
		});
		if(entries.length &gt; 0) {
			source.add("," + JSON.stringify(entries));
		}
		source.add(")");
		return source;
	});
	chunkTemplate.plugin("hash", function(hash) {
		hash.update("JsonpChunkTemplatePlugin");
		hash.update("3");
		hash.update(this.outputOptions.jsonpFunction + "");
		hash.update(this.outputOptions.library + "");
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.<span class="apidocCodeKeywordSpan">apply</span>(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.JsonpMainTemplatePlugin" id="apidoc.module.webpack.JsonpMainTemplatePlugin">module webpack.JsonpMainTemplatePlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.JsonpMainTemplatePlugin.JsonpMainTemplatePlugin" id="apidoc.element.webpack.JsonpMainTemplatePlugin.JsonpMainTemplatePlugin">
        function <span class="apidocSignatureSpan">webpack.</span>JsonpMainTemplatePlugin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JsonpMainTemplatePlugin() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.JsonpMainTemplatePlugin.prototype" id="apidoc.module.webpack.JsonpMainTemplatePlugin.prototype">module webpack.JsonpMainTemplatePlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.JsonpMainTemplatePlugin.prototype.apply" id="apidoc.element.webpack.JsonpMainTemplatePlugin.prototype.apply">
        function <span class="apidocSignatureSpan">webpack.JsonpMainTemplatePlugin.prototype.</span>apply
        <span class="apidocSignatureSpan">(mainTemplate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (mainTemplate) {
	mainTemplate.plugin("local-vars", function(source, chunk) {
		if(chunk.chunks.length &gt; 0) {
			return this.asString([
				source,
				"",
				"// objects to store loaded and loading chunks",
				"var installedChunks = {",
				this.indent(
					chunk.ids.map(function(id) {
						return id + ": 0";
					}).join(",\n")
				),
				"};"
			]);
		}
		return source;
	});
	mainTemplate.plugin("jsonp-script", function(_, chunk, hash) {
		var chunkFilename = this.outputOptions.chunkFilename;
		var chunkMaps = chunk.getChunkMaps();
		var crossOriginLoading = this.outputOptions.crossOriginLoading;
		var chunkLoadTimeout = this.outputOptions.chunkLoadTimeout || 120000;
		return this.asString([
			"var script = document.createElement('script');",
			"script.type = 'text/javascript';",
			"script.charset = 'utf-8';",
			"script.async = true;",
			"script.timeout = " + chunkLoadTimeout + ";",
			crossOriginLoading ? "script.crossOrigin = '" + crossOriginLoading + "';" : "",
			"if (" + this.requireFn + ".nc) {",
			this.indent("script.setAttribute(\"nonce\", " + this.requireFn + ".nc);"),
			"}",
			"script.src = " + this.requireFn + ".p + " +
			this.applyPluginsWaterfall("asset-path", JSON.stringify(chunkFilename), {
				hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
				hashWithLength: function(length) {
					return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
				}.bind(this),
				chunk: {
					id: "\" + chunkId + \"",
					hash: "\" + " + JSON.stringify(chunkMaps.hash) + "[chunkId] + \"",
					hashWithLength: function(length) {
						var shortChunkHashMap = {};
						Object.keys(chunkMaps.hash).forEach(function(chunkId) {
							if(typeof chunkMaps.hash[chunkId] === "string")
								shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
						});
						return "\" + " + JSON.stringify(shortChunkHashMap) + "[chunkId] + \"";
					},
					name: "\" + (" + JSON.stringify(chunkMaps.name) + "[chunkId]||chunkId) + \""
				}
			}) + ";",
			"var timeout = setTimeout(onScriptComplete, " + chunkLoadTimeout + ");",
			"script.onerror = script.onload = onScriptComplete;",
			"function onScriptComplete() {",
			this.indent([
				"// avoid mem leaks in IE.",
				"script.onerror = script.onload = null;",
				"clearTimeout(timeout);",
				"var chunk = installedChunks[chunkId];",
				"if(chunk !== 0) {",
				this.indent([
					"if(chunk) chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));",
					"installedChunks[chunkId] = undefined;"
				]),
				"}"
			]),
			"};",
		]);
	});
	mainTemplate.plugin("require-ensure", function(_, chunk, hash) {
		return this.asString([
			"if(installedChunks[chunkId] === 0)",
			this.indent([
				"return Promise.resolve();"
			]),
			"",
			"// a Promise means \"currently loading\".",
			"if(installedChunks[chunkId]) {",
			this.indent([
				"return installedChunks[chunkId][2];"
			]),
			"}",
			"",
			"// setup Promise in chunk cache",
			"var promise = new Promise(function(resolve, reject) {",
			this.indent([
				"installedChunks[chunkId] = [resolve, reject];"
			]),
			"});",
			"installedChunks[chunkId][2] = promise;",
			"",
			"// start chunk loading",
			"var head = document.getElementsByTagName('head')[0];",
			this.applyPluginsWaterfall("jsonp-script", "", chunk, hash),
			"head.appendChild(script);",
			"",
			"return promise;"
		]);
	});
	mainTemplate.plugin("require-extensions", function(source, chunk) {
		if(chunk.chunks.length === 0) return source;
		return this.asString([
			source,
			"",
			"// on error function for async loading",
			this.requireFn + ".oe = function(err) { console.error(err); throw err; };"
		]);
	});
	mainTemplate.plugin("bootstrap", function(source, chunk, hash) {
		if(chunk.chunks.length &gt; 0) {
			var jsonpFunction = this.outputOptions.jsonpFunction;
			return this.asString([
				source,
				"",
				"// install a JSONP callback for chunk loading",
				"var parentJsonpFunction = win ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.<span class="apidocCodeKeywordSpan">apply</span>(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.LibManifestPlugin" id="apidoc.module.webpack.LibManifestPlugin">module webpack.LibManifestPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.LibManifestPlugin.LibManifestPlugin" id="apidoc.element.webpack.LibManifestPlugin.LibManifestPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>LibManifestPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LibManifestPlugin(options) {
	this.options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.LibManifestPlugin.prototype" id="apidoc.module.webpack.LibManifestPlugin.prototype">module webpack.LibManifestPlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.LibManifestPlugin.prototype.apply" id="apidoc.element.webpack.LibManifestPlugin.prototype.apply">
        function <span class="apidocSignatureSpan">webpack.LibManifestPlugin.prototype.</span>apply
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (compiler) {
	compiler.plugin("emit", function(compilation, callback) {
		async.forEach(compilation.chunks, function(chunk, callback) {
			if(!chunk.isInitial()) {
				callback();
				return;
			}
			var targetPath = compilation.getPath(this.options.path, {
				hash: compilation.hash,
				chunk: chunk
			});
			var name = this.options.name &amp;&amp; compilation.getPath(this.options.name, {
				hash: compilation.hash,
				chunk: chunk
			});
			var manifest = {
				name: name,
				type: this.options.type,
				content: chunk.modules.reduce(function(obj, module) {
					if(module.libIdent) {
						var ident = module.libIdent({
							context: this.options.context || compiler.options.context
						});
						if(ident) {
							obj[ident] = {
								id: module.id,
								meta: module.meta,
								exports: Array.isArray(module.providedExports) ? module.providedExports : undefined
							};
						}
					}
					return obj;
				}.bind(this), {})
			};
			var content = new Buffer(JSON.stringify(manifest, null, 2), "utf8"); //eslint-disable-line
			compiler.outputFileSystem.mkdirp(path.dirname(targetPath), function(err) {
				if(err) return callback(err);
				compiler.outputFileSystem.writeFile(targetPath, content, callback);
			});
		}.bind(this), callback);
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.<span class="apidocCodeKeywordSpan">apply</span>(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.MemoryOutputFileSystem" id="apidoc.module.webpack.MemoryOutputFileSystem">module webpack.MemoryOutputFileSystem</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.MemoryOutputFileSystem" id="apidoc.element.webpack.MemoryOutputFileSystem.MemoryOutputFileSystem">
        function <span class="apidocSignatureSpan">webpack.</span>MemoryOutputFileSystem
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MemoryFileSystem(data) {
	this.data = data || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.MemoryOutputFileSystem.prototype" id="apidoc.module.webpack.MemoryOutputFileSystem.prototype">module webpack.MemoryOutputFileSystem.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype._remove" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype._remove">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>_remove
        <span class="apidocSignatureSpan">(_path, name, testFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_remove = function (_path, name, testFn) {
	var path = pathToArray(_path);
	if(path.length === 0) {
		throw new MemoryFileSystemError(errors.code.EPERM, _path);
	}
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	}
	if(!testFn(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	delete current[path[i]];
	return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.createReadStream" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.createReadStream">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>createReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createReadStream = function (path, options) {
	var stream = new ReadableStream();
	var done = false;
	var data;
	try {
		data = this.readFileSync(path);
	} catch (e) {
		stream._read = function() {
			if (done) {
				return;
			}
			done = true;
			this.emit('error', e);
			this.push(null);
		};
		return stream;
	}
	options = options || { };
	options.start = options.start || 0;
	options.end = options.end || data.length;
	stream._read = function() {
		if (done) {
			return;
		}
		done = true;
		this.push(data.slice(options.start, options.end));
		this.push(null);
	};
	return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.createWriteStream" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.createWriteStream">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>createWriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWriteStream = function (path, options) {
	var stream = new WritableStream(), self = this;
	try {
		// Zero the file and make sure it is writable
		this.writeFileSync(path, new Buffer(0));
	} catch(e) {
		// This or setImmediate?
		stream.once('prefinish', function() {
			stream.emit('error', e);
		});
		return stream;
	}
	var bl = [ ], len = 0;
	stream._write = function(chunk, encoding, callback) {
		bl.push(chunk);
		len += chunk.length;
		self.writeFile(path, Buffer.concat(bl, len), callback);
	}
	return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.exists" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.exists">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>exists
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (path, callback) {
	return callback(this.existsSync(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.existsSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.existsSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>existsSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existsSync = function (_path) {
	return !!this.meta(_path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.join" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.join">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>join
        <span class="apidocSignatureSpan">(path, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function join(path, request) {
	if(!request) return normalize(path);
	if(absoluteWinRegExp.test(request)) return normalize(request.replace(/\//g, "\\"));
	if(absoluteNixRegExp.test(request)) return normalize(request);
	if(path == "/") return normalize(path + request);
	if(absoluteWinRegExp.test(path)) return normalize(path.replace(/\//g, "\\") + "\\" + request.replace(/\//g, "\\"));
	if(absoluteNixRegExp.test(path)) return normalize(path + "/" + request);
	return normalize(path + "/" + request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		compilation.templatesPlugin("render-with-entry", (source, chunk, hash) =&gt; {
			const externals = chunk.modules.filter((m) =&gt; m.external);
			const externalsDepsArray = JSON.stringify(externals.map((m) =&gt;
				typeof m.request === "object" ? m.request.amd : m.request
			));
			const externalsArguments = externals.map((m) =&gt;
				Template.toIdentifier(`__WEBPACK_EXTERNAL_MODULE_${m.id}__`)
			).<span class="apidocCodeKeywordSpan">join</span>(", ");

			if(this.name) {
				const name = mainTemplate.applyPluginsWaterfall("asset-path", this.name, {
					hash,
					chunk
				});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.meta" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.meta">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>meta
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">meta = function (_path) {
	var path = pathToArray(_path);
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			return;
		current = current[path[i]];
	}
	return current[path[i]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdir" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdir">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdir
        <span class="apidocSignatureSpan">(path, optArg, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdir = function (path, optArg, callback) {
		if(!callback) {
			callback = optArg;
			optArg = undefined;
		}
		try {
			var result = this[fn + "Sync"](path, optArg);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirSync = function (_path) {
	var path = pathToArray(_path);
	if(path.length === 0) return;
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	}
	if(isDir(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.EEXIST, _path);
	else if(isFile(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);
	current[path[i]] = {"":true};
	return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirp" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirp">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirp
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirp = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirpSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.mkdirpSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>mkdirpSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirpSync = function (_path) {
	var path = pathToArray(_path);
	if(path.length === 0) return;
	var current = this.data;
	for(var i = 0; i &lt; path.length; i++) {
		if(isFile(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);
		else if(!isDir(current[path[i]]))
			current[path[i]] = {"":true};
		current = current[path[i]];
	}
	return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.normalize" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.normalize">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>normalize
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalize(path) {
	var parts = path.split(/(\\+|\/+)/);
	if(parts.length === 1)
		return path;
	var result = [];
	var absolutePathStart = 0;
	for(var i = 0, sep = false; i &lt; parts.length; i++, sep = !sep) {
		var part = parts[i];
		if(i === 0 &amp;&amp; /^([A-Z]:)?$/i.test(part)) {
			result.push(part);
			absolutePathStart = 2;
		} else if(sep) {
			result.push(part[0]);
		} else if(part === "..") {
			switch(result.length) {
				case 0:
					// i. e. ".." =&gt; ".."
					// i. e. "../a/b/c" =&gt; "../a/b/c"
					result.push(part);
					break;
				case 2:
					// i. e. "a/.." =&gt; ""
					// i. e. "/.." =&gt; "/"
					// i. e. "C:\.." =&gt; "C:\"
					// i. e. "a/../b/c" =&gt; "b/c"
					// i. e. "/../b/c" =&gt; "/b/c"
					// i. e. "C:\..\a\b\c" =&gt; "C:\a\b\c"
					i++;
					sep = !sep;
					result.length = absolutePathStart;
					break;
				case 4:
					// i. e. "a/b/.." =&gt; "a"
					// i. e. "/a/.." =&gt; "/"
					// i. e. "C:\a\.." =&gt; "C:\"
					// i. e. "/a/../b/c" =&gt; "/b/c"
					if(absolutePathStart === 0) {
						result.length -= 3;
					} else {
						i++;
						sep = !sep;
						result.length = 2;
					}
					break;
				default:
					// i. e. "/a/b/.." =&gt; "/a"
					// i. e. "/a/b/../c" =&gt; "/a/c"
					result.length -= 3;
					break;
			}
		} else if(part === ".") {
			switch(result.length) {
				case 0:
					// i. e. "." =&gt; "."
					// i. e. "./a/b/c" =&gt; "./a/b/c"
					result.push(part);
					break;
				case 2:
					// i. e. "a/." =&gt; "a"
					// i. e. "/." =&gt; "/"
					// i. e. "C:\." =&gt; "C:\"
					// i. e. "C:\.\a\b\c" =&gt; "C:\a\b\c"
					if(absolutePathStart === 0) {
						result.length--;
					} else {
						i++;
						sep = !sep;
					}
					break;
				default:
					// i. e. "a/b/." =&gt; "a/b"
					// i. e. "/a/." =&gt; "/"
					// i. e. "C:\a\." =&gt; "C:\"
					// i. e. "a/./b/c" =&gt; "a/b/c"
					// i. e. "/a/./b/c" =&gt; "/a/b/c"
					result.length--;
					break;
			}
		} else if(part) {
			result.push(part);
		}
	}
	if(result.length === 1 &amp;&amp; /^[A-Za-z]:$/.test(result))
		return result[0] + "\\";
	return result.join("");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.pathToArray" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.pathToArray">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>pathToArray
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pathToArray(path) {
	path = normalize(path);
	var nix = /^\//.test(path);
	if(!nix) {
		if(!/^[A-Za-z]:/.test(path)) {
			throw new MemoryFileSystemError(errors.code.EINVAL, path);
		}
		path = path.replace(/[\\\/]+/g, "\\"); // multi slashs
		path = path.split(/[\\\/]/);
		path[0] = path[0].toUpperCase();
	} else {
		path = path.replace(/\/+/g, "/"); // multi slashs
		path = path.substr(1).split("/");
	}
	if(!path[path.length-1]) path.pop();
	return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFile" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFile">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readFile
        <span class="apidocSignatureSpan">(path, optArg, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFile = function (path, optArg, callback) {
		if(!callback) {
			callback = optArg;
			optArg = undefined;
		}
		try {
			var result = this[fn + "Sync"](path, optArg);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			compilation.dependencyFactories.set(DelegatedSourceDependency, normalModuleFactory);
		});

		compiler.plugin("before-compile", (params, callback) =&gt; {
			const manifest = this.options.manifest;
			if(typeof manifest === "string") {
				params.compilationDependencies.push(manifest);
				compiler.inputFileSystem.<span class="apidocCodeKeywordSpan">readFile</span>(manifest, function(err, result) {
					if(err) return callback(err);
					params["dll reference " + manifest] = JSON.parse(result.toString("utf-8"));
					return callback();
				});
			} else {
				return callback();
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFileSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readFileSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readFileSync
        <span class="apidocSignatureSpan">(_path, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFileSync = function (_path, encoding) {
	var path = pathToArray(_path);
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	}
	if(!isFile(current[path[i]])) {
		if(isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.EISDIR, _path);
		else
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	}
	current = current[path[i]];
	return encoding ? current.toString(encoding) : current;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdir" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdir">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readdir
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdir = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	});
};

ContextModuleFactory.prototype.resolveDependencies = function resolveDependencies(fs, resource, recursive, regExp, callback) {
	if(!regExp || !resource)
		return callback(null, []);
	(function addDirectory(directory, callback) {
		fs.<span class="apidocCodeKeywordSpan">readdir</span>(directory, function(err, files) {
			if(err) return callback(err);
			if(!files || files.length === 0) return callback(null, []);
			async.map(files.filter(function(p) {
				return p.indexOf(".") !== 0;
			}), function(seqment, callback) {

				var subResource = path.join(directory, seqment);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdirSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readdirSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readdirSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdirSync = function (_path) {
	if(_path === "/") return Object.keys(this.data).filter(Boolean);
	var path = pathToArray(_path);
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	}
	if(!isDir(current[path[i]])) {
		if(isFile(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOTDIR, _path);
		else
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	}
	return Object.keys(current[path[i]]).filter(Boolean);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlink" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlink">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readlink
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlink = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlinkSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.readlinkSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>readlinkSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlinkSync = function (_path) {
	throw new MemoryFileSystemError(errors.code.ENOSYS, _path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdir" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdir">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>rmdir
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdir = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdirSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.rmdirSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>rmdirSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdirSync = function (_path) {
	return this._remove(_path, "Directory", isDir);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.stat" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.stat">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>stat
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stat = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				callback();
			});
			compiler.plugin("run", (compiler, callback) =&gt; {
				if(!compiler._lastCompilationFileDependencies) return callback();
				const fs = compiler.inputFileSystem;
				const fileTs = compiler.fileTimestamps = {};
				async.forEach(compiler._lastCompilationFileDependencies, (file, callback) =&gt; {
					fs.<span class="apidocCodeKeywordSpan">stat</span>(file, (err, stat) =&gt; {
						if(err) {
							if(err.code === "ENOENT") return callback();
							return callback(err);
						}

						if(stat.mtime)
							this.applyMtime(+stat.mtime);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.statSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.statSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>statSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statSync = function (_path) {
	var current = this.meta(_path);
	if(_path === "/" || isDir(current)) {
		return {
			isFile: falseFn,
			isDirectory: trueFn,
			isBlockDevice: falseFn,
			isCharacterDevice: falseFn,
			isSymbolicLink: falseFn,
			isFIFO: falseFn,
			isSocket: falseFn
		};
	} else if(isFile(current)) {
		return {
			isFile: trueFn,
			isDirectory: falseFn,
			isBlockDevice: falseFn,
			isCharacterDevice: falseFn,
			isSymbolicLink: falseFn,
			isFIFO: falseFn,
			isSocket: falseFn
		};
	} else {
		throw new MemoryFileSystemError(errors.code.ENOENT, _path);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlink" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlink">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>unlink
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (path, callback) {
		try {
			var result = this[fn + "Sync"](path);
		} catch(e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlinkSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.unlinkSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>unlinkSync
        <span class="apidocSignatureSpan">(_path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlinkSync = function (_path) {
	return this._remove(_path, "File", isFile);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFile" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFile">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>writeFile
        <span class="apidocSignatureSpan">(path, content, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFile = function (path, content, encoding, callback) {
	if(!callback) {
		callback = encoding;
		encoding = undefined;
	}
	try {
		this.writeFileSync(path, content, encoding);
	} catch(e) {
		return callback(e);
	}
	return callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFileSync" id="apidoc.element.webpack.MemoryOutputFileSystem.prototype.writeFileSync">
        function <span class="apidocSignatureSpan">webpack.MemoryOutputFileSystem.prototype.</span>writeFileSync
        <span class="apidocSignatureSpan">(_path, content, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFileSync = function (_path, content, encoding) {
	if(!content &amp;&amp; !encoding) throw new Error("No content");
	var path = pathToArray(_path);
	if(path.length === 0) {
		throw new MemoryFileSystemError(errors.code.EISDIR, _path);
	}
	var current = this.data;
	for(var i = 0; i &lt; path.length - 1; i++) {
		if(!isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path);
		current = current[path[i]];
	}
	if(isDir(current[path[i]]))
		throw new MemoryFileSystemError(errors.code.EISDIR, _path);
	current[path[i]] = encoding || typeof content === "string" ? new Buffer(content, encoding) : content;
	return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Module" id="apidoc.module.webpack.Module">module webpack.Module</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Module.Module" id="apidoc.element.webpack.Module.Module">
        function <span class="apidocSignatureSpan">webpack.</span>Module
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module() {
	DependenciesBlock.call(this);
	this.context = null;
	this.reasons = [];
	this.debugId = debugId++;
	this.lastId = -1;
	this.id = null;
	this.portableId = null;
	this.index = null;
	this.index2 = null;
	this.depth = null;
	this.used = null;
	this.usedExports = null;
	this.providedExports = null;
	this.chunks = [];
	this.warnings = [];
	this.dependenciesWarnings = [];
	this.errors = [];
	this.dependenciesErrors = [];
	this.strict = false;
	this.meta = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Module.prototype" id="apidoc.module.webpack.Module.prototype">module webpack.Module.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.addChunk" id="apidoc.element.webpack.Module.prototype.addChunk">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>addChunk
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addChunk = function (chunk) {
	var idx = this.chunks.indexOf(chunk);
	if(idx &lt; 0)
		this.chunks.push(chunk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				/**
				 * remove this chunk as "intermediary" and connect
				 * it "sub chunks" and parents directly
				 */
				// add parent to each "sub chunk"
				chunk.addParent(parentChunk);
				// add "sub chunk" to parent
				parentChunk.<span class="apidocCodeKeywordSpan">addChunk</span>(chunk);
			});
		});

		/**
		 * we need to iterate again over the chunks
		 * to remove this from the chunks parents.
		 * This can not be done in the above loop
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.addReason" id="apidoc.element.webpack.Module.prototype.addReason">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>addReason
        <span class="apidocSignatureSpan">(module, dependency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addReason = function (module, dependency) {
	this.reasons.push(new ModuleReason(module, dependency));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					}
				}

				function iterationDependencies(depend) {
					for(let index = 0; index &lt; depend.length; index++) {
						const dep = depend[index];
						dep.module = dependentModule;
						dependentModule.<span class="apidocCodeKeywordSpan">addReason</span>(module, dep);
					}
				}

				if(err) {
					return errorOrWarningAndCallback(new ModuleNotFoundError(module, err, dependencies));
				}
				if(!dependentModule) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.constructor" id="apidoc.element.webpack.Module.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module() {
	DependenciesBlock.call(this);
	this.context = null;
	this.reasons = [];
	this.debugId = debugId++;
	this.lastId = -1;
	this.id = null;
	this.portableId = null;
	this.index = null;
	this.index2 = null;
	this.depth = null;
	this.used = null;
	this.usedExports = null;
	this.providedExports = null;
	this.chunks = [];
	this.warnings = [];
	this.dependenciesWarnings = [];
	this.errors = [];
	this.dependenciesErrors = [];
	this.strict = false;
	this.meta = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.disconnect" id="apidoc.element.webpack.Module.prototype.disconnect">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function () {
	this.reasons.length = 0;
	this.lastId = this.id;
	this.id = null;
	this.index = null;
	this.index2 = null;
	this.depth = null;
	this.used = null;
	this.usedExports = null;
	this.providedExports = null;
	this.chunks.length = 0;
	DependenciesBlock.prototype.disconnect.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		hash.update(this.chunks &amp;&amp; this.chunks.map((chunk) =&gt; {
			return typeof chunk.id === "number" ? chunk.id : "";
		}).join(",") || "");
		super.updateHash(hash);
	}
	disconnect() {
		this.chunks = null;
		super.<span class="apidocCodeKeywordSpan">disconnect</span>();
	}
	unseal() {
		this.chunks = null;
		super.unseal();
	}
	sortItems() {
		super.sortItems();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.hasReasonForChunk" id="apidoc.element.webpack.Module.prototype.hasReasonForChunk">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>hasReasonForChunk
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasReasonForChunk = function (chunk) {
	for(var i = 0; i &lt; this.reasons.length; i++) {
		var r = this.reasons[i];
		if(r.chunks) {
			if(r.chunks.indexOf(chunk) &gt;= 0)
				return true;
		} else if(r.module.chunks.indexOf(chunk) &gt;= 0)
			return true;
	}
	return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if(err) return callback(err);

			this.processModuleDependencies(module, (err) =&gt; {
				if(err) return callback(err);
				deps.forEach(d =&gt; {
					if(d.module &amp;&amp; d.module.removeReason(module, d)) {
						module.chunks.forEach(chunk =&gt; {
							if(!d.module.<span class="apidocCodeKeywordSpan">hasReasonForChunk</span>(chunk)) {
								if(d.module.removeChunk(chunk)) {
									this.removeChunkFromDependencies(d.module, chunk);
								}
							}
						});
					}
				});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.isProvided" id="apidoc.element.webpack.Module.prototype.isProvided">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>isProvided
        <span class="apidocSignatureSpan">(exportName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isProvided = function (exportName) {
	if(!Array.isArray(this.providedExports))
		return null;
	return this.providedExports.indexOf(exportName) &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if(this.used === null) return exportName;
	if(!exportName) return this.used ? true : false;
	if(!this.used) return false;
	if(!this.usedExports) return false;
	if(this.usedExports === true) return exportName;
	var idx = this.usedExports.indexOf(exportName);
	if(idx &lt; 0) return false;
	if(this.<span class="apidocCodeKeywordSpan">isProvided</span>(exportName))
		return Template.numberToIdentifer(idx);
	return exportName;
};

Module.prototype.isProvided = function(exportName) {
	if(!Array.isArray(this.providedExports))
		return null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.isUsed" id="apidoc.element.webpack.Module.prototype.isUsed">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>isUsed
        <span class="apidocSignatureSpan">(exportName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUsed = function (exportName) {
	if(this.used === null) return exportName;
	if(!exportName) return this.used ? true : false;
	if(!this.used) return false;
	if(!this.usedExports) return false;
	if(this.usedExports === true) return exportName;
	var idx = this.usedExports.indexOf(exportName);
	if(idx &lt; 0) return false;
	if(this.isProvided(exportName))
		return Template.numberToIdentifer(idx);
	return exportName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.needRebuild" id="apidoc.element.webpack.Module.prototype.needRebuild">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>needRebuild
        <span class="apidocSignatureSpan">(fileTimestamps, contextTimestamps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">needRebuild = function (fileTimestamps, contextTimestamps) {
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
		const cacheName = (cacheGroup || "m") + identifier;
		if(this.cache &amp;&amp; this.cache[cacheName]) {
			const cacheModule = this.cache[cacheName];

			let rebuild = true;
			if(!cacheModule.error &amp;&amp; cacheModule.cacheable &amp;&amp; this.fileTimestamps &amp;&amp; this.contextTimestamps
) {
				rebuild = cacheModule.<span class="apidocCodeKeywordSpan">needRebuild</span>(this.fileTimestamps, this.contextTimestamps);
			}

			if(!rebuild) {
				cacheModule.disconnect();
				this._modules[identifier] = cacheModule;
				this.modules.push(cacheModule);
				cacheModule.errors.forEach(err =&gt; this.errors.push(err), this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.removeChunk" id="apidoc.element.webpack.Module.prototype.removeChunk">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>removeChunk
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeChunk = function (chunk) {
	var idx = this.chunks.indexOf(chunk);
	if(idx &gt;= 0) {
		this.chunks.splice(idx, 1);
		chunk.removeModule(this);
		return true;
	}
	return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		return this.addToCollection(this.blocks, block);
	}

	removeModule(module) {
		const idx = this.modules.indexOf(module);
		if(idx &gt;= 0) {
			this.modules.splice(idx, 1);
			module.<span class="apidocCodeKeywordSpan">removeChunk</span>(this);
			return true;
		}
		return false;
	}

	removeChunk(chunk) {
		const idx = this.chunks.indexOf(chunk);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.removeReason" id="apidoc.element.webpack.Module.prototype.removeReason">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>removeReason
        <span class="apidocSignatureSpan">(module, dependency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeReason = function (module, dependency) {
	for(var i = 0; i &lt; this.reasons.length; i++) {
		var r = this.reasons[i];
		if(r.module === module &amp;&amp; r.dependency === dependency) {
			this.reasons.splice(i, 1);
			return true;
		}
	}
	return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		const deps = module.dependencies.slice();
		this.buildModule(module, false, module, null, (err) =&gt; {
			if(err) return callback(err);

			this.processModuleDependencies(module, (err) =&gt; {
				if(err) return callback(err);
				deps.forEach(d =&gt; {
					if(d.module &amp;&amp; d.module.<span class="apidocCodeKeywordSpan">removeReason</span>(module, d)) {
						module.chunks.forEach(chunk =&gt; {
							if(!d.module.hasReasonForChunk(chunk)) {
								if(d.module.removeChunk(chunk)) {
									this.removeChunkFromDependencies(d.module, chunk);
								}
							}
						});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.rewriteChunkInReasons" id="apidoc.element.webpack.Module.prototype.rewriteChunkInReasons">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>rewriteChunkInReasons
        <span class="apidocSignatureSpan">(oldChunk, newChunks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rewriteChunkInReasons = function (oldChunk, newChunks) {
	this.reasons.forEach(function(r) {
		if(!r.chunks) {
			if(r.module.chunks.indexOf(oldChunk) &lt; 0)
				return;
			r.chunks = r.module.chunks;
		}
		r.chunks = r.chunks.reduce(function(arr, c) {
			addToSet(arr, c !== oldChunk ? [c] : newChunks);
			return arr;
		}, []);
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		});
	}

	moveModule(module, otherChunk) {
		module.removeChunk(this);
		module.addChunk(otherChunk);
		otherChunk.addModule(module);
		module.<span class="apidocCodeKeywordSpan">rewriteChunkInReasons</span>(this, [otherChunk]);
	}

	replaceChunk(oldChunk, newChunk) {
		const idx = this.chunks.indexOf(oldChunk);
		if(idx &gt;= 0) {
			this.chunks.splice(idx, 1);
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.sortItems" id="apidoc.element.webpack.Module.prototype.sortItems">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>sortItems
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sortItems = function () {
	DependenciesBlock.prototype.sortItems.call(this);
	this.chunks.sort(byId);
	this.reasons.sort(function(a, b) {
		return byId(a.module, b.module);
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		super.disconnect();
	}
	unseal() {
		this.chunks = null;
		super.unseal();
	}
	sortItems() {
		super.<span class="apidocCodeKeywordSpan">sortItems</span>();
		if(this.chunks) {
			this.chunks.sort((a, b) =&gt; {
				let i = 0;
				while(true) { // eslint-disable-line no-constant-condition
					if(!a.modules[i] &amp;&amp; !b.modules[i]) return 0;
					if(!a.modules[i]) return -1;
					if(!b.modules[i]) return 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.toString" id="apidoc.element.webpack.Module.prototype.toString">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
	return "Module[" + (this.id || this.debugId) + "]";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						return JSON.stringify(key) + ":" + toCode(code);
					}).join(",") + "})";
				}

				function toCode(code) {
					if(code === null) return "null";
					else if(code === undefined) return "undefined";
					else if(code instanceof RegExp &amp;&amp; code.toString) return code.<span class="apidocCodeKeywordSpan">toString</span>();
					else if(typeof code === "function" &amp;&amp; code.toString) return "(" + code.toString() + ")&amp;#
x22;;
					else if(typeof code === "object") return stringifyObj(code);
					else return code + "";
				}

				function applyDefineKey(prefix, key) {
					const splittedKey = key.split(".");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.unbuild" id="apidoc.element.webpack.Module.prototype.unbuild">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>unbuild
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unbuild = function () {
	this.disconnect();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				cacheModule.errors.forEach(err =&gt; this.errors.push(err), this);
				cacheModule.warnings.forEach(err =&gt; this.warnings.push(err), this);
				return cacheModule;
			} else {
				module.lastId = cacheModule.id;
			}
		}
		module.<span class="apidocCodeKeywordSpan">unbuild</span>();
		this._modules[identifier] = module;
		if(this.cache) {
			this.cache[cacheName] = module;
		}
		this.modules.push(module);
		return true;
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.unseal" id="apidoc.element.webpack.Module.prototype.unseal">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>unseal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unseal = function () {
	this.lastId = this.id;
	this.id = null;
	this.index = null;
	this.index2 = null;
	this.depth = null;
	this.chunks.length = 0;
	DependenciesBlock.prototype.unseal.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}
	disconnect() {
		this.chunks = null;
		super.disconnect();
	}
	unseal() {
		this.chunks = null;
		super.<span class="apidocCodeKeywordSpan">unseal</span>();
	}
	sortItems() {
		super.sortItems();
		if(this.chunks) {
			this.chunks.sort((a, b) =&gt; {
				let i = 0;
				while(true) { // eslint-disable-line no-constant-condition
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Module.prototype.updateHash" id="apidoc.element.webpack.Module.prototype.updateHash">
        function <span class="apidocSignatureSpan">webpack.Module.prototype.</span>updateHash
        <span class="apidocSignatureSpan">(hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateHash = function (hash) {
	hash.update(this.id + "" + this.used);
	hash.update(JSON.stringify(this.usedExports));
	DependenciesBlock.prototype.updateHash.call(this, hash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		throw new Error("`chunk` was been renamed to `chunks` and is now an array");
	}
	updateHash(hash) {
		hash.update(this.chunkName || "");
		hash.update(this.chunks &amp;&amp; this.chunks.map((chunk) =&gt; {
			return typeof chunk.id === "number" ? chunk.id : "";
		}).join(",") || "");
		super.<span class="apidocCodeKeywordSpan">updateHash</span>(hash);
	}
	disconnect() {
		this.chunks = null;
		super.disconnect();
	}
	unseal() {
		this.chunks = null;
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ModuleFilenameHelpers" id="apidoc.module.webpack.ModuleFilenameHelpers">module webpack.ModuleFilenameHelpers</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ModuleFilenameHelpers.createFilename" id="apidoc.element.webpack.ModuleFilenameHelpers.createFilename">
        function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>createFilename
        <span class="apidocSignatureSpan">(module, moduleFilenameTemplate, requestShortener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFilename(module, moduleFilenameTemplate, requestShortener) {
	var absoluteResourcePath;
	var hash;
	var identifier;
	var moduleId;
	var shortIdentifier;
	if(!module) module = "";
	if(typeof module === "string") {
		shortIdentifier = requestShortener.shorten(module);
		identifier = shortIdentifier;
		moduleId = "";
		absoluteResourcePath = module.split("!").pop();
		hash = getHash(identifier);
	} else {
		shortIdentifier = module.readableIdentifier(requestShortener);
		identifier = requestShortener.shorten(module.identifier());
		moduleId = module.id;
		absoluteResourcePath = module.resourcePath || module.identifier().split("!").pop();
		hash = getHash(identifier);
	}
	var resource = shortIdentifier.split("!").pop();
	var loaders = getBefore(shortIdentifier, "!");
	var allLoaders = getBefore(identifier, "!");
	var query = getAfter(resource, "?");
	var resourcePath = resource.substr(0, resource.length - query.length);
	if(typeof moduleFilenameTemplate === "function") {
		return moduleFilenameTemplate({
			identifier: identifier,
			shortIdentifier: shortIdentifier,
			resource: resource,
			resourcePath: resourcePath,
			absoluteResourcePath: absoluteResourcePath,
			allLoaders: allLoaders,
			query: query,
			moduleId: moduleId,
			hash: hash
		});
	}
	return moduleFilenameTemplate
		.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE, identifier)
		.replace(ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE, shortIdentifier)
		.replace(ModuleFilenameHelpers.REGEXP_RESOURCE, resource)
		.replace(ModuleFilenameHelpers.REGEXP_RESOURCE_PATH, resourcePath)
		.replace(ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH, absoluteResourcePath)
		.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS, allLoaders)
		.replace(ModuleFilenameHelpers.REGEXP_LOADERS, loaders)
		.replace(ModuleFilenameHelpers.REGEXP_QUERY, query)
		.replace(ModuleFilenameHelpers.REGEXP_ID, moduleId)
		.replace(ModuleFilenameHelpers.REGEXP_HASH, hash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.sourceUrlComment = sourceUrlComment || "\n//# sourceURL=[url]";
		this.moduleFilenameTemplate = moduleFilenameTemplate || "webpack:///[resourcePath]?[loaders]";
	}

	apply(moduleTemplate) {
		moduleTemplate.plugin("module", (source, module) =&gt; {
			const content = source.source();
			const str = ModuleFilenameHelpers.<span class="apidocCodeKeywordSpan">createFilename</span>(module, this.moduleFilenameTemplate
, moduleTemplate.requestShortener);
			const footer = ["\n",
				ModuleFilenameHelpers.createFooter(module, moduleTemplate.requestShortener),
				this.sourceUrlComment.replace(/\[url\]/g, encodeURI(str).replace(/%2F/g, "/").replace(/%20/g, "_").replace
(/%5E/g, "^").replace(/%5C/g, "\\").replace(/^\//, ""))
			].join("\n");
			return new RawSource(`eval(${JSON.stringify(content + footer)});`);
		});
		moduleTemplate.plugin("hash", hash =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ModuleFilenameHelpers.createFooter" id="apidoc.element.webpack.ModuleFilenameHelpers.createFooter">
        function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>createFooter
        <span class="apidocSignatureSpan">(module, requestShortener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFooter(module, requestShortener) {
	if(!module) module = "";
	if(typeof module === "string") {
		return [
			"// WEBPACK FOOTER //",
			"// " + requestShortener.shorten(module)
		].join("\n");
	} else {
		return [
			"//////////////////",
			"// WEBPACK FOOTER",
			"// " + module.readableIdentifier(requestShortener),
			"// module id = " + module.id,
			"// module chunks = " + module.chunks.map(function(c) {
				return c.id;
			}).join(" ")
		].join("\n");
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	apply(moduleTemplate) {
		moduleTemplate.plugin("module", (source, module) =&gt; {
			const content = source.source();
			const str = ModuleFilenameHelpers.createFilename(module, this.moduleFilenameTemplate, moduleTemplate.requestShortener);
			const footer = ["\n",
				ModuleFilenameHelpers.<span class="apidocCodeKeywordSpan">createFooter</span>(module, moduleTemplate.requestShortener),
				this.sourceUrlComment.replace(/\[url\]/g, encodeURI(str).replace(/%2F/g, "/").replace(/%20/g, "_").replace
(/%5E/g, "^").replace(/%5C/g, "\\").replace(/^\//, ""))
			].join("\n");
			return new RawSource(`eval(${JSON.stringify(content + footer)});`);
		});
		moduleTemplate.plugin("hash", hash =&gt; {
			hash.update("EvalDevToolModuleTemplatePlugin");
			hash.update("2");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ModuleFilenameHelpers.matchObject" id="apidoc.element.webpack.ModuleFilenameHelpers.matchObject">
        function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>matchObject
        <span class="apidocSignatureSpan">(obj, str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchObject(obj, str) {
	if(obj.test)
		if(!ModuleFilenameHelpers.matchPart(str, obj.test)) return false;
	if(obj.include)
		if(!ModuleFilenameHelpers.matchPart(str, obj.include)) return false;
	if(obj.exclude)
		if(ModuleFilenameHelpers.matchPart(str, obj.exclude)) return false;
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("normal-module-loader", (context, module) =&gt; {
				const resource = module.resource;
				if(!resource) return;
				const i = resource.indexOf("?");
				if(ModuleFilenameHelpers.<span class="apidocCodeKeywordSpan">matchObject</span>(options, i &lt; 0 ? resource : resource.substr
(0, i))) {
					const filterSet = new Set(["include", "exclude", "test"]);
					Object.keys(options)
						.filter((key) =&gt; !filterSet.has(key))
						.forEach((key) =&gt; context[key] = options[key]);
				}
			});
		});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ModuleFilenameHelpers.matchPart" id="apidoc.element.webpack.ModuleFilenameHelpers.matchPart">
        function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>matchPart
        <span class="apidocSignatureSpan">(str, test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchPart(str, test) {
	if(!test) return true;
	test = asRegExp(test);
	if(Array.isArray(test)) {
		return test.map(asRegExp).filter(function(regExp) {
			return regExp.test(str);
		}).length &gt; 0;
	} else {
		return test.test(str);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ModuleFilenameHelpers.replaceDuplicates" id="apidoc.element.webpack.ModuleFilenameHelpers.replaceDuplicates">
        function <span class="apidocSignatureSpan">webpack.ModuleFilenameHelpers.</span>replaceDuplicates
        <span class="apidocSignatureSpan">(array, fn, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceDuplicates(array, fn, comparator) {
	var countMap = {};
	var posMap = {};
	array.forEach(function(item, idx) {
		countMap[item] = (countMap[item] || []);
		countMap[item].push(idx);
		posMap[item] = 0;
	});
	if(comparator) {
		Object.keys(countMap).forEach(function(item) {
			countMap[item].sort(comparator);
		});
	}
	return array.map(function(item, i) {
		if(countMap[item].length &gt; 1) {
			if(comparator &amp;&amp; countMap[item][0] === i)
				return item;
			return fn(item, i, posMap[item]++);
		} else return item;
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			const modules = sourceMap.sources.map(function(source) {
				const module = self.compilation.findModule(source);
				return module || source;
			});
			let moduleFilenames = modules.map(function(module) {
				return ModuleFilenameHelpers.createFilename(module, self.moduleFilenameTemplate, this.requestShortener);
			}, this);
			moduleFilenames = ModuleFilenameHelpers.<span class="apidocCodeKeywordSpan">replaceDuplicates</span>(moduleFilenames, function
(filename, i, n) {
				for(let j = 0; j &lt; n; j++)
					filename += "*";
				return filename;
			});
			sourceMap.sources = moduleFilenames;
			if(sourceMap.sourcesContent) {
				sourceMap.sourcesContent = sourceMap.sourcesContent.map(function(content, i) {
...</pre></li>
    </ul>










































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.MultiCompiler" id="apidoc.module.webpack.MultiCompiler">module webpack.MultiCompiler</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler.MultiCompiler" id="apidoc.element.webpack.MultiCompiler.MultiCompiler">
        function <span class="apidocSignatureSpan">webpack.</span>MultiCompiler
        <span class="apidocSignatureSpan">(compilers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiCompiler(compilers) {
	Tapable.call(this);
	if(!Array.isArray(compilers)) {
		compilers = Object.keys(compilers).map(function(name) {
			compilers[name].name = name;
			return compilers[name];
		});
	}
	this.compilers = compilers;

	function delegateProperty(name) {
		Object.defineProperty(this, name, {
			configurable: false,
			get: function() {
				throw new Error("Cannot read " + name + " of a MultiCompiler");
			},
			set: function(value) {
				this.compilers.forEach(function(compiler) {
					compiler[name] = value;
				});
			}.bind(this)
		});
	}
	delegateProperty.call(this, "outputFileSystem");
	delegateProperty.call(this, "inputFileSystem");

	Object.defineProperty(this, "outputPath", {
		configurable: false,
		get: function() {
			var commonPath = compilers[0].outputPath;
			for(var i = 1; i &lt; compilers.length; i++) {
				while(compilers[i].outputPath.indexOf(commonPath) !== 0 &amp;&amp; /[\/\\]/.test(commonPath)) {
					commonPath = commonPath.replace(/[\/\\][^\/\\]*$/, "");
				}
			}
			if(!commonPath &amp;&amp; compilers[0].outputPath[0] === "/") return "/";
			return commonPath;
		}
	});

	var doneCompilers = 0;
	var compilerStats = [];
	this.compilers.forEach(function(compiler, idx) {
		var compilerDone = false;
		compiler.plugin("done", function(stats) {
			if(!compilerDone) {
				compilerDone = true;
				doneCompilers++;
			}
			compilerStats[idx] = stats;
			if(doneCompilers === this.compilers.length) {
				this.applyPlugins("done", new MultiStats(compilerStats));
			}
		}.bind(this));
		compiler.plugin("invalid", function() {
			if(compilerDone) {
				compilerDone = false;
				doneCompilers--;
			}
			this.applyPlugins("invalid");
		}.bind(this));
	}, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.MultiCompiler.prototype" id="apidoc.module.webpack.MultiCompiler.prototype">module webpack.MultiCompiler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler.prototype.constructor" id="apidoc.element.webpack.MultiCompiler.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>constructor
        <span class="apidocSignatureSpan">(compilers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiCompiler(compilers) {
	Tapable.call(this);
	if(!Array.isArray(compilers)) {
		compilers = Object.keys(compilers).map(function(name) {
			compilers[name].name = name;
			return compilers[name];
		});
	}
	this.compilers = compilers;

	function delegateProperty(name) {
		Object.defineProperty(this, name, {
			configurable: false,
			get: function() {
				throw new Error("Cannot read " + name + " of a MultiCompiler");
			},
			set: function(value) {
				this.compilers.forEach(function(compiler) {
					compiler[name] = value;
				});
			}.bind(this)
		});
	}
	delegateProperty.call(this, "outputFileSystem");
	delegateProperty.call(this, "inputFileSystem");

	Object.defineProperty(this, "outputPath", {
		configurable: false,
		get: function() {
			var commonPath = compilers[0].outputPath;
			for(var i = 1; i &lt; compilers.length; i++) {
				while(compilers[i].outputPath.indexOf(commonPath) !== 0 &amp;&amp; /[\/\\]/.test(commonPath)) {
					commonPath = commonPath.replace(/[\/\\][^\/\\]*$/, "");
				}
			}
			if(!commonPath &amp;&amp; compilers[0].outputPath[0] === "/") return "/";
			return commonPath;
		}
	});

	var doneCompilers = 0;
	var compilerStats = [];
	this.compilers.forEach(function(compiler, idx) {
		var compilerDone = false;
		compiler.plugin("done", function(stats) {
			if(!compilerDone) {
				compilerDone = true;
				doneCompilers++;
			}
			compilerStats[idx] = stats;
			if(doneCompilers === this.compilers.length) {
				this.applyPlugins("done", new MultiStats(compilerStats));
			}
		}.bind(this));
		compiler.plugin("invalid", function() {
			if(compilerDone) {
				compilerDone = false;
				doneCompilers--;
			}
			this.applyPlugins("invalid");
		}.bind(this));
	}, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler.prototype.purgeInputFileSystem" id="apidoc.element.webpack.MultiCompiler.prototype.purgeInputFileSystem">
        function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>purgeInputFileSystem
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purgeInputFileSystem = function () {
	this.compilers.forEach(function(compiler) {
		if(compiler.inputFileSystem &amp;&amp; compiler.inputFileSystem.purge)
			compiler.inputFileSystem.purge();
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler.prototype.run" id="apidoc.element.webpack.MultiCompiler.prototype.run">
        function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>run
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (callback) {
	var allStats = this.compilers.map(function() {
		return null;
	});

	runWithDependencies(this.compilers, function(compiler, callback) {
		var compilerIdx = this.compilers.indexOf(compiler);
		compiler.run(function(err, stats) {
			if(err) return callback(err);
			allStats[compilerIdx] = stats;
			callback();
		});
	}.bind(this), function(err) {
		if(err) return callback(err);
		callback(null, new MultiStats(allStats));
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	new WebpackOptionsDefaulter().process(options);

	const compiler = new Compiler();
	compiler.options = options;
	compiler.options = new WebpackOptionsApply().process(options, compiler);
	new WebEnvironmentPlugin(options.inputFileSystem, options.outputFileSystem).apply(compiler);
	if(callback) {
		compiler.<span class="apidocCodeKeywordSpan">run</span>(callback);
	}
	return compiler;
}
module.exports = webpack;

webpack.WebpackOptionsDefaulter = WebpackOptionsDefaulter;
webpack.WebpackOptionsApply = WebpackOptionsApply;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.MultiCompiler.prototype.watch" id="apidoc.element.webpack.MultiCompiler.prototype.watch">
        function <span class="apidocSignatureSpan">webpack.MultiCompiler.prototype.</span>watch
        <span class="apidocSignatureSpan">(watchOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watch = function (watchOptions, handler) {
	var watchings = [];
	var allStats = this.compilers.map(function() {
		return null;
	});
	var compilerStatus = this.compilers.map(function() {
		return false;
	});

	runWithDependencies(this.compilers, function(compiler, callback) {
		var compilerIdx = this.compilers.indexOf(compiler);
		var firstRun = true;
		var watching = compiler.watch(watchOptions, function(err, stats) {
			if(err)
				handler(err);
			if(stats) {
				allStats[compilerIdx] = stats;
				compilerStatus[compilerIdx] = "new";
				if(compilerStatus.every(Boolean)) {
					var freshStats = allStats.filter(function(s, idx) {
						return compilerStatus[idx] === "new";
					});
					compilerStatus.fill(true);
					var multiStats = new MultiStats(freshStats);
					handler(null, multiStats);
				}
			}
			if(firstRun &amp;&amp; !err) {
				firstRun = false;
				callback();
			}
		});
		watchings.push(watching);
	}.bind(this), function() {
		// ignore
	});

	return new MultiWatching(watchings, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		const ignored = path =&gt; this.paths.some(p =&gt; p instanceof RegExp ? p.test(path) : path.indexOf(p) === 0);

		const notIgnored = path =&gt; !ignored(path);

		const ignoredFiles = files.filter(ignored);
		const ignoredDirs = dirs.filter(ignored);

		this.wfs.<span class="apidocCodeKeywordSpan">watch</span>(files.filter(notIgnored), dirs.filter(notIgnored), missing, startTime
, options, (err, filesModified, dirsModified, missingModified, fileTimestamps, dirTimestamps) =&gt; {
			if(err) return callback(err);

			ignoredFiles.forEach(path =&gt; {
				fileTimestamps[path] = 1;
			});

			ignoredDirs.forEach(path =&gt; {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.NodeStuffPlugin" id="apidoc.module.webpack.NodeStuffPlugin">module webpack.NodeStuffPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.NodeStuffPlugin.NodeStuffPlugin" id="apidoc.element.webpack.NodeStuffPlugin.NodeStuffPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>NodeStuffPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodeStuffPlugin(options) {
	this.options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.NodeStuffPlugin.prototype" id="apidoc.module.webpack.NodeStuffPlugin.prototype">module webpack.NodeStuffPlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.NodeStuffPlugin.prototype.apply" id="apidoc.element.webpack.NodeStuffPlugin.prototype.apply">
        function <span class="apidocSignatureSpan">webpack.NodeStuffPlugin.prototype.</span>apply
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (compiler) {
	var options = this.options;
	compiler.plugin("compilation", function(compilation, params) {
		compilation.dependencyFactories.set(ConstDependency, new NullFactory());
		compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

		params.normalModuleFactory.plugin("parser", function(parser, parserOptions) {

			if(parserOptions.node === false)
				return;

			var localOptions = options;
			if(parserOptions.node)
				localOptions = Object.assign({}, localOptions, parserOptions.node);

			function setConstant(expressionName, value) {
				parser.plugin("expression " + expressionName, function() {
					this.state.current.addVariable(expressionName, JSON.stringify(value));
					return true;
				});
			}

			function setModuleConstant(expressionName, fn) {
				parser.plugin("expression " + expressionName, function() {
					this.state.current.addVariable(expressionName, JSON.stringify(fn(this.state.module)));
					return true;
				});
			}
			var context = compiler.context;
			if(localOptions.__filename === "mock") {
				setConstant("__filename", "/index.js");
			} else if(localOptions.__filename) {
				setModuleConstant("__filename", function(module) {
					return path.relative(context, module.resource);
				});
			}
			parser.plugin("evaluate Identifier __filename", function(expr) {
				if(!this.state.module) return;
				var resource = this.state.module.resource;
				var i = resource.indexOf("?");
				return ParserHelpers.evaluateToString(i &lt; 0 ? resource : resource.substr(0, i))(expr);
			});
			if(localOptions.__dirname === "mock") {
				setConstant("__dirname", "/");
			} else if(localOptions.__dirname) {
				setModuleConstant("__dirname", function(module) {
					return path.relative(context, module.context);
				});
			}
			parser.plugin("evaluate Identifier __dirname", function(expr) {
				if(!this.state.module) return;
				return ParserHelpers.evaluateToString(this.state.module.context)(expr);
			});
			parser.plugin("expression require.main", ParserHelpers.toConstantDependency("__webpack_require__.c[__webpack_require__.s]"));
			parser.plugin(
				"expression require.extensions",
				ParserHelpers.expressionIsUnsupported("require.extensions is not supported by webpack. Use a loader instead.")
			);
			parser.plugin("expression module.loaded", ParserHelpers.toConstantDependency("module.l"));
			parser.plugin("expression module.id", ParserHelpers.toConstantDependency("module.i"));
			parser.plugin("expression module.exports", function() {
				var module = this.state.module;
				var isHarmony = module.meta &amp;&amp; module.meta.harmonyModule;
				if(!isHarmony)
					return true;
			});
			parser.plugin("evaluate Identifier module.hot", ParserHelpers.evaluateToBoolean(false));
			parser.plugin("expression module", function() {
				var module = this.state.module;
				var isHarmony = module.meta &amp;&amp; module.meta.harmonyModule;
				var moduleJsPath = path.join(__dirname, "..", "buildin", isHarmony ? "harmony-module.js" : "module.js");
				if(module.context) {
					moduleJsPath = path.relative(this.state.module.context, moduleJsPath);
					if(!/^[A-Z]:/i.test(moduleJsPath)) {
						moduleJsPath = "./" + moduleJsPath.replace(/\\/g, "/");
					}
				}
				return ParserHelpers.addParsedVariableToModule(this, "module", "require(" + JSON.stringify(moduleJsPath) + ")(module)");
			});
		});
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.<span class="apidocCodeKeywordSpan">apply</span>(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.NormalModuleFactory" id="apidoc.module.webpack.NormalModuleFactory">module webpack.NormalModuleFactory</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.NormalModuleFactory.NormalModuleFactory" id="apidoc.element.webpack.NormalModuleFactory.NormalModuleFactory">
        function <span class="apidocSignatureSpan">webpack.</span>NormalModuleFactory
        <span class="apidocSignatureSpan">(context, resolvers, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NormalModuleFactory(context, resolvers, options) {
	Tapable.call(this);
	this.resolvers = resolvers;
	this.ruleSet = new RuleSet(options.rules || options.loaders);
	this.cachePredicate = typeof options.unsafeCache === "function" ? options.unsafeCache : Boolean.bind(null, options.unsafeCache);
	this.context = context || "";
	this.parserCache = {};
	this.plugin("factory", function() {
		var _this = this;
		return function(result, callback) {
			var resolver = _this.applyPluginsWaterfall0("resolver", null);

			// Ignored
			if(!resolver) return callback();

			resolver(result, function onDoneResolving(err, data) {
				if(err) return callback(err);

				// Ignored
				if(!data) return callback();

				// direct module
				if(typeof data.source === "function")
					return callback(null, data);

				_this.applyPluginsAsyncWaterfall("after-resolve", data, function(err, result) {
					if(err) return callback(err);

					// Ignored
					if(!result) return callback();

					var createdModule = _this.applyPluginsBailResult("create-module", result);
					if(!createdModule) {

						if(!result.request) {
							return callback(new Error("Empty dependency (no request)"));
						}

						createdModule = new NormalModule(
							result.request,
							result.userRequest,
							result.rawRequest,
							result.loaders,
							result.resource,
							result.parser
						);
					}

					createdModule = _this.applyPluginsWaterfall0("module", createdModule);

					return callback(null, createdModule);
				});
			});
		};
	});
	this.plugin("resolver", function() {
		var _this = this;
		return function(data, callback) {
			var contextInfo = data.contextInfo;
			var context = data.context;
			var request = data.request;
			var resolveContextInfo = {};

			var noAutoLoaders = /^-?!/.test(request);
			var noPrePostAutoLoaders = /^!!/.test(request);
			var noPostAutoLoaders = /^-!/.test(request);
			var elements = request.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!");
			var resource = elements.pop();
			elements = elements.map(identToLoaderRequest);

			async.parallel([
				function(callback) {
					_this.resolveRequestArray(resolveContextInfo, context, elements, _this.resolvers.loader, callback);
				},
				function(callback) {
					if(resource === "" || resource[0] === "?")
						return callback(null, {
							resource: resource
						});

					_this.resolvers.normal.resolve(resolveContextInfo, context, resource, function(err, resource, resourceResolveData) {
						if(err) return callback(err);
						callback(null, {
							resourceResolveData: resourceResolveData,
							resource: resource,
						});
					});
				}
			], function(err, results) {
				if(err) return callback(err);
				var loaders = results[0];
				var resourceResolveData = results[1].resourceResolveData;
				resource = results[1].resource;

				// translate option idents
				try {
					loaders.forEach(function(item) {
						if(typeof item.options === "string" &amp;&amp; /^\?/.test(item.options)) {
							item.options = _this.ruleSet.findOptionsByIdent(item.options.substr(1));
						}
					});
				} catch(e) {
					return callback(e);
				}

				if(resource === false)
					return callback(null,
						new RawModule("/* (ignored) */",
							"ignored " + context + " " + request,
							request + " (ignored)")); // ignored

				var userRequest = loaders.map(loaderToIdent).concat([resource]).join("!");

				var resourcePath = resource;
				var resourceQuery = "";
				var queryIndex = resourcePath.indexOf("?");
				if(queryIndex &gt;= 0) {
					resourceQuery = resourcePath.substr(queryIndex);
					resourcePath = resourcePath.substr(0, queryIndex);
				}

				var result = _this.ruleSet.exec({
					resource: resourcePath,
					resourceQuery: resourceQuery,
					issuer: contextInfo.issuer,
					compiler: contextInfo.compiler
				});
				var settings = {};
				var useLoadersPost = [];
				var useLoaders = [];
				var useLoadersPre = [];
				result.forEac ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.NormalModuleFactory.prototype" id="apidoc.module.webpack.NormalModuleFactory.prototype">module webpack.NormalModuleFactory.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.NormalModuleFactory.prototype.constructor" id="apidoc.element.webpack.NormalModuleFactory.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.NormalModuleFactory.prototype.</span>constructor
        <span class="apidocSignatureSpan">(context, resolvers, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NormalModuleFactory(context, resolvers, options) {
	Tapable.call(this);
	this.resolvers = resolvers;
	this.ruleSet = new RuleSet(options.rules || options.loaders);
	this.cachePredicate = typeof options.unsafeCache === "function" ? options.unsafeCache : Boolean.bind(null, options.unsafeCache);
	this.context = context || "";
	this.parserCache = {};
	this.plugin("factory", function() {
		var _this = this;
		return function(result, callback) {
			var resolver = _this.applyPluginsWaterfall0("resolver", null);

			// Ignored
			if(!resolver) return callback();

			resolver(result, function onDoneResolving(err, data) {
				if(err) return callback(err);

				// Ignored
				if(!data) return callback();

				// direct module
				if(typeof data.source === "function")
					return callback(null, data);

				_this.applyPluginsAsyncWaterfall("after-resolve", data, function(err, result) {
					if(err) return callback(err);

					// Ignored
					if(!result) return callback();

					var createdModule = _this.applyPluginsBailResult("create-module", result);
					if(!createdModule) {

						if(!result.request) {
							return callback(new Error("Empty dependency (no request)"));
						}

						createdModule = new NormalModule(
							result.request,
							result.userRequest,
							result.rawRequest,
							result.loaders,
							result.resource,
							result.parser
						);
					}

					createdModule = _this.applyPluginsWaterfall0("module", createdModule);

					return callback(null, createdModule);
				});
			});
		};
	});
	this.plugin("resolver", function() {
		var _this = this;
		return function(data, callback) {
			var contextInfo = data.contextInfo;
			var context = data.context;
			var request = data.request;
			var resolveContextInfo = {};

			var noAutoLoaders = /^-?!/.test(request);
			var noPrePostAutoLoaders = /^!!/.test(request);
			var noPostAutoLoaders = /^-!/.test(request);
			var elements = request.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!");
			var resource = elements.pop();
			elements = elements.map(identToLoaderRequest);

			async.parallel([
				function(callback) {
					_this.resolveRequestArray(resolveContextInfo, context, elements, _this.resolvers.loader, callback);
				},
				function(callback) {
					if(resource === "" || resource[0] === "?")
						return callback(null, {
							resource: resource
						});

					_this.resolvers.normal.resolve(resolveContextInfo, context, resource, function(err, resource, resourceResolveData) {
						if(err) return callback(err);
						callback(null, {
							resourceResolveData: resourceResolveData,
							resource: resource,
						});
					});
				}
			], function(err, results) {
				if(err) return callback(err);
				var loaders = results[0];
				var resourceResolveData = results[1].resourceResolveData;
				resource = results[1].resource;

				// translate option idents
				try {
					loaders.forEach(function(item) {
						if(typeof item.options === "string" &amp;&amp; /^\?/.test(item.options)) {
							item.options = _this.ruleSet.findOptionsByIdent(item.options.substr(1));
						}
					});
				} catch(e) {
					return callback(e);
				}

				if(resource === false)
					return callback(null,
						new RawModule("/* (ignored) */",
							"ignored " + context + " " + request,
							request + " (ignored)")); // ignored

				var userRequest = loaders.map(loaderToIdent).concat([resource]).join("!");

				var resourcePath = resource;
				var resourceQuery = "";
				var queryIndex = resourcePath.indexOf("?");
				if(queryIndex &gt;= 0) {
					resourceQuery = resourcePath.substr(queryIndex);
					resourcePath = resourcePath.substr(0, queryIndex);
				}

				var result = _this.ruleSet.exec({
					resource: resourcePath,
					resourceQuery: resourceQuery,
					issuer: contextInfo.issuer,
					compiler: contextInfo.compiler
				});
				var settings = {};
				var useLoadersPost = [];
				var useLoaders = [];
				var useLoadersPre = [];
				result.forEac ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NormalModuleFactory.prototype.create" id="apidoc.element.webpack.NormalModuleFactory.prototype.create">
        function <span class="apidocSignatureSpan">webpack.NormalModuleFactory.prototype.</span>create
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, callback) {
	var _this = this;
	var dependencies = data.dependencies;
	var cacheEntry = dependencies[0].__NormalModuleFactoryCache;
	if(cacheEntry) return callback(null, cacheEntry);
	var context = data.context || this.context;
	var request = dependencies[0].request;
	var contextInfo = data.contextInfo || {};
	_this.applyPluginsAsyncWaterfall("before-resolve", {
		contextInfo: contextInfo,
		context: context,
		request: request,
		dependencies: dependencies
	}, function(err, result) {
		if(err) return callback(err);

		// Ignored
		if(!result) return callback();

		var factory = _this.applyPluginsWaterfall0("factory", null);

		// Ignored
		if(!factory) return callback();

		factory(result, function(err, module) {
			if(err) return callback(err);

			if(module &amp;&amp; _this.cachePredicate(module)) {
				dependencies.forEach(function(d) {
					d.__NormalModuleFactoryCache = module;
				});
			}

			callback(null, module);
		});

	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...





module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.<span class="apidocCodeKeywordSpan">create</span>(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NormalModuleFactory.prototype.createParser" id="apidoc.element.webpack.NormalModuleFactory.prototype.createParser">
        function <span class="apidocSignatureSpan">webpack.NormalModuleFactory.prototype.</span>createParser
        <span class="apidocSignatureSpan">(parserOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createParser(parserOptions) {
	var parser = new Parser();
	this.applyPlugins2("parser", parser, parserOptions || {});
	return parser;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			ident = parserOptions.ident;
		else
			ident = JSON.stringify(parserOptions);
	}
	var parser = this.parserCache[ident];
	if(parser)
		return parser;
	return this.parserCache[ident] = this.<span class="apidocCodeKeywordSpan">createParser</span>(parserOptions);
};

NormalModuleFactory.prototype.createParser = function createParser(parserOptions) {
	var parser = new Parser();
	this.applyPlugins2("parser", parser, parserOptions || {});
	return parser;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NormalModuleFactory.prototype.getParser" id="apidoc.element.webpack.NormalModuleFactory.prototype.getParser">
        function <span class="apidocSignatureSpan">webpack.NormalModuleFactory.prototype.</span>getParser
        <span class="apidocSignatureSpan">(parserOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getParser(parserOptions) {
	var ident = "null";
	if(parserOptions) {
		if(parserOptions.ident)
			ident = parserOptions.ident;
		else
			ident = JSON.stringify(parserOptions);
	}
	var parser = this.parserCache[ident];
	if(parser)
		return parser;
	return this.parserCache[ident] = this.createParser(parserOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						request: loaders.map(loaderToIdent).concat([resource]).join("!"),
						dependencies: data.dependencies,
						userRequest: userRequest,
						rawRequest: request,
						loaders: loaders,
						resource: resource,
						resourceResolveData: resourceResolveData,
						parser: _this.<span class="apidocCodeKeywordSpan">getParser</span>(settings.parser)
					});
				}
			});
		};
	});
}
module.exports = NormalModuleFactory;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.NormalModuleFactory.prototype.resolveRequestArray" id="apidoc.element.webpack.NormalModuleFactory.prototype.resolveRequestArray">
        function <span class="apidocSignatureSpan">webpack.NormalModuleFactory.prototype.</span>resolveRequestArray
        <span class="apidocSignatureSpan">(contextInfo, context, array, resolver, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveRequestArray(contextInfo, context, array, resolver, callback) {
	if(array.length === 0) return callback(null, []);
	async.map(array, function(item, callback) {
		resolver.resolve(contextInfo, context, item.loader, function(err, result) {
			if(err &amp;&amp; /^[^/]*$/.test(item.loader) &amp;&amp; !/-loader$/.test(item.loader)) {
				return resolver.resolve(contextInfo, context, item.loader + "-loader", function(err2) {
					if(!err2) {
						err.message = err.message + "\n" +
							"BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\n" +
							"                 You need to specify '" + item.loader + "-loader' instead of '" + item.loader + "',\n" +
							"                 see https://webpack.js.org/guides/migrating/#automatic-loader-module-name-extension-removed";
					}
					callback(err);
				});
			}
			if(err) return callback(err);

			var optionsOnly = item.options ? {
				options: item.options
			} : undefined;
			return callback(null, Object.assign({}, item, identToLoaderRequest(result), optionsOnly));
		});
	}, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			var noPostAutoLoaders = /^-!/.test(request);
			var elements = request.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!");
			var resource = elements.pop();
			elements = elements.map(identToLoaderRequest);

			async.parallel([
				function(callback) {
					_this.<span class="apidocCodeKeywordSpan">resolveRequestArray</span>(resolveContextInfo, context, elements, _this.resolvers
.loader, callback);
				},
				function(callback) {
					if(resource === "" || resource[0] === "?")
						return callback(null, {
							resource: resource
						});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Parser" id="apidoc.module.webpack.Parser">module webpack.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Parser.Parser" id="apidoc.element.webpack.Parser.Parser">
        function <span class="apidocSignatureSpan">webpack.</span>Parser
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options) {
	Tapable.call(this);
	this.options = options;
	this.initializeEvaluating();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.Parser.prototype" id="apidoc.module.webpack.Parser.prototype">module webpack.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.constructor" id="apidoc.element.webpack.Parser.prototype.constructor">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options) {
	Tapable.call(this);
	this.options = options;
	this.initializeEvaluating();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.enterArrayPattern" id="apidoc.element.webpack.Parser.prototype.enterArrayPattern">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterArrayPattern
        <span class="apidocSignatureSpan">(pattern, onIdent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enterArrayPattern(pattern, onIdent) {
	for(var elementIndex = 0, len = pattern.elements.length; elementIndex &lt; len; elementIndex++) {
		var element = pattern.elements[elementIndex];
		this.enterPattern(element, onIdent);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.enterAssignmentPattern" id="apidoc.element.webpack.Parser.prototype.enterAssignmentPattern">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterAssignmentPattern
        <span class="apidocSignatureSpan">(pattern, onIdent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enterAssignmentPattern(pattern, onIdent) {
	this.enterPattern(pattern.left, onIdent);
	this.walkExpression(pattern.right);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.enterIdentifier" id="apidoc.element.webpack.Parser.prototype.enterIdentifier">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterIdentifier
        <span class="apidocSignatureSpan">(pattern, onIdent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enterIdentifier(pattern, onIdent) {
	onIdent(pattern.name, pattern);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.enterObjectPattern" id="apidoc.element.webpack.Parser.prototype.enterObjectPattern">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterObjectPattern
        <span class="apidocSignatureSpan">(pattern, onIdent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enterObjectPattern(pattern, onIdent) {
	for(var propIndex = 0, len = pattern.properties.length; propIndex &lt; len; propIndex++) {
		var prop = pattern.properties[propIndex];
		this.enterPattern(prop.value, onIdent);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.enterPattern" id="apidoc.element.webpack.Parser.prototype.enterPattern">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterPattern
        <span class="apidocSignatureSpan">(pattern, onIdent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enterPattern(pattern, onIdent) {
	if(pattern &amp;&amp; this["enter" + pattern.type])
		this["enter" + pattern.type](pattern, onIdent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					if(!_this.applyPluginsBailResult1("rename " + renameIdentifier, declarator.init)) {
						_this.scope.renames["$" + declarator.id.name] = _this.scope.renames["$" + renameIdentifier] || renameIdentifier
;
						var idx = _this.scope.definitions.indexOf(declarator.id.name);
						if(idx &gt;= 0) _this.scope.definitions.splice(idx, 1);
					}
				} else {
					_this.walkPattern(declarator.id);
					_this.<span class="apidocCodeKeywordSpan">enterPattern</span>(declarator.id, function(name, decl) {
						if(!_this.applyPluginsBailResult1("var " + name, decl)) {
							_this.scope.renames["$" + name] = undefined;
							_this.scope.definitions.push(name);
						}
					});
					if(declarator.init)
						_this.walkExpression(declarator.init);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.enterRestElement" id="apidoc.element.webpack.Parser.prototype.enterRestElement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>enterRestElement
        <span class="apidocSignatureSpan">(pattern, onIdent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enterRestElement(pattern, onIdent) {
	this.enterPattern(pattern.argument, onIdent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.evaluate" id="apidoc.element.webpack.Parser.prototype.evaluate">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>evaluate
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function evaluate(source) {
	var ast = acorn.parse("(" + source + ")", {
		ranges: true,
		locations: true,
		ecmaVersion: 2017,
		sourceType: "module",
		plugins: {
			dynamicImport: true
		}
	});
	if(!ast || typeof ast !== "object" || ast.type !== "Program")
		throw new Error("evaluate: Source couldn't be parsed");
	if(ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement")
		throw new Error("evaluate: Source is not a expression");
	return this.evaluateExpression(ast.body[0].expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
							 * e.g.: new DefinePlugin({
							 * "a": "b",
							 * "b": "a"
							 * });
							 */
							if(recurse) return;
							recurse = true;
							const res = parser.<span class="apidocCodeKeywordSpan">evaluate</span>(code);
							recurse = false;
							res.setRange(expr.range);
							return res;
						});
						parser.plugin("expression " + key, ParserHelpers.toConstantDependency(code));
					}
					const typeofCode = isTypeof ? code : "typeof (" + code + ")";
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.evaluateExpression" id="apidoc.element.webpack.Parser.prototype.evaluateExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>evaluateExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function evaluateExpression(expression) {
	try {
		var result = this.applyPluginsBailResult1("evaluate " + expression.type, expression);
		if(result !== undefined)
			return result;
	} catch(e) {
		console.warn(e);
		// ignore error
	}
	return new BasicEvaluatedExpression().setRange(expression.range);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

				if(typeof parserOptions.browserify !== "undefined" &amp;&amp; !parserOptions.browserify)
					return;

				parser.plugin("call require", (expr) =&gt; {
					// support for browserify style require delegator: "require(o, !0)"
					if(expr.arguments.length !== 2) return;
					const second = parser.<span class="apidocCodeKeywordSpan">evaluateExpression</span>(expr.arguments[1]);
					if(!second.isBoolean()) return;
					if(second.asBool() !== true) return;
					const dep = new ConstDependency("require", expr.callee.range);
					dep.loc = expr.loc;
					if(parser.state.current.dependencies.length &gt; 1) {
						const last = parser.state.current.dependencies[parser.state.current.dependencies.length - 1];
						if(last.critical &amp;&amp; last.request === "." &amp;&amp; last.userRequest === "." &amp;&amp;
last.recursive)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.getRenameIdentifier" id="apidoc.element.webpack.Parser.prototype.getRenameIdentifier">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>getRenameIdentifier
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRenameIdentifier(expr) {
	var result = this.evaluateExpression(expr);
	if(!result) return;
	if(result.isIdentifier()) return result.identifier;
	return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Parser.prototype.walkVariableDeclarators = function walkVariableDeclarators(declarators) {
	var _this = this;
	declarators.forEach(function(declarator) {
		switch(declarator.type) {
			case "VariableDeclarator":
				var renameIdentifier = declarator.init &amp;&amp; _this.<span class="apidocCodeKeywordSpan">getRenameIdentifier</span>(declarator
.init);
				if(renameIdentifier &amp;&amp; declarator.id.type === "Identifier" &amp;&amp; _this.applyPluginsBailResult1(&amp;#
x22;can-rename " + renameIdentifier, declarator.init)) {
					// renaming with "var a = b;"
					if(!_this.applyPluginsBailResult1("rename " + renameIdentifier, declarator.init)) {
						_this.scope.renames["$" + declarator.id.name] = _this.scope.renames["$" + renameIdentifier] || renameIdentifier
;
						var idx = _this.scope.definitions.indexOf(declarator.id.name);
						if(idx &gt;= 0) _this.scope.definitions.splice(idx, 1);
					}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.inScope" id="apidoc.element.webpack.Parser.prototype.inScope">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>inScope
        <span class="apidocSignatureSpan">(params, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inScope(params, fn) {
	var oldScope = this.scope;
	var _this = this;
	this.scope = {
		inTry: false,
		inShorthand: false,
		definitions: oldScope.definitions.slice(),
		renames: Object.create(oldScope.renames)
	};

	for(var paramIndex = 0, len = params.length; paramIndex &lt; len; paramIndex++) {
		var param = params[paramIndex];

		if(typeof param !== "string") {
			_this.enterPattern(param, function(param) {
				_this.scope.renames["$" + param] = undefined;
				_this.scope.definitions.push(param);
			});
		} else {
			_this.scope.renames["$" + param] = undefined;
			_this.scope.definitions.push(param);
		}
	}

	fn();
	_this.scope = oldScope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	this.walkStatement(statement.body);
};

// Declarations
Parser.prototype.walkFunctionDeclaration = function walkFunctionDeclaration(statement) {
	this.scope.renames["$" + statement.id.name] = undefined;
	this.scope.definitions.push(statement.id.name);
	this.<span class="apidocCodeKeywordSpan">inScope</span>(statement.params, function() {
		if(statement.body.type === "BlockStatement")
			this.walkStatement(statement.body);
		else
			this.walkExpression(statement.body);
	}.bind(this));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.initializeEvaluating" id="apidoc.element.webpack.Parser.prototype.initializeEvaluating">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>initializeEvaluating
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeEvaluating = function () {
	function joinRanges(startRange, endRange) {
		if(!endRange) return startRange;
		if(!startRange) return endRange;
		return [startRange[0], endRange[1]];
	}
	this.plugin("evaluate Literal", function(expr) {
		switch(typeof expr.value) {
			case "number":
				return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);
			case "string":
				return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);
			case "boolean":
				return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);
		}
		if(expr.value === null)
			return new BasicEvaluatedExpression().setNull().setRange(expr.range);
		if(expr.value instanceof RegExp)
			return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);
	});
	this.plugin("evaluate LogicalExpression", function(expr) {
		var left;
		var leftAsBool;
		var right;
		if(expr.operator === "&amp;&amp;") {
			left = this.evaluateExpression(expr.left);
			leftAsBool = left &amp;&amp; left.asBool();
			if(leftAsBool === false) return left.setRange(expr.range);
			if(leftAsBool !== true) return;
			right = this.evaluateExpression(expr.right);
			return right.setRange(expr.range);
		} else if(expr.operator === "||") {
			left = this.evaluateExpression(expr.left);
			leftAsBool = left &amp;&amp; left.asBool();
			if(leftAsBool === true) return left.setRange(expr.range);
			if(leftAsBool !== false) return;
			right = this.evaluateExpression(expr.right);
			return right.setRange(expr.range);
		}
	});
	this.plugin("evaluate BinaryExpression", function(expr) {
		var left;
		var right;
		var res;
		if(expr.operator === "+") {
			left = this.evaluateExpression(expr.left);
			right = this.evaluateExpression(expr.right);
			if(!left || !right) return;
			res = new BasicEvaluatedExpression();
			if(left.isString()) {
				if(right.isString()) {
					res.setString(left.string + right.string);
				} else if(right.isNumber()) {
					res.setString(left.string + right.number);
				} else if(right.isWrapped() &amp;&amp; right.prefix &amp;&amp; right.prefix.isString()) {
					res.setWrapped(
						new BasicEvaluatedExpression()
						.setString(left.string + right.prefix.string)
						.setRange(joinRanges(left.range, right.prefix.range)),
						right.postfix);
				} else {
					res.setWrapped(left, null);
				}
			} else if(left.isNumber()) {
				if(right.isString()) {
					res.setString(left.number + right.string);
				} else if(right.isNumber()) {
					res.setNumber(left.number + right.number);
				}
			} else if(left.isWrapped()) {
				if(left.postfix &amp;&amp; left.postfix.isString() &amp;&amp; right.isString()) {
					res.setWrapped(left.prefix,
						new BasicEvaluatedExpression()
						.setString(left.postfix.string + right.string)
						.setRange(joinRanges(left.postfix.range, right.range))
					);
				} else if(left.postfix &amp;&amp; left.postfix.isString() &amp;&amp; right.isNumber()) {
					res.setWrapped(left.prefix,
						new BasicEvaluatedExpression()
						.setString(left.postfix.string + right.number)
						.setRange(joinRanges(left.postfix.range, right.range))
					);
				} else if(right.isString()) {
					res.setWrapped(left.prefix, right);
				} else if(right.isNumber()) {
					res.setWrapped(left.prefix,
						new BasicEvaluatedExpression()
						.setString(right.number + "")
						.setRange(right.range));
				} else {
					res.setWrapped(left.prefix, new BasicEvaluatedExpression());
				}
			} else {
				if(right.isString()) {
					res.setWrapped(null, right);
				}
			}
			res.setRange(expr.range);
			return res;
		} else if(expr.operator === "-") {
			left = this.evaluateExpression(expr.left);
			right = this.evaluateExpression(expr.right);
			if(!left || !right) return;
			if(!left.isNumber() || !right.isNumber()) return;
			res = new BasicEvaluatedExpression();
			res.setNumber(left.number - right.number);
			res.setRange(expr.range);
			return res;
		} else if(expr.operator === "*") {
			left = this.evaluateExpression(expr.left);
			right = this.evaluateExpressio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var acorn = require("acorn-dynamic-import").default;
var Tapable = require("tapable");
var BasicEvaluatedExpression = require("./BasicEvaluatedExpression");

function Parser(options) {
	Tapable.call(this);
	this.options = options;
	this.<span class="apidocCodeKeywordSpan">initializeEvaluating</span>();
}
module.exports = Parser;

// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API

Parser.prototype = Object.create(Tapable.prototype);
Parser.prototype.constructor = Parser;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.isHoistedStatement" id="apidoc.element.webpack.Parser.prototype.isHoistedStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>isHoistedStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isHoistedStatement(statement) {
	switch(statement.type) {
		case "ImportDeclaration":
		case "ExportAllDeclaration":
		case "ExportNamedDeclaration":
			return true;
	}
	return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if(methodDefinition.value)
		this.walkExpression(methodDefinition.value);
};

Parser.prototype.walkStatements = function walkStatements(statements) {
	for(var indexA = 0, lenA = statements.length; indexA &lt; lenA; indexA++) {
		var statementA = statements[indexA];
		if(this.<span class="apidocCodeKeywordSpan">isHoistedStatement</span>(statementA))
			this.walkStatement(statementA);
	}
	for(var indexB = 0, lenB = statements.length; indexB &lt; lenB; indexB++) {
		var statementB = statements[indexB];
		if(!this.isHoistedStatement(statementB))
			this.walkStatement(statementB);
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.parse" id="apidoc.element.webpack.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">(source, initialState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(source, initialState) {
	var ast, comments = [];
	for(var i = 0, len = POSSIBLE_AST_OPTIONS.length; i &lt; len; i++) {
		if(!ast) {
			try {
				comments.length = 0;
				POSSIBLE_AST_OPTIONS[i].onComment = comments;
				ast = acorn.parse(source, POSSIBLE_AST_OPTIONS[i]);
			} catch(e) {
				// ignore the error
			}
		}
	}
	if(!ast) {
		// for the error
		ast = acorn.parse(source, {
			ranges: true,
			locations: true,
			ecmaVersion: 2017,
			sourceType: "module",
			plugins: {
				dynamicImport: true
			},
			onComment: comments
		});
	}
	if(!ast || typeof ast !== "object")
		throw new Error("Source couldn't be parsed");
	var oldScope = this.scope;
	var oldState = this.state;
	this.scope = {
		inTry: false,
		definitions: [],
		renames: {}
	};
	var state = this.state = initialState || {};
	if(this.applyPluginsBailResult("program", ast, comments) === undefined)
		this.walkStatements(ast.body);
	this.scope = oldScope;
	this.state = oldState;
	return state;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		compiler.plugin("before-compile", (params, callback) =&gt; {
			const manifest = this.options.manifest;
			if(typeof manifest === "string") {
				params.compilationDependencies.push(manifest);
				compiler.inputFileSystem.readFile(manifest, function(err, result) {
					if(err) return callback(err);
					params["dll reference " + manifest] = JSON.<span class="apidocCodeKeywordSpan">parse</span>(result.toString("
;utf-8"));
					return callback();
				});
			} else {
				return callback();
			}
		});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.parseCalculatedString" id="apidoc.element.webpack.Parser.prototype.parseCalculatedString">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>parseCalculatedString
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseCalculatedString(expression) {
	switch(expression.type) {
		case "BinaryExpression":
			if(expression.operator === "+") {
				var left = this.parseCalculatedString(expression.left);
				var right = this.parseCalculatedString(expression.right);
				if(left.code) {
					return {
						range: left.range,
						value: left.value,
						code: true
					};
				} else if(right.code) {
					return {
						range: [left.range[0], right.range ? right.range[1] : left.range[1]],
						value: left.value + right.value,
						code: true
					};
				} else {
					return {
						range: [left.range[0], right.range[1]],
						value: left.value + right.value
					};
				}
			}
			break;
		case "ConditionalExpression":
			var consequent = this.parseCalculatedString(expression.consequent);
			var alternate = this.parseCalculatedString(expression.alternate);
			var items = [];
			if(consequent.conditional)
				Array.prototype.push.apply(items, consequent.conditional);
			else if(!consequent.code)
				items.push(consequent);
			else break;
			if(alternate.conditional)
				Array.prototype.push.apply(items, alternate.conditional);
			else if(!alternate.code)
				items.push(alternate);
			else break;
			return {
				value: "",
				code: true,
				conditional: items
			};
		case "Literal":
			return {
				range: expression.range,
				value: expression.value + ""
			};
	}
	return {
		value: "",
		code: true
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	throw new Error(expression.type + " is not supported as parameter for require");
};

Parser.prototype.parseCalculatedString = function parseCalculatedString(expression) {
	switch(expression.type) {
		case "BinaryExpression":
			if(expression.operator === "+") {
				var left = this.<span class="apidocCodeKeywordSpan">parseCalculatedString</span>(expression.left);
				var right = this.parseCalculatedString(expression.right);
				if(left.code) {
					return {
						range: left.range,
						value: left.value,
						code: true
					};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.parseCalculatedStringArray" id="apidoc.element.webpack.Parser.prototype.parseCalculatedStringArray">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>parseCalculatedStringArray
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseXXXArray(expression) {
		switch(expression.type) {
			case "ArrayExpression":
				var arr = [];
				if(expression.elements)
					expression.elements.forEach(function(expr) {
						arr.push(this[fn](expr));
					}, this);
				return arr;
		}
		return [this[fn](expression)];
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.parseString" id="apidoc.element.webpack.Parser.prototype.parseString">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>parseString
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseString(expression) {
	switch(expression.type) {
		case "BinaryExpression":
			if(expression.operator === "+")
				return this.parseString(expression.left) + this.parseString(expression.right);
			break;
		case "Literal":
			return expression.value + "";
	}
	throw new Error(expression.type + " is not supported as parameter for require");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	return new BasicEvaluatedExpression().setRange(expression.range);
};

Parser.prototype.parseString = function parseString(expression) {
	switch(expression.type) {
		case "BinaryExpression":
			if(expression.operator === "+")
				return this.<span class="apidocCodeKeywordSpan">parseString</span>(expression.left) + this.parseString(expression.right);
			break;
		case "Literal":
			return expression.value + "";
	}
	throw new Error(expression.type + " is not supported as parameter for require");
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.parseStringArray" id="apidoc.element.webpack.Parser.prototype.parseStringArray">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>parseStringArray
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseXXXArray(expression) {
		switch(expression.type) {
			case "ArrayExpression":
				var arr = [];
				if(expression.elements)
					expression.elements.forEach(function(expr) {
						arr.push(this[fn](expr));
					}, this);
				return arr;
		}
		return [this[fn](expression)];
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkArrayExpression" id="apidoc.element.webpack.Parser.prototype.walkArrayExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkArrayExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkArrayExpression(expression) {
	if(expression.elements)
		this.walkExpressions(expression.elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkArrayPattern" id="apidoc.element.webpack.Parser.prototype.walkArrayPattern">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkArrayPattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkArrayPattern(pattern) {
	for(var i = 0, len = pattern.elements.length; i &lt; len; i++) {
		var element = pattern.elements[i];
		if(element)
			this.walkPattern(element);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkArrowFunctionExpression" id="apidoc.element.webpack.Parser.prototype.walkArrowFunctionExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkArrowFunctionExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkArrowFunctionExpression(expression) {
	this.inScope(expression.params, function() {
		if(expression.body.type === "BlockStatement")
			this.walkStatement(expression.body);
		else
			this.walkExpression(expression.body);
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkAssignmentExpression" id="apidoc.element.webpack.Parser.prototype.walkAssignmentExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkAssignmentExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkAssignmentExpression(expression) {
	var renameIdentifier = this.getRenameIdentifier(expression.right);
	if(expression.left.type === "Identifier" &amp;&amp; renameIdentifier &amp;&amp; this.applyPluginsBailResult1("can-rename " + renameIdentifier,
expression.right)) {
		// renaming "a = b;"
		if(!this.applyPluginsBailResult1("rename " + renameIdentifier, expression.right)) {
			this.scope.renames["$" + expression.left.name] = renameIdentifier;
			var idx = this.scope.definitions.indexOf(expression.left.name);
			if(idx &gt;= 0) this.scope.definitions.splice(idx, 1);
		}
	} else if(expression.left.type === "Identifier") {
		if(!this.applyPluginsBailResult1("assigned " + expression.left.name, expression)) {
			this.walkExpression(expression.right);
		}
		this.scope.renames["$" + expression.left.name] = undefined;
		if(!this.applyPluginsBailResult1("assign " + expression.left.name, expression)) {
			this.walkExpression(expression.left);
		}
	} else {
		this.walkExpression(expression.right);
		this.scope.renames["$" + expression.left.name] = undefined;
		this.walkExpression(expression.left);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkAwaitExpression" id="apidoc.element.webpack.Parser.prototype.walkAwaitExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkAwaitExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkAwaitExpression(expression) {
	var argument = expression.argument;
	if(this["walk" + argument.type])
		return this["walk" + argument.type](argument);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkBinaryExpression" id="apidoc.element.webpack.Parser.prototype.walkBinaryExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkBinaryExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkLeftRightExpression(expression) {
		this.walkExpression(expression.left);
		this.walkExpression(expression.right);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkBlockStatement" id="apidoc.element.webpack.Parser.prototype.walkBlockStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkBlockStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkBlockStatement(statement) {
	this.walkStatements(statement.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkCallExpression" id="apidoc.element.webpack.Parser.prototype.walkCallExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkCallExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkCallExpression(expression) {
	var result;

	function walkIIFE(functionExpression, options) {
		var params = functionExpression.params;
		var args = options.map(function(arg) {
			var renameIdentifier = this.getRenameIdentifier(arg);
			if(renameIdentifier &amp;&amp; this.applyPluginsBailResult1("can-rename " + renameIdentifier, arg)) {
				if(!this.applyPluginsBailResult1("rename " + renameIdentifier, arg))
					return renameIdentifier;
			}
			this.walkExpression(arg);
		}, this);
		this.inScope(params.filter(function(identifier, idx) {
			return !args[idx];
		}), function() {
			for(var i = 0; i &lt; args.length; i++) {
				var param = args[i];
				if(!param) continue;
				if(!params[i] || params[i].type !== "Identifier") continue;
				this.scope.renames["$" + params[i].name] = param;
			}
			if(functionExpression.body.type === "BlockStatement")
				this.walkStatement(functionExpression.body);
			else
				this.walkExpression(functionExpression.body);
		}.bind(this));
	}
	if(expression.callee.type === "MemberExpression" &amp;&amp;
		expression.callee.object.type === "FunctionExpression" &amp;&amp;
		!expression.callee.computed &amp;&amp;
		(["call", "bind"]).indexOf(expression.callee.property.name) &gt;= 0 &amp;&amp;
		expression.arguments &amp;&amp;
		expression.arguments.length &gt; 1
	) {
		// (function(...) { }.call/bind(?, ...))
		walkIIFE.call(this, expression.callee.object, expression.arguments.slice(1));
		this.walkExpression(expression.arguments[0]);
	} else if(expression.callee.type === "FunctionExpression" &amp;&amp; expression.arguments) {
		// (function(...) { }(...))
		walkIIFE.call(this, expression.callee, expression.arguments);
	} else if(expression.callee.type === "Import") {
		result = this.applyPluginsBailResult1("import-call", expression);
		if(result === true)
			return;

		if(expression.arguments)
			this.walkExpressions(expression.arguments);
	} else {

		var callee = this.evaluateExpression(expression.callee);
		if(callee.isIdentifier()) {
			result = this.applyPluginsBailResult1("call " + callee.identifier, expression);
			if(result === true)
				return;
		}

		if(expression.callee)
			this.walkExpression(expression.callee);
		if(expression.arguments)
			this.walkExpressions(expression.arguments);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkCatchClause" id="apidoc.element.webpack.Parser.prototype.walkCatchClause">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkCatchClause
        <span class="apidocSignatureSpan">(catchClause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkCatchClause(catchClause) {
	if(catchClause.guard)
		this.walkExpression(catchClause.guard);
	this.inScope([catchClause.param], function() {
		this.walkStatement(catchClause.body);
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.walkStatement(statement.block);
	} else {
		this.scope.inTry = true;
		this.walkStatement(statement.block);
		this.scope.inTry = false;
	}
	if(statement.handler)
		this.<span class="apidocCodeKeywordSpan">walkCatchClause</span>(statement.handler);
	if(statement.finalizer)
		this.walkStatement(statement.finalizer);
};

Parser.prototype.walkWhileStatement =
	Parser.prototype.walkDoWhileStatement = function walkLoopStatement(statement) {
		this.walkExpression(statement.test);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkClass" id="apidoc.element.webpack.Parser.prototype.walkClass">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkClass
        <span class="apidocSignatureSpan">(classy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkClass(classy) {
	if(classy.superClass)
		this.walkExpression(classy.superClass);
	if(classy.body &amp;&amp; classy.body.type === "ClassBody") {
		classy.body.body.forEach(function(methodDefinition) {
			if(methodDefinition.type === "MethodDefinition")
				this.walkMethodDefinition(methodDefinition);
		}, this);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if(statement.declarations)
		this.walkVariableDeclarators(statement.declarations);
};

Parser.prototype.walkClassDeclaration = function walkClassDeclaration(statement) {
	this.scope.renames["$" + statement.id.name] = undefined;
	this.scope.definitions.push(statement.id.name);
	this.<span class="apidocCodeKeywordSpan">walkClass</span>(statement);
};

Parser.prototype.walkSwitchCases = function walkSwitchCases(switchCases) {
	for(var index = 0, len = switchCases.length; index &lt; len; index++) {
		var switchCase = switchCases[index];

		if(switchCase.test) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkClassDeclaration" id="apidoc.element.webpack.Parser.prototype.walkClassDeclaration">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkClassDeclaration
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkClassDeclaration(statement) {
	this.scope.renames["$" + statement.id.name] = undefined;
	this.scope.definitions.push(statement.id.name);
	this.walkClass(statement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkClassExpression" id="apidoc.element.webpack.Parser.prototype.walkClassExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkClassExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkClassExpression(expression) {
	this.walkClass(expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkConditionalExpression" id="apidoc.element.webpack.Parser.prototype.walkConditionalExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkConditionalExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkConditionalExpression(expression) {
	var result = this.applyPluginsBailResult1("expression ?:", expression);
	if(result === undefined) {
		this.walkExpression(expression.test);
		this.walkExpression(expression.consequent);
		if(expression.alternate)
			this.walkExpression(expression.alternate);
	} else {
		if(result)
			this.walkExpression(expression.consequent);
		else if(expression.alternate)
			this.walkExpression(expression.alternate);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkDoWhileStatement" id="apidoc.element.webpack.Parser.prototype.walkDoWhileStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkDoWhileStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkLoopStatement(statement) {
		this.walkExpression(statement.test);
		this.walkStatement(statement.body);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkExportAllDeclaration" id="apidoc.element.webpack.Parser.prototype.walkExportAllDeclaration">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExportAllDeclaration
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkExportAllDeclaration(statement) {
	var source = statement.source.value;
	this.applyPluginsBailResult("export import", statement, source);
	this.applyPluginsBailResult("export import specifier", statement, source, null, null, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkExportDefaultDeclaration" id="apidoc.element.webpack.Parser.prototype.walkExportDefaultDeclaration">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExportDefaultDeclaration
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkExportDefaultDeclaration(statement) {
	this.applyPluginsBailResult1("export", statement);
	if(/Declaration$/.test(statement.declaration.type)) {
		if(!this.applyPluginsBailResult("export declaration", statement, statement.declaration)) {
			var pos = this.scope.definitions.length;
			this.walkStatement(statement.declaration);
			var newDefs = this.scope.definitions.slice(pos);
			for(var index = 0, len = newDefs.length; index &lt; len; index++) {
				var def = newDefs[index];
				this.applyPluginsBailResult("export specifier", statement, def, "default");
			}
		}
	} else {
		this.walkExpression(statement.declaration);
		if(!this.applyPluginsBailResult("export expression", statement, statement.declaration)) {
			this.applyPluginsBailResult("export specifier", statement, statement.declaration, "default");
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkExportNamedDeclaration" id="apidoc.element.webpack.Parser.prototype.walkExportNamedDeclaration">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExportNamedDeclaration
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkExportNamedDeclaration(statement) {
	if(statement.source) {
		var source = statement.source.value;
		this.applyPluginsBailResult("export import", statement, source);
	} else {
		this.applyPluginsBailResult1("export", statement);
	}
	if(statement.declaration) {
		if(/Expression$/.test(statement.declaration.type)) {
			throw new Error("Doesn't occur?");
		} else {
			if(!this.applyPluginsBailResult("export declaration", statement, statement.declaration)) {
				var pos = this.scope.definitions.length;
				this.walkStatement(statement.declaration);
				var newDefs = this.scope.definitions.slice(pos);
				for(var index = newDefs.length - 1; index &gt;= 0; index--) {
					var def = newDefs[index];
					this.applyPluginsBailResult("export specifier", statement, def, def, index);
				}
			}
		}
	}
	if(statement.specifiers) {
		for(var specifierIndex = 0; specifierIndex &lt; statement.specifiers.length; specifierIndex++) {
			var specifier = statement.specifiers[specifierIndex];
			switch(specifier.type) {
				case "ExportSpecifier":
					var name = specifier.exported.name;
					if(source)
						this.applyPluginsBailResult("export import specifier", statement, source, specifier.local.name, name, specifierIndex);
					else
						this.applyPluginsBailResult("export specifier", statement, specifier.local.name, name, specifierIndex);
					break;
			}
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkExpression" id="apidoc.element.webpack.Parser.prototype.walkExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkExpression(expression) {
	if(this["walk" + expression.type])
		return this["walk" + expression.type](expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if(!result) return;
	if(result.isIdentifier()) return result.identifier;
	return;
};

Parser.prototype.walkClass = function walkClass(classy) {
	if(classy.superClass)
		this.<span class="apidocCodeKeywordSpan">walkExpression</span>(classy.superClass);
	if(classy.body &amp;&amp; classy.body.type === "ClassBody") {
		classy.body.body.forEach(function(methodDefinition) {
			if(methodDefinition.type === "MethodDefinition")
				this.walkMethodDefinition(methodDefinition);
		}, this);
	}
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkExpressionStatement" id="apidoc.element.webpack.Parser.prototype.walkExpressionStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExpressionStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkExpressionStatement(statement) {
	this.walkExpression(statement.expression);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkExpressions" id="apidoc.element.webpack.Parser.prototype.walkExpressions">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkExpressions
        <span class="apidocSignatureSpan">(expressions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkExpressions(expressions) {
	for(var expressionsIndex = 0, len = expressions.length; expressionsIndex &lt; len; expressionsIndex++) {
		var expression = expressions[expressionsIndex];
		if(expression)
			this.walkExpression(expression);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var argument = expression.argument;
	if(this["walk" + argument.type])
		return this["walk" + argument.type](argument);
};

Parser.prototype.walkArrayExpression = function walkArrayExpression(expression) {
	if(expression.elements)
		this.<span class="apidocCodeKeywordSpan">walkExpressions</span>(expression.elements);
};

Parser.prototype.walkSpreadElement = function walkSpreadElement(expression) {
	if(expression.argument)
		this.walkExpression(expression.argument);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkForInStatement" id="apidoc.element.webpack.Parser.prototype.walkForInStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkForInStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkForInStatement(statement) {
	if(statement.left.type === "VariableDeclaration")
		this.walkStatement(statement.left);
	else
		this.walkExpression(statement.left);
	this.walkExpression(statement.right);
	this.walkStatement(statement.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkForOfStatement" id="apidoc.element.webpack.Parser.prototype.walkForOfStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkForOfStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkForOfStatement(statement) {
	if(statement.left.type === "VariableDeclaration")
		this.walkStatement(statement.left);
	else
		this.walkExpression(statement.left);
	this.walkExpression(statement.right);
	this.walkStatement(statement.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkForStatement" id="apidoc.element.webpack.Parser.prototype.walkForStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkForStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkForStatement(statement) {
	if(statement.init) {
		if(statement.init.type === "VariableDeclaration")
			this.walkStatement(statement.init);
		else
			this.walkExpression(statement.init);
	}
	if(statement.test)
		this.walkExpression(statement.test);
	if(statement.update)
		this.walkExpression(statement.update);
	this.walkStatement(statement.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkFunctionDeclaration" id="apidoc.element.webpack.Parser.prototype.walkFunctionDeclaration">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkFunctionDeclaration
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkFunctionDeclaration(statement) {
	this.scope.renames["$" + statement.id.name] = undefined;
	this.scope.definitions.push(statement.id.name);
	this.inScope(statement.params, function() {
		if(statement.body.type === "BlockStatement")
			this.walkStatement(statement.body);
		else
			this.walkExpression(statement.body);
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkFunctionExpression" id="apidoc.element.webpack.Parser.prototype.walkFunctionExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkFunctionExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkFunctionExpression(expression) {
	this.inScope(expression.params, function() {
		if(expression.body.type === "BlockStatement")
			this.walkStatement(expression.body);
		else
			this.walkExpression(expression.body);
	}.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkIdentifier" id="apidoc.element.webpack.Parser.prototype.walkIdentifier">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkIdentifier
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkIdentifier(expression) {
	if(this.scope.definitions.indexOf(expression.name) === -1) {
		var result = this.applyPluginsBailResult1("expression " + (this.scope.renames["$" + expression.name] || expression.name), expression
);
		if(result === true)
			return;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkIfStatement" id="apidoc.element.webpack.Parser.prototype.walkIfStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkIfStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkIfStatement(statement) {
	var result = this.applyPluginsBailResult1("statement if", statement);
	if(result === undefined) {
		this.walkExpression(statement.test);
		this.walkStatement(statement.consequent);
		if(statement.alternate)
			this.walkStatement(statement.alternate);
	} else {
		if(result)
			this.walkStatement(statement.consequent);
		else if(statement.alternate)
			this.walkStatement(statement.alternate);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkImportDeclaration" id="apidoc.element.webpack.Parser.prototype.walkImportDeclaration">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkImportDeclaration
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkImportDeclaration(statement) {
	var source = statement.source.value;
	this.applyPluginsBailResult("import", statement, source);
	statement.specifiers.forEach(function(specifier) {
		var name = specifier.local.name;
		this.scope.renames["$" + name] = undefined;
		this.scope.definitions.push(name);
		switch(specifier.type) {
			case "ImportDefaultSpecifier":
				this.applyPluginsBailResult("import specifier", statement, source, "default", name);
				break;
			case "ImportSpecifier":
				this.applyPluginsBailResult("import specifier", statement, source, specifier.imported.name, name);
				break;
			case "ImportNamespaceSpecifier":
				this.applyPluginsBailResult("import specifier", statement, source, null, name);
				break;
		}
	}, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkLabeledStatement" id="apidoc.element.webpack.Parser.prototype.walkLabeledStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkLabeledStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkLabeledStatement(statement) {
	var result = this.applyPluginsBailResult1("label " + statement.label.name, statement);
	if(result !== true)
		this.walkStatement(statement.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkLogicalExpression" id="apidoc.element.webpack.Parser.prototype.walkLogicalExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkLogicalExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkLeftRightExpression(expression) {
		this.walkExpression(expression.left);
		this.walkExpression(expression.right);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkMemberExpression" id="apidoc.element.webpack.Parser.prototype.walkMemberExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkMemberExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkMemberExpression(expression) {
	var expr = expression;
	var exprName = [];
	while(expr.type === "MemberExpression" &amp;&amp;
		expr.property.type === (expr.computed ? "Literal" : "Identifier")
	) {
		exprName.unshift(expr.property.name || expr.property.value);
		expr = expr.object;
	}
	if(expr.type === "Identifier" &amp;&amp; this.scope.definitions.indexOf(expr.name) === -1) {
		exprName.unshift(this.scope.renames["$" + expr.name] || expr.name);
		var result = this.applyPluginsBailResult1("expression " + exprName.join("."), expression);
		if(result === true)
			return;
		exprName[exprName.length - 1] = "*";
		result = this.applyPluginsBailResult1("expression " + exprName.join("."), expression);
		if(result === true)
			return;
	}
	this.walkExpression(expression.object);
	if(expression.computed === true)
		this.walkExpression(expression.property);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkMethodDefinition" id="apidoc.element.webpack.Parser.prototype.walkMethodDefinition">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkMethodDefinition
        <span class="apidocSignatureSpan">(methodDefinition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkMethodDefinition(methodDefinition) {
	if(methodDefinition.computed &amp;&amp; methodDefinition.key)
		this.walkExpression(methodDefinition.key);
	if(methodDefinition.value)
		this.walkExpression(methodDefinition.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Parser.prototype.walkClass = function walkClass(classy) {
	if(classy.superClass)
		this.walkExpression(classy.superClass);
	if(classy.body &amp;&amp; classy.body.type === "ClassBody") {
		classy.body.body.forEach(function(methodDefinition) {
			if(methodDefinition.type === "MethodDefinition")
				this.<span class="apidocCodeKeywordSpan">walkMethodDefinition</span>(methodDefinition);
		}, this);
	}
};

Parser.prototype.walkMethodDefinition = function walkMethodDefinition(methodDefinition) {
	if(methodDefinition.computed &amp;&amp; methodDefinition.key)
		this.walkExpression(methodDefinition.key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkNewExpression" id="apidoc.element.webpack.Parser.prototype.walkNewExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkNewExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkNewExpression(expression) {
	this.walkExpression(expression.callee);
	if(expression.arguments)
		this.walkExpressions(expression.arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkObjectExpression" id="apidoc.element.webpack.Parser.prototype.walkObjectExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkObjectExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkObjectExpression(expression) {
	for(var propIndex = 0, len = expression.properties.length; propIndex &lt; len; propIndex++) {
		var prop = expression.properties[propIndex];
		if(prop.computed)
			this.walkExpression(prop.key);
		if(prop.shorthand)
			this.scope.inShorthand = true;
		this.walkExpression(prop.value);
		if(prop.shorthand)
			this.scope.inShorthand = false;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkObjectPattern" id="apidoc.element.webpack.Parser.prototype.walkObjectPattern">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkObjectPattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkObjectPattern(pattern) {
	for(var i = 0, len = pattern.properties.length; i &lt; len; i++) {
		var prop = pattern.properties[i];
		if(prop) {
			if(prop.computed)
				this.walkExpression(prop.key);
			if(prop.value)
				this.walkPattern(prop.value);
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkPattern" id="apidoc.element.webpack.Parser.prototype.walkPattern">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkPattern
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkPattern(pattern) {
	if(pattern.type === "Identifier")
		return;
	if(this["walk" + pattern.type])
		this["walk" + pattern.type](pattern);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					// renaming with "var a = b;"
					if(!_this.applyPluginsBailResult1("rename " + renameIdentifier, declarator.init)) {
						_this.scope.renames["$" + declarator.id.name] = _this.scope.renames["$" + renameIdentifier] || renameIdentifier
;
						var idx = _this.scope.definitions.indexOf(declarator.id.name);
						if(idx &gt;= 0) _this.scope.definitions.splice(idx, 1);
					}
				} else {
					_this.<span class="apidocCodeKeywordSpan">walkPattern</span>(declarator.id);
					_this.enterPattern(declarator.id, function(name, decl) {
						if(!_this.applyPluginsBailResult1("var " + name, decl)) {
							_this.scope.renames["$" + name] = undefined;
							_this.scope.definitions.push(name);
						}
					});
					if(declarator.init)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkRestElement" id="apidoc.element.webpack.Parser.prototype.walkRestElement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkRestElement
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkRestElement(pattern) {
	this.walkPattern(pattern.argument);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkReturnStatement" id="apidoc.element.webpack.Parser.prototype.walkReturnStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkReturnStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkArgumentStatement(statement) {
		if(statement.argument)
			this.walkExpression(statement.argument);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkSequenceExpression" id="apidoc.element.webpack.Parser.prototype.walkSequenceExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkSequenceExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkSequenceExpression(expression) {
	if(expression.expressions)
		this.walkExpressions(expression.expressions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkSpreadElement" id="apidoc.element.webpack.Parser.prototype.walkSpreadElement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkSpreadElement
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkSpreadElement(expression) {
	if(expression.argument)
		this.walkExpression(expression.argument);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkStatement" id="apidoc.element.webpack.Parser.prototype.walkStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkStatement(statement) {
	if(this.applyPluginsBailResult1("statement", statement) !== undefined) return;
	if(this["walk" + statement.type])
		this["walk" + statement.type](statement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.walkExpression(methodDefinition.value);
};

Parser.prototype.walkStatements = function walkStatements(statements) {
	for(var indexA = 0, lenA = statements.length; indexA &lt; lenA; indexA++) {
		var statementA = statements[indexA];
		if(this.isHoistedStatement(statementA))
			this.<span class="apidocCodeKeywordSpan">walkStatement</span>(statementA);
	}
	for(var indexB = 0, lenB = statements.length; indexB &lt; lenB; indexB++) {
		var statementB = statements[indexB];
		if(!this.isHoistedStatement(statementB))
			this.walkStatement(statementB);
	}
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkStatements" id="apidoc.element.webpack.Parser.prototype.walkStatements">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkStatements
        <span class="apidocSignatureSpan">(statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkStatements(statements) {
	for(var indexA = 0, lenA = statements.length; indexA &lt; lenA; indexA++) {
		var statementA = statements[indexA];
		if(this.isHoistedStatement(statementA))
			this.walkStatement(statementA);
	}
	for(var indexB = 0, lenB = statements.length; indexB &lt; lenB; indexB++) {
		var statementB = statements[indexB];
		if(!this.isHoistedStatement(statementB))
			this.walkStatement(statementB);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if(this.applyPluginsBailResult1("statement", statement) !== undefined) return;
	if(this["walk" + statement.type])
		this["walk" + statement.type](statement);
};

// Real Statements
Parser.prototype.walkBlockStatement = function walkBlockStatement(statement) {
	this.<span class="apidocCodeKeywordSpan">walkStatements</span>(statement.body);
};

Parser.prototype.walkExpressionStatement = function walkExpressionStatement(statement) {
	this.walkExpression(statement.expression);
};

Parser.prototype.walkIfStatement = function walkIfStatement(statement) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkSwitchCases" id="apidoc.element.webpack.Parser.prototype.walkSwitchCases">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkSwitchCases
        <span class="apidocSignatureSpan">(switchCases)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkSwitchCases(switchCases) {
	for(var index = 0, len = switchCases.length; index &lt; len; index++) {
		var switchCase = switchCases[index];

		if(switchCase.test) {
			this.walkExpression(switchCase.test);
		}
		this.walkStatements(switchCase.consequent);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Parser.prototype.walkWithStatement = function walkWithStatement(statement) {
	this.walkExpression(statement.object);
	this.walkStatement(statement.body);
};

Parser.prototype.walkSwitchStatement = function walkSwitchStatement(statement) {
	this.walkExpression(statement.discriminant);
	this.<span class="apidocCodeKeywordSpan">walkSwitchCases</span>(statement.cases);
};

Parser.prototype.walkReturnStatement =
	Parser.prototype.walkThrowStatement = function walkArgumentStatement(statement) {
		if(statement.argument)
			this.walkExpression(statement.argument);
	};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkSwitchStatement" id="apidoc.element.webpack.Parser.prototype.walkSwitchStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkSwitchStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkSwitchStatement(statement) {
	this.walkExpression(statement.discriminant);
	this.walkSwitchCases(statement.cases);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkTaggedTemplateExpression" id="apidoc.element.webpack.Parser.prototype.walkTaggedTemplateExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkTaggedTemplateExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkTaggedTemplateExpression(expression) {
	if(expression.tag)
		this.walkExpression(expression.tag);
	if(expression.quasi &amp;&amp; expression.quasi.expressions)
		this.walkExpressions(expression.quasi.expressions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkTemplateLiteral" id="apidoc.element.webpack.Parser.prototype.walkTemplateLiteral">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkTemplateLiteral
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkTemplateLiteral(expression) {
	if(expression.expressions)
		this.walkExpressions(expression.expressions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkThrowStatement" id="apidoc.element.webpack.Parser.prototype.walkThrowStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkThrowStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkArgumentStatement(statement) {
		if(statement.argument)
			this.walkExpression(statement.argument);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkTryStatement" id="apidoc.element.webpack.Parser.prototype.walkTryStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkTryStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkTryStatement(statement) {
	if(this.scope.inTry) {
		this.walkStatement(statement.block);
	} else {
		this.scope.inTry = true;
		this.walkStatement(statement.block);
		this.scope.inTry = false;
	}
	if(statement.handler)
		this.walkCatchClause(statement.handler);
	if(statement.finalizer)
		this.walkStatement(statement.finalizer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkUnaryExpression" id="apidoc.element.webpack.Parser.prototype.walkUnaryExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkUnaryExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkUnaryExpression(expression) {
	if(expression.operator === "typeof") {
		var expr = expression.argument;
		var exprName = [];
		while(expr.type === "MemberExpression" &amp;&amp;
			expr.property.type === (expr.computed ? "Literal" : "Identifier")
		) {
			exprName.unshift(expr.property.name || expr.property.value);
			expr = expr.object;
		}
		if(expr.type === "Identifier" &amp;&amp; this.scope.definitions.indexOf(expr.name) === -1) {
			exprName.unshift(this.scope.renames["$" + expr.name] || expr.name);
			exprName = exprName.join(".");
			var result = this.applyPluginsBailResult1("typeof " + exprName, expression);
			if(result === true)
				return;
		}
	}
	this.walkExpression(expression.argument);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkUpdateExpression" id="apidoc.element.webpack.Parser.prototype.walkUpdateExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkUpdateExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkUpdateExpression(expression) {
	this.walkExpression(expression.argument);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkVariableDeclaration" id="apidoc.element.webpack.Parser.prototype.walkVariableDeclaration">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkVariableDeclaration
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkVariableDeclaration(statement) {
	if(statement.declarations)
		this.walkVariableDeclarators(statement.declarations);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkVariableDeclarators" id="apidoc.element.webpack.Parser.prototype.walkVariableDeclarators">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkVariableDeclarators
        <span class="apidocSignatureSpan">(declarators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkVariableDeclarators(declarators) {
	var _this = this;
	declarators.forEach(function(declarator) {
		switch(declarator.type) {
			case "VariableDeclarator":
				var renameIdentifier = declarator.init &amp;&amp; _this.getRenameIdentifier(declarator.init);
				if(renameIdentifier &amp;&amp; declarator.id.type === "Identifier" &amp;&amp; _this.applyPluginsBailResult1("can-rename " + renameIdentifier
, declarator.init)) {
					// renaming with "var a = b;"
					if(!_this.applyPluginsBailResult1("rename " + renameIdentifier, declarator.init)) {
						_this.scope.renames["$" + declarator.id.name] = _this.scope.renames["$" + renameIdentifier] || renameIdentifier;
						var idx = _this.scope.definitions.indexOf(declarator.id.name);
						if(idx &gt;= 0) _this.scope.definitions.splice(idx, 1);
					}
				} else {
					_this.walkPattern(declarator.id);
					_this.enterPattern(declarator.id, function(name, decl) {
						if(!_this.applyPluginsBailResult1("var " + name, decl)) {
							_this.scope.renames["$" + name] = undefined;
							_this.scope.definitions.push(name);
						}
					});
					if(declarator.init)
						_this.walkExpression(declarator.init);
				}
				break;
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var source = statement.source.value;
	this.applyPluginsBailResult("export import", statement, source);
	this.applyPluginsBailResult("export import specifier", statement, source, null, null, 0);
};

Parser.prototype.walkVariableDeclaration = function walkVariableDeclaration(statement) {
	if(statement.declarations)
		this.<span class="apidocCodeKeywordSpan">walkVariableDeclarators</span>(statement.declarations);
};

Parser.prototype.walkClassDeclaration = function walkClassDeclaration(statement) {
	this.scope.renames["$" + statement.id.name] = undefined;
	this.scope.definitions.push(statement.id.name);
	this.walkClass(statement);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkWhileStatement" id="apidoc.element.webpack.Parser.prototype.walkWhileStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkWhileStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkLoopStatement(statement) {
		this.walkExpression(statement.test);
		this.walkStatement(statement.body);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkWithStatement" id="apidoc.element.webpack.Parser.prototype.walkWithStatement">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkWithStatement
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkWithStatement(statement) {
	this.walkExpression(statement.object);
	this.walkStatement(statement.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.Parser.prototype.walkYieldExpression" id="apidoc.element.webpack.Parser.prototype.walkYieldExpression">
        function <span class="apidocSignatureSpan">webpack.Parser.prototype.</span>walkYieldExpression
        <span class="apidocSignatureSpan">(expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkYieldExpression(expression) {
	if(expression.argument)
		this.walkExpression(expression.argument);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.ParserHelpers" id="apidoc.module.webpack.ParserHelpers">module webpack.ParserHelpers</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.addParsedVariableToModule" id="apidoc.element.webpack.ParserHelpers.addParsedVariableToModule">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>addParsedVariableToModule
        <span class="apidocSignatureSpan">(parser, name, expression)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addParsedVariableToModule = function (parser, name, expression) {
	if(!parser.state.current.addVariable) return false;
	var deps = [];
	parser.parse(expression, {
		current: {
			addDependency: function(dep) {
				dep.userRequest = name;
				deps.push(dep);
			}
		},
		module: parser.state.module
	});
	parser.state.current.addVariable(name, expression, deps);
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						let expression = `require(${JSON.stringify(request[0])})`;
						if(scopedName) {
							nameIdentifier = `__webpack_provided_${name.replace(/\./g, "_dot_")}`;
						}
						if(request.length &gt; 1) {
							expression += request.slice(1).map(r =&gt; `[${JSON.stringify(r)}]`).join("");
						}
						if(!ParserHelpers.<span class="apidocCodeKeywordSpan">addParsedVariableToModule</span>(this, nameIdentifier, expression)) {
							return false;
						}
						if(scopedName) {
							ParserHelpers.toConstantDependency(nameIdentifier).bind(this)(expr);
						}
						return true;
					});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.approve" id="apidoc.element.webpack.ParserHelpers.approve">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>approve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function approve() {
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.evaluateToBoolean" id="apidoc.element.webpack.ParserHelpers.evaluateToBoolean">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>evaluateToBoolean
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluateToBoolean = function (value) {
	return function booleanExpression(expr) {
		return new BasicEvaluatedExpression().setBoolean(value).setRange(expr.range);
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			parser.plugin("expression module.id", ParserHelpers.toConstantDependency("module.i"));
			parser.plugin("expression module.exports", function() {
				var module = this.state.module;
				var isHarmony = module.meta &amp;&amp; module.meta.harmonyModule;
				if(!isHarmony)
					return true;
			});
			parser.plugin("evaluate Identifier module.hot", ParserHelpers.<span class="apidocCodeKeywordSpan">evaluateToBoolean
</span>(false));
			parser.plugin("expression module", function() {
				var module = this.state.module;
				var isHarmony = module.meta &amp;&amp; module.meta.harmonyModule;
				var moduleJsPath = path.join(__dirname, "..", "buildin", isHarmony ? "harmony-module.js" : "
;module.js");
				if(module.context) {
					moduleJsPath = path.relative(this.state.module.context, moduleJsPath);
					if(!/^[A-Z]:/i.test(moduleJsPath)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.evaluateToString" id="apidoc.element.webpack.ParserHelpers.evaluateToString">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>evaluateToString
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluateToString = function (value) {
	return function stringExpression(expr) {
		return new BasicEvaluatedExpression().setString(value).setRange(expr.range);
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		compiler.plugin("compilation", (compilation, params) =&gt; {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

			params.normalModuleFactory.plugin("parser", parser =&gt; {
				Object.keys(REPLACEMENTS).forEach(key =&gt; {
					parser.plugin(`expression ${key}`, ParserHelpers.toConstantDependency(REPLACEMENTS[key]));
					parser.plugin(`evaluate typeof ${key}`, ParserHelpers.<span class="apidocCodeKeywordSpan">evaluateToString</span>(REPLACEMENT_TYPES
[key]));
				});
				IGNORES.forEach(key =&gt; {
					parser.plugin(key, ParserHelpers.skipTraversal);
				});
			});
		});
	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.expressionIsUnsupported" id="apidoc.element.webpack.ParserHelpers.expressionIsUnsupported">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>expressionIsUnsupported
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expressionIsUnsupported = function (message) {
	return function unsupportedExpression(expr) {
		var dep = new ConstDependency("(void 0)", expr.range);
		dep.loc = expr.loc;
		this.state.current.addDependency(dep);
		if(!this.state.module) return;
		this.state.module.warnings.push(new UnsupportedFeatureWarning(this.state.module, message));
		return true;
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			parser.plugin("evaluate Identifier __dirname", function(expr) {
				if(!this.state.module) return;
				return ParserHelpers.evaluateToString(this.state.module.context)(expr);
			});
			parser.plugin("expression require.main", ParserHelpers.toConstantDependency("__webpack_require__.c[__webpack_require__
.s]"));
			parser.plugin(
				"expression require.extensions",
				ParserHelpers.<span class="apidocCodeKeywordSpan">expressionIsUnsupported</span>("require.extensions is not supported by
 webpack. Use a loader instead.")
			);
			parser.plugin("expression module.loaded", ParserHelpers.toConstantDependency("module.l"));
			parser.plugin("expression module.id", ParserHelpers.toConstantDependency("module.i"));
			parser.plugin("expression module.exports", function() {
				var module = this.state.module;
				var isHarmony = module.meta &amp;&amp; module.meta.harmonyModule;
				if(!isHarmony)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.requireFileAsExpression" id="apidoc.element.webpack.ParserHelpers.requireFileAsExpression">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>requireFileAsExpression
        <span class="apidocSignatureSpan">(context, pathToModule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requireFileAsExpression = function (context, pathToModule) {
	var moduleJsPath = path.relative(context, pathToModule);
	if(!/^[A-Z]:/i.test(moduleJsPath)) {
		moduleJsPath = "./" + moduleJsPath.replace(/\\/g, "/");
	}
	return "require(" + JSON.stringify(moduleJsPath) + ")";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.skipTraversal" id="apidoc.element.webpack.ParserHelpers.skipTraversal">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>skipTraversal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipTraversal() {
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.ParserHelpers.toConstantDependency" id="apidoc.element.webpack.ParserHelpers.toConstantDependency">
        function <span class="apidocSignatureSpan">webpack.ParserHelpers.</span>toConstantDependency
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toConstantDependency = function (value) {
	return function constDependency(expr) {
		var dep = new ConstDependency(value, expr.range);
		dep.loc = expr.loc;
		this.state.current.addDependency(dep);
		return true;
	};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	apply(compiler) {
		compiler.plugin("compilation", (compilation, params) =&gt; {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

			params.normalModuleFactory.plugin("parser", parser =&gt; {
				Object.keys(REPLACEMENTS).forEach(key =&gt; {
					parser.plugin(`expression ${key}`, ParserHelpers.<span class="apidocCodeKeywordSpan">toConstantDependency</span>(REPLACEMENTS
[key]));
					parser.plugin(`evaluate typeof ${key}`, ParserHelpers.evaluateToString(REPLACEMENT_TYPES[key]));
				});
				IGNORES.forEach(key =&gt; {
					parser.plugin(key, ParserHelpers.skipTraversal);
				});
			});
		});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.SizeFormatHelpers" id="apidoc.module.webpack.SizeFormatHelpers">module webpack.SizeFormatHelpers</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.SizeFormatHelpers.formatSize" id="apidoc.element.webpack.SizeFormatHelpers.formatSize">
        function <span class="apidocSignatureSpan">webpack.SizeFormatHelpers.</span>formatSize
        <span class="apidocSignatureSpan">(size &lt;= 0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size =&gt; {
	if(size &lt;= 0) {
		return "0 bytes";
	}

	const abbreviations = ["bytes", "kB", "MB", "GB"];
	const index = Math.floor(Math.log(size) / Math.log(1000));

	return `${+(size / Math.pow(1000, index)).toPrecision(3)} ${abbreviations[index]}`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				}]
			];
			obj.assets.forEach(asset =&gt; {
				t.push([{
					value: asset.name,
					color: getAssetColor(asset, colors.green)
				}, {
					value: SizeFormatHelpers.<span class="apidocCodeKeywordSpan">formatSize</span>(asset.size),
					color: getAssetColor(asset, colors.normal)
				}, {
					value: asset.chunks.join(", "),
					color: colors.bold
				}, {
					value: asset.emitted ? "[emitted]" : "",
					color: colors.green
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.SourceMapDevToolPlugin" id="apidoc.module.webpack.SourceMapDevToolPlugin">module webpack.SourceMapDevToolPlugin</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.SourceMapDevToolPlugin.SourceMapDevToolPlugin" id="apidoc.element.webpack.SourceMapDevToolPlugin.SourceMapDevToolPlugin">
        function <span class="apidocSignatureSpan">webpack.</span>SourceMapDevToolPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceMapDevToolPlugin(options) {
	if(arguments.length &gt; 1)
		throw new Error("SourceMapDevToolPlugin only takes one argument (pass an options object)");
	if(typeof options === "string") {
		options = {
			sourceMapFilename: options
		};
	}
	if(!options) options = {};
	this.sourceMapFilename = options.filename;
	this.sourceMappingURLComment = options.append === false ? false : options.append || "\n//# sourceMappingURL=[url]";
	this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack:///[resourcePath]";
	this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || "webpack:///[resourcePath]?[hash]";
	this.options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.SourceMapDevToolPlugin.prototype" id="apidoc.module.webpack.SourceMapDevToolPlugin.prototype">module webpack.SourceMapDevToolPlugin.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.SourceMapDevToolPlugin.prototype.apply" id="apidoc.element.webpack.SourceMapDevToolPlugin.prototype.apply">
        function <span class="apidocSignatureSpan">webpack.SourceMapDevToolPlugin.prototype.</span>apply
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (compiler) {
	var sourceMapFilename = this.sourceMapFilename;
	var sourceMappingURLComment = this.sourceMappingURLComment;
	var moduleFilenameTemplate = this.moduleFilenameTemplate;
	var fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;
	var requestShortener = new RequestShortener(compiler.context);
	var options = this.options;
	options.test = options.test || /\.(js|css)($|\?)/i;
	compiler.plugin("compilation", function(compilation) {
		new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
		compilation.plugin("after-optimize-chunk-assets", function(chunks) {
			var allModules = [];
			var allModuleFilenames = [];
			var tasks = [];
			chunks.forEach(function(chunk) {
				chunk.files.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options)).map(function(file) {
					var asset = this.assets[file];
					if(asset.__SourceMapDevToolData) {
						var data = asset.__SourceMapDevToolData;
						for(var cachedFile in data) {
							this.assets[cachedFile] = data[cachedFile];
							if(cachedFile !== file)
								chunk.files.push(cachedFile);
						}
						return;
					}
					var source;
					var sourceMap;
					if(asset.sourceAndMap) {
						var sourceAndMap = asset.sourceAndMap(options);
						sourceMap = sourceAndMap.map;
						source = sourceAndMap.source;
					} else {
						sourceMap = asset.map(options);
						source = asset.source();
					}
					if(sourceMap) {
						return {
							chunk: chunk,
							file: file,
							asset: asset,
							source: source,
							sourceMap: sourceMap
						};
					}
				}, this).filter(Boolean).map(function(task) {
					var modules = task.sourceMap.sources.map(function(source) {
						var module = compilation.findModule(source);
						return module || source;
					});
					var moduleFilenames = modules.map(function(module) {
						return ModuleFilenameHelpers.createFilename(module, moduleFilenameTemplate, requestShortener);
					});
					task.modules = modules;
					task.moduleFilenames = moduleFilenames;
					return task;
				}, this).forEach(function(task) {
					allModules = allModules.concat(task.modules);
					allModuleFilenames = allModuleFilenames.concat(task.moduleFilenames);
					tasks.push(task);
				}, this);
			}, this);
			allModuleFilenames = ModuleFilenameHelpers.replaceDuplicates(allModuleFilenames, function(filename, i) {
				return ModuleFilenameHelpers.createFilename(allModules[i], fallbackModuleFilenameTemplate, requestShortener);
			}, function(ai, bi) {
				var a = allModules[ai];
				var b = allModules[bi];
				a = !a ? "" : typeof a === "string" ? a : a.identifier();
				b = !b ? "" : typeof b === "string" ? b : b.identifier();
				return a.length - b.length;
			});
			allModuleFilenames = ModuleFilenameHelpers.replaceDuplicates(allModuleFilenames, function(filename, i, n) {
				for(var j = 0; j &lt; n; j++)
					filename += "*";
				return filename;
			});
			tasks.forEach(function(task) {
				task.moduleFilenames = allModuleFilenames.slice(0, task.moduleFilenames.length);
				allModuleFilenames = allModuleFilenames.slice(task.moduleFilenames.length);
			}, this);
			tasks.forEach(function(task) {
				var chunk = task.chunk;
				var file = task.file;
				var asset = task.asset;
				var sourceMap = task.sourceMap;
				var source = task.source;
				var moduleFilenames = task.moduleFilenames;
				var modules = task.modules;
				sourceMap.sources = moduleFilenames;
				if(sourceMap.sourcesContent &amp;&amp; !options.noSources) {
					sourceMap.sourcesContent = sourceMap.sourcesContent.map(function(content, i) {
						return content + "\n\n\n" + ModuleFilenameHelpers.createFooter(modules[i], requestShortener);
					});
				} else {
					sourceMap.sourcesContent = undefined;
				}
				sourceMap.sourceRoot = options.sourceRoot || "";
				sourceMap.file = file;
				asset.__SourceMapDevToolData = {};
				var currentSourceMappingURLComment = sourceMappingURLComment;
				if(currentSourceMappingURLComment !== false &amp;&amp; /\.css($|\?)/i. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this.cache = cache || {};
		this.FS_ACCURENCY = 2000;
	}

	apply(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) =&gt; {
				c.<span class="apidocCodeKeywordSpan">apply</span>(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			});
		} else {
			compiler.plugin("compilation", compilation =&gt; {
				if(!compilation.notCacheable) {
					compilation.cache = this.cache;
				} else if(this.watching) {
					compilation.warnings.push(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.optimize" id="apidoc.module.webpack.optimize">module webpack.optimize</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.optimize.AggressiveMergingPlugin" id="apidoc.element.webpack.optimize.AggressiveMergingPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>AggressiveMergingPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AggressiveMergingPlugin {
	constructor(options) {
		if(options !== undefined &amp;&amp; typeof options !== "object" || Array.isArray(options)) {
			throw new Error("Argument should be an options object. To use defaults, pass in nothing.\nFor more info on options, see https
://webpack.js.org/plugins/");
		}
		this.options = options || {};
	}

	apply(compiler) {
		const options = this.options;
		const minSizeReduce = options.minSizeReduce || 1.5;

		function getParentsWeight(chunk) {
			return chunk.parents.map((p) =&gt; {
				return p.isInitial() ? options.entryChunkMultiplicator || 10 : 1;
			}).reduce((a, b) =&gt; {
				return a + b;
			}, 0);
		}
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-chunks-advanced", (chunks) =&gt; {
				let combinations = [];
				chunks.forEach((a, idx) =&gt; {
					if(a.isInitial()) return;
					for(let i = 0; i &lt; idx; i++) {
						const b = chunks[i];
						if(b.isInitial()) continue;
						combinations.push([b, a]);
					}
				});

				combinations.forEach((pair) =&gt; {
					const a = pair[0].size({
						chunkOverhead: 0
					});
					const b = pair[1].size({
						chunkOverhead: 0
					});
					const ab = pair[0].integratedSize(pair[1], {
						chunkOverhead: 0
					});
					pair.push({
						a: a,
						b: b,
						ab: ab
					});
					let newSize;
					if(ab === false) {
						pair.unshift(false);
					} else if(options.moveToParents) {
						const aOnly = ab - b;
						const bOnly = ab - a;
						const common = a + b - ab;
						newSize = common + getParentsWeight(pair[0]) * aOnly + getParentsWeight(pair[1]) * bOnly;
						pair.push({
							aOnly: aOnly,
							bOnly: bOnly,
							common: common,
							newSize: newSize
						});
					} else {
						newSize = ab;
					}

					pair.unshift((a + b) / newSize);
				});
				combinations = combinations.filter((pair) =&gt; {
					return pair[0] !== false;
				});
				combinations.sort((a, b) =&gt; {
					return b[0] - a[0];
				});

				const pair = combinations[0];

				if(!pair) return;
				if(pair[0] &lt; minSizeReduce) return;

				if(options.moveToParents) {
					const commonModules = pair[1].modules.filter((m) =&gt; {
						return pair[2].modules.indexOf(m) &gt;= 0;
					});
					const aOnlyModules = pair[1].modules.filter((m) =&gt; {
						return commonModules.indexOf(m) &lt; 0;
					});
					const bOnlyModules = pair[2].modules.filter((m) =&gt; {
						return commonModules.indexOf(m) &lt; 0;
					});
					aOnlyModules.forEach((m) =&gt; {
						pair[1].removeModule(m);
						m.removeChunk(pair[1]);
						pair[1].parents.forEach((c) =&gt; {
							c.addModule(m);
							m.addChunk(c);
						});
					});
					bOnlyModules.forEach((m) =&gt; {
						pair[2].removeModule(m);
						m.removeChunk(pair[2]);
						pair[2].parents.forEach((c) =&gt; {
							c.addModule(m);
							m.addChunk(c);
						});
					});
				}
				if(pair[1].integrate(pair[2], "aggressive-merge")) {
					chunks.splice(chunks.indexOf(pair[2]), 1);
					return true;
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.AggressiveSplittingPlugin" id="apidoc.element.webpack.optimize.AggressiveSplittingPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>AggressiveSplittingPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AggressiveSplittingPlugin {
	constructor(options) {
		this.options = options || {};
		if(typeof this.options.minSize !== "number") this.options.minSize = 30 * 1024;
		if(typeof this.options.maxSize !== "number") this.options.maxSize = 50 * 1024;
		if(typeof this.options.chunkOverhead !== "number") this.options.chunkOverhead = 0;
		if(typeof this.options.entryChunkMultiplicator !== "number") this.options.entryChunkMultiplicator = 1;
	}
	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-chunks-advanced", (chunks) =&gt; {
				const savedSplits = compilation.records &amp;&amp; compilation.records.aggressiveSplits || [];
				const usedSplits = compilation._aggressiveSplittingSplits ?
					savedSplits.concat(compilation._aggressiveSplittingSplits) : savedSplits;

				const minSize = this.options.minSize;
				const maxSize = this.options.maxSize;
				// 1. try to restore to recorded splitting
				for(let j = 0; j &lt; usedSplits.length; j++) {
					const splitData = usedSplits[j];
					for(let i = 0; i &lt; chunks.length; i++) {
						const chunk = chunks[i];
						const chunkModuleNames = chunk.modules.map(makeRelative(compiler.context));

						if(chunkModuleNames.length &lt; splitData.modules.length)
							continue;
						const moduleIndicies = splitData.modules.map(toIndexOf(chunkModuleNames));
						const hasAllModules = moduleIndicies.every((idx) =&gt; {
							return idx &gt;= 0;
						});
						if(hasAllModules) {
							if(chunkModuleNames.length &gt; splitData.modules.length) {
								const selectedModules = moduleIndicies.map(toChunkModuleIndices(chunk.modules));
								const newChunk = compilation.addChunk();
								selectedModules.forEach(moveModuleBetween(chunk, newChunk));
								chunk.split(newChunk);
								chunk.name = null;
								newChunk._fromAggressiveSplitting = true;
								if(j &lt; savedSplits.length)
									newChunk._fromAggressiveSplittingIndex = j;
								if(typeof splitData.id === "number") newChunk.id = splitData.id;
								newChunk.origins = chunk.origins.map(copyWithReason);
								chunk.origins = chunk.origins.map(copyWithReason);
								return true;
							} else {
								if(j &lt; savedSplits.length)
									chunk._fromAggressiveSplittingIndex = j;
								chunk.name = null;
								if(typeof splitData.id === "number") chunk.id = splitData.id;
							}
						}
					}
				}
				// 2. for any other chunk which isn't splitted yet, split it
				for(let i = 0; i &lt; chunks.length; i++) {
					const chunk = chunks[i];
					const size = chunk.size(this.options);
					if(size &gt; maxSize &amp;&amp; chunk.modules.length &gt; 1) {
						const newChunk = compilation.addChunk();
						const modules = chunk.modules
							.filter(isNotAEntryModule(chunk.entryModule))
							.sort((a, b) =&gt; {
								a = a.identifier();
								b = b.identifier();
								if(a &gt; b) return 1;
								if(a &lt; b) return -1;
								return 0;
							});
						for(let k = 0; k &lt; modules.length; k++) {
							chunk.moveModule(modules[k], newChunk);
							const newSize = newChunk.size(this.options);
							const chunkSize = chunk.size(this.options);
							// break early if it's fine
							if(chunkSize &lt; maxSize &amp;&amp; newSize &lt; maxSize &amp;&amp; newSize &gt;= minSize &amp;&amp; chunkSize &gt;= minSize)
								break;
							if(newSize &gt; maxSize &amp;&amp; k === 0) {
								// break if there is a single module which is bigger than maxSize
								break;
							}
							if(newSize &gt; maxSize || chunkSize &lt; minSize) {
								// move it back
								newChunk.moveModule(modules[k], chunk);
								// check if it's fine now
								if(newSize &lt; maxSize &amp;&amp; newSize &gt;= minSize &amp;&amp; chunkSize &gt;= minSize)
									break;
							}
						}
						if(newChunk.modules.length &gt; 0) {
							chunk.split(newChunk);
							chunk.name = null;
							newChunk.origins = chunk.origins.map(copyWithReason);
							chunk.origins = chunk.origins.map(copyWithReason);
							compilation._aggressiveSplittingSplits = (compilation._aggressiveSplittingSplits || []).concat({ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.ChunkModuleIdRangePlugin" id="apidoc.element.webpack.optimize.ChunkModuleIdRangePlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>ChunkModuleIdRangePlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ChunkModuleIdRangePlugin {
	constructor(options) {
		this.options = options;
	}
	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("module-ids", (modules) =&gt; {
				const chunk = this.chunks.filter((chunk) =&gt; {
					return chunk.name === options.name;
				})[0];
				if(!chunk) throw new Error("ChunkModuleIdRangePlugin: Chunk with name '" + options.name + "' was not found");
				let currentId = options.start;
				let chunkModules;
				if(options.order) {
					chunkModules = chunk.modules.slice();
					switch(options.order) {
						case "index":
							chunkModules.sort((a, b) =&gt; {
								return a.index - b.index;
							});
							break;
						case "index2":
							chunkModules.sort((a, b) =&gt; {
								return a.index2 - b.index2;
							});
							break;
						default:
							throw new Error("ChunkModuleIdRangePlugin: unexpected value of order");
					}

				} else {
					chunkModules = modules.filter((m) =&gt; {
						return m.chunks.indexOf(chunk) &gt;= 0;
					});
				}

				for(let i = 0; i &lt; chunkModules.length; i++) {
					const m = chunkModules[i];
					if(m.id === null) {
						m.id = currentId++;
					}
					if(options.end &amp;&amp; currentId &gt; options.end)
						break;
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.CommonsChunkPlugin" id="apidoc.element.webpack.optimize.CommonsChunkPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>CommonsChunkPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CommonsChunkPlugin {
	constructor(options) {
		if(arguments.length &gt; 1) {
			throw new Error(`Deprecation notice: CommonsChunkPlugin now only takes a single argument. Either an options
object *or* the name of the chunk.
Example: if your old code looked like this:
	new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js')
You would change it to:
	new webpack.optimize.CommonsChunkPlugin({ name: 'vendor', filename: 'vendor.bundle.js' })
The available options are:
	name: string
	names: string[]
	filename: string
	minChunks: number
	chunks: string[]
	children: boolean
	async: boolean
	minSize: number`);
		}

		const normalizedOptions = this.normalizeOptions(options);

		this.chunkNames = normalizedOptions.chunkNames;
		this.filenameTemplate = normalizedOptions.filenameTemplate;
		this.minChunks = normalizedOptions.minChunks;
		this.selectedChunks = normalizedOptions.selectedChunks;
		this.children = normalizedOptions.children;
		this.async = normalizedOptions.async;
		this.minSize = normalizedOptions.minSize;
		this.ident = __filename + (nextIdent++);
	}

	normalizeOptions(options) {
		if(Array.isArray(options)) {
			return {
				chunkNames: options,
			};
		}

		if(typeof options === "string") {
			return {
				chunkNames: [options],
			};
		}

		// options.children and options.chunk may not be used together
		if(options.children &amp;&amp; options.chunks) {
			throw new Error("You can't and it does not make any sense to use \"children\" and \"chunk\" options together.");
		}

		/**
		 * options.async and options.filename are also not possible together
		 * as filename specifies how the chunk is called but "async" implies
		 * that webpack will take care of loading this file.
		 */
		if(options.async &amp;&amp; options.filename) {
			throw new Error(`You can not specify a filename if you use the \"async\" option.
You can however specify the name of the async chunk by passing the desired string as the \"async\" option.`);
		}

		/**
		 * Make sure this is either an array or undefined.
		 * "name" can be a string and
		 * "names" a string or an array
		 */
		const chunkNames = options.name || options.names ? [].concat(options.name || options.names) : undefined;
		return {
			chunkNames: chunkNames,
			filenameTemplate: options.filename,
			minChunks: options.minChunks,
			selectedChunks: options.chunks,
			children: options.children,
			async: options.async,
			minSize: options.minSize
		};
	}

	apply(compiler) {
		compiler.plugin("this-compilation", (compilation) =&gt; {
			compilation.plugin(["optimize-chunks", "optimize-extracted-chunks"], (chunks) =&gt; {
				// only optimize once
				if(compilation[this.ident]) return;
				compilation[this.ident] = true;

				/**
				 * Creates a list of "common"" chunks based on the options.
				 * The list is made up of preexisting or newly created chunks.
				 * - If chunk has the name as specified in the chunkNames it is put in the list
				 * - If no chunk with the name as given in chunkNames exists a new chunk is created and added to the list
				 *
				 * These chunks are the "targets" for extracted modules.
				 */
				const targetChunks = this.getTargetChunks(chunks, compilation, this.chunkNames, this.children, this.async);

				// iterate over all our new chunks
				targetChunks.forEach((targetChunk, idx) =&gt; {

					/**
					 * These chunks are subject to get "common" modules extracted and moved to the common chunk
					 */
					const affectedChunks = this.getAffectedChunks(compilation, chunks, targetChunk, targetChunks, idx, this.selectedChunks, this
.async, this.children);

					// bail if no chunk is affected
					if(!affectedChunks) {
						return;
					}

					// If we are async create an async chunk now
					// override the "commonChunk" with the newly created async one and use it as commonChunk from now on
					let asyncChunk;
					if(this.async) {
						asyncChunk = this.createAsyncChunk(compilation, this.async, targetChunk);
						targetChunk = asyncChunk;
					} ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.DedupePlugin" id="apidoc.element.webpack.optimize.DedupePlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>DedupePlugin
        <span class="apidocSignatureSpan">(compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DedupePlugin {
	apply(compiler) {
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.warnings.push(new Error("DedupePlugin: This plugin was removed from webpack. Remove it from your configuration."));
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.LimitChunkCountPlugin" id="apidoc.element.webpack.optimize.LimitChunkCountPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>LimitChunkCountPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class LimitChunkCountPlugin {
	constructor(options) {
		if(options !== undefined &amp;&amp; typeof options !== "object" || Array.isArray(options)) {
			throw new Error("Argument should be an options object.\nFor more info on options, see https://webpack.js.org/plugins/");
		}
		this.options = options || {};
	}
	apply(compiler) {
		const options = this.options;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-chunks-advanced", (chunks) =&gt; {
				const maxChunks = options.maxChunks;
				if(!maxChunks) return;
				if(maxChunks &lt; 1) return;
				if(chunks.length &lt;= maxChunks) return;

				if(chunks.length &gt; maxChunks) {
					const sortedExtendedPairCombinations = chunks.reduce((combinations, a, idx) =&gt; {
						// create combination pairs
						for(let i = 0; i &lt; idx; i++) {
							const b = chunks[i];
							combinations.push([b, a]);
						}
						return combinations;
					}, []).map((pair) =&gt; {
						// extend combination pairs with size and integrated size
						const a = pair[0].size(options);
						const b = pair[1].size(options);
						const ab = pair[0].integratedSize(pair[1], options);
						return [a + b - ab, ab, pair[0], pair[1], a, b];
					}).filter((extendedPair) =&gt; {
						// filter pairs that do not have an integratedSize
						// meaning they can NOT be integrated!
						return extendedPair[1] !== false;
					}).sort((a, b) =&gt; { // sadly javascript does an inplace sort here
						// sort them by size
						const diff = b[0] - a[0];
						if(diff !== 0) return diff;
						return a[1] - b[1];
					});

					const pair = sortedExtendedPairCombinations[0];

					if(pair &amp;&amp; pair[2].integrate(pair[3], "limit")) {
						chunks.splice(chunks.indexOf(pair[3]), 1);
						return true;
					}
				}
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.MinChunkSizePlugin" id="apidoc.element.webpack.optimize.MinChunkSizePlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>MinChunkSizePlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class MinChunkSizePlugin {
	constructor(options) {
		if(typeof options !== "object" || Array.isArray(options)) {
			throw new Error("Argument should be an options object.\nFor more info on options, see https://webpack.js.org/plugins/");
		}
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		const minChunkSize = options.minChunkSize;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-chunks-advanced", (chunks) =&gt; {
				const equalOptions = {
					chunkOverhead: 1,
					entryChunkMultiplicator: 1
				};

				const sortedSizeFilteredExtendedPairCombinations = chunks.reduce((combinations, a, idx) =&gt; {
					// create combination pairs
					for(let i = 0; i &lt; idx; i++) {
						const b = chunks[i];
						combinations.push([b, a]);
					}
					return combinations;
				}, []).filter((pair) =&gt; {
					// check if one of the chunks sizes is smaller than the minChunkSize
					const p0SmallerThanMinChunkSize = pair[0].size(equalOptions) &lt; minChunkSize;
					const p1SmallerThanMinChunkSize = pair[1].size(equalOptions) &lt; minChunkSize;
					return p0SmallerThanMinChunkSize || p1SmallerThanMinChunkSize;
				}).map((pair) =&gt; {
					// extend combination pairs with size and integrated size
					const a = pair[0].size(options);
					const b = pair[1].size(options);
					const ab = pair[0].integratedSize(pair[1], options);
					return [a + b - ab, ab, pair[0], pair[1]];
				}).filter((pair) =&gt; {
					// filter pairs that do not have an integratedSize
					// meaning they can NOT be integrated!
					return pair[1] !== false;
				}).sort((a, b) =&gt; { // sadly javascript does an inplace sort here
					// sort by size
					const diff = b[0] - a[0];
					if(diff !== 0) return diff;
					return a[1] - b[1];
				});

				if(sortedSizeFilteredExtendedPairCombinations.length === 0) return;

				const pair = sortedSizeFilteredExtendedPairCombinations[0];

				pair[2].integrate(pair[3], "min-size");
				chunks.splice(chunks.indexOf(pair[3]), 1);
				return true;
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.OccurrenceOrderPlugin" id="apidoc.element.webpack.optimize.OccurrenceOrderPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>OccurrenceOrderPlugin
        <span class="apidocSignatureSpan">(preferEntry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class OccurrenceOrderPlugin {
	constructor(preferEntry) {
		if(preferEntry !== undefined &amp;&amp; typeof preferEntry !== "boolean") {
			throw new Error("Argument should be a boolean.\nFor more info on this plugin, see https://webpack.js.org/plugins/");
		}
		this.preferEntry = preferEntry;
	}
	apply(compiler) {
		const preferEntry = this.preferEntry;
		compiler.plugin("compilation", (compilation) =&gt; {
			compilation.plugin("optimize-module-order", (modules) =&gt; {
				function entryChunks(m) {
					return m.chunks.map((c) =&gt; {
						const sum = (c.isInitial() ? 1 : 0) + (c.entryModule === m ? 1 : 0);
						return sum;
					}).reduce((a, b) =&gt; {
						return a + b;
					}, 0);
				}

				function occursInEntry(m) {
					if(typeof m.__OccurenceOrderPlugin_occursInEntry === "number") return m.__OccurenceOrderPlugin_occursInEntry;
					const result = m.reasons.map((r) =&gt; {
						if(!r.module) return 0;
						return entryChunks(r.module);
					}).reduce((a, b) =&gt; {
						return a + b;
					}, 0) + entryChunks(m);
					return m.__OccurenceOrderPlugin_occursInEntry = result;
				}

				function occurs(m) {
					if(typeof m.__OccurenceOrderPlugin_occurs === "number") return m.__OccurenceOrderPlugin_occurs;
					const result = m.reasons.map((r) =&gt; {
						if(!r.module) return 0;
						return r.module.chunks.length;
					}).reduce((a, b) =&gt; {
						return a + b;
					}, 0) + m.chunks.length + m.chunks.filter((c) =&gt; {
						return c.entryModule === m;
					}).length;
					return m.__OccurenceOrderPlugin_occurs = result;
				}
				modules.sort((a, b) =&gt; {
					if(preferEntry) {
						const aEntryOccurs = occursInEntry(a);
						const bEntryOccurs = occursInEntry(b);
						if(aEntryOccurs &gt; bEntryOccurs) return -1;
						if(aEntryOccurs &lt; bEntryOccurs) return 1;
					}
					const aOccurs = occurs(a);
					const bOccurs = occurs(b);
					if(aOccurs &gt; bOccurs) return -1;
					if(aOccurs &lt; bOccurs) return 1;
					if(a.identifier() &gt; b.identifier()) return 1;
					if(a.identifier() &lt; b.identifier()) return -1;
					return 0;
				});
				// TODO refactor to Map
				modules.forEach((m) =&gt; {
					m.__OccurenceOrderPlugin_occursInEntry = undefined;
					m.__OccurenceOrderPlugin_occurs = undefined;
				});
			});
			compilation.plugin("optimize-chunk-order", (chunks) =&gt; {
				function occursInEntry(c) {
					if(typeof c.__OccurenceOrderPlugin_occursInEntry === "number") return c.__OccurenceOrderPlugin_occursInEntry;
					const result = c.parents.filter((p) =&gt; {
						return p.isInitial();
					}).length;
					return c.__OccurenceOrderPlugin_occursInEntry = result;
				}

				function occurs(c) {
					return c.blocks.length;
				}
				chunks.forEach((c) =&gt; {
					c.modules.sort((a, b) =&gt; {
						if(a.identifier() &gt; b.identifier()) return 1;
						if(a.identifier() &lt; b.identifier()) return -1;
						return 0;
					});
				});
				chunks.sort((a, b) =&gt; {
					const aEntryOccurs = occursInEntry(a);
					const bEntryOccurs = occursInEntry(b);
					if(aEntryOccurs &gt; bEntryOccurs) return -1;
					if(aEntryOccurs &lt; bEntryOccurs) return 1;
					const aOccurs = occurs(a);
					const bOccurs = occurs(b);
					if(aOccurs &gt; bOccurs) return -1;
					if(aOccurs &lt; bOccurs) return 1;
					if(a.modules.length &gt; b.modules.length) return -1;
					if(a.modules.length &lt; b.modules.length) return 1;
					for(let i = 0; i &lt; a.modules.length; i++) {
						if(a.modules[i].identifier() &gt; b.modules[i].identifier()) return -1;
						if(a.modules[i].identifier() &lt; b.modules[i].identifier()) return 1;
					}
					return 0;
				});
				// TODO refactor to Map
				chunks.forEach((c) =&gt; {
					c.__OccurenceOrderPlugin_occursInEntry = undefined;
				});
			});
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.optimize.UglifyJsPlugin" id="apidoc.element.webpack.optimize.UglifyJsPlugin">
        function <span class="apidocSignatureSpan">webpack.optimize.</span>UglifyJsPlugin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class UglifyJsPlugin {
	constructor(options) {
		if(typeof options !== "object" || Array.isArray(options)) options = {};
		if(typeof options.compressor !== "undefined") options.compress = options.compressor;
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		options.test = options.test || /\.js($|\?)/i;
		const warningsFilter = options.warningsFilter || (() =&gt; true);

		const requestShortener = new RequestShortener(compiler.context);
		compiler.plugin("compilation", (compilation) =&gt; {
			if(options.sourceMap) {
				compilation.plugin("build-module", (module) =&gt; {
					// to get detailed location info about errors
					module.useSourceMap = true;
				});
			}
			compilation.plugin("optimize-chunk-assets", (chunks, callback) =&gt; {
				const files = [];
				chunks.forEach((chunk) =&gt; files.push.apply(files, chunk.files));
				files.push.apply(files, compilation.additionalChunkAssets);
				const filterdFiles = files.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options));
				filterdFiles.forEach((file) =&gt; {
					const oldWarnFunction = uglify.AST_Node.warn_function;
					const warnings = [];
					let sourceMap;
					try {
						const asset = compilation.assets[file];
						if(asset.__UglifyJsPlugin) {
							compilation.assets[file] = asset.__UglifyJsPlugin;
							return;
						}
						let input;
						let inputSourceMap;
						if(options.sourceMap) {
							if(asset.sourceAndMap) {
								const sourceAndMap = asset.sourceAndMap();
								inputSourceMap = sourceAndMap.map;
								input = sourceAndMap.source;
							} else {
								inputSourceMap = asset.map();
								input = asset.source();
							}
							sourceMap = new SourceMapConsumer(inputSourceMap);
							uglify.AST_Node.warn_function = (warning) =&gt; { // eslint-disable-line camelcase
								const match = /\[.+:([0-9]+),([0-9]+)\]/.exec(warning);
								const line = +match[1];
								const column = +match[2];
								const original = sourceMap.originalPositionFor({
									line: line,
									column: column
								});
								if(!original || !original.source || original.source === file) return;
								if(!warningsFilter(original.source)) return;
								warnings.push(warning.replace(/\[.+:([0-9]+),([0-9]+)\]/, "") +
									"[" + requestShortener.shorten(original.source) + ":" + original.line + "," + original.column + "]");
							};
						} else {
							input = asset.source();
							uglify.AST_Node.warn_function = (warning) =&gt; { // eslint-disable-line camelcase
								warnings.push(warning);
							};
						}
						uglify.base54.reset();
						let ast = uglify.parse(input, {
							filename: file
						});
						if(options.compress !== false) {
							ast.figure_out_scope();
							const compress = uglify.Compressor(options.compress || {
								warnings: false
							}); // eslint-disable-line new-cap
							ast = compress.compress(ast);
						}
						if(options.mangle !== false) {
							ast.figure_out_scope(options.mangle || {});
							ast.compute_char_frequency(options.mangle || {});
							ast.mangle_names(options.mangle || {});
							if(options.mangle &amp;&amp; options.mangle.props) {
								uglify.mangle_properties(ast, options.mangle.props);
							}
						}
						const output = {};
						output.comments = Object.prototype.hasOwnProperty.call(options, "comments") ? options.comments : /^\**!|@preserve|@license
/;
						output.beautify = options.beautify;
						for(let k in options.output) {
							output[k] = options.output[k];
						}
						const extractedComments = [];
						if(options.extractComments) {
							const condition = {};
							if(typeof options.extractComments === "string" || options.extractComments instanceof RegExp) {
								// extractComments specifies the extract condition and output.comments specifies the preserve condition
								condition.preserve = output.comments;
								condition.extract = options.extractComments;
							} else if(Object.prototype.hasOwnProperty.call(options.extractC ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.system" id="apidoc.module.webpack.system">module webpack.system</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.system.import" id="apidoc.element.webpack.system.import">
        function <span class="apidocSignatureSpan">webpack.system.</span>import
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function () {
		throw new Error("System.import cannot be used indirectly");
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webpack.webpack_web" id="apidoc.module.webpack.webpack_web">module webpack.webpack_web</a></h1>


    <h2>
        <a href="#apidoc.element.webpack.webpack_web.webpack_web" id="apidoc.element.webpack.webpack_web.webpack_web">
        function <span class="apidocSignatureSpan">webpack.</span>webpack_web
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function webpack(options, callback) {
	new WebpackOptionsDefaulter().process(options);

	const compiler = new Compiler();
	compiler.options = options;
	compiler.options = new WebpackOptionsApply().process(options, compiler);
	new WebEnvironmentPlugin(options.inputFileSystem, options.outputFileSystem).apply(compiler);
	if(callback) {
		compiler.run(callback);
	}
	return compiler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.webpack_web.Compiler" id="apidoc.element.webpack.webpack_web.Compiler">
        function <span class="apidocSignatureSpan">webpack.webpack_web.</span>Compiler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compiler() {
	Tapable.call(this);

	this.outputPath = "";
	this.outputFileSystem = null;
	this.inputFileSystem = null;

	this.recordsInputPath = null;
	this.recordsOutputPath = null;
	this.records = {};

	this.fileTimestamps = {};
	this.contextTimestamps = {};

	this.resolvers = {
		normal: null,
		loader: null,
		context: null
	};
	var deprecationReported = false;
	this.parser = {
		plugin: function(hook, fn) {
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.plugin(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.plugin(hook, fn);
				});
			});
		}.bind(this),
		apply: function() {
			var args = arguments;
			if(!deprecationReported) {
				console.warn("webpack: Using compiler.parser is deprecated.\n" +
					"Use compiler.plugin(\"compilation\", function(compilation, data) {\n  data.normalModuleFactory.plugin(\"parser\", function
(parser, options) { parser.apply(/* ... */); });\n}); instead. " +
					"It was called " + new Error().stack.split("\n")[2].trim() + ".");
				deprecationReported = true;
			}
			this.plugin("compilation", function(compilation, data) {
				data.normalModuleFactory.plugin("parser", function(parser) {
					parser.apply.apply(parser, args);
				});
			});
		}.bind(this)
	};

	this.options = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.webpack_web.WebEnvironmentPlugin" id="apidoc.element.webpack.webpack_web.WebEnvironmentPlugin">
        function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebEnvironmentPlugin
        <span class="apidocSignatureSpan">(inputFileSystem, outputFileSystem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebEnvironmentPlugin {
	constructor(inputFileSystem, outputFileSystem) {
		this.inputFileSystem = inputFileSystem;
		this.outputFileSystem = outputFileSystem;
	}

	apply(compiler) {
		compiler.outputFileSystem = this.outputFileSystem;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.webpack_web.WebpackOptionsApply" id="apidoc.element.webpack.webpack_web.WebpackOptionsApply">
        function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebpackOptionsApply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebpackOptionsApply extends OptionsApply {
	constructor() {
		super();
	}

	process(options, compiler) {
		let ExternalsPlugin;
		compiler.outputPath = options.output.path;
		compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;
		compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath;
		compiler.name = options.name;
		compiler.dependencies = options.dependencies;
		if(typeof options.target === "string") {
			let JsonpTemplatePlugin;
			let NodeSourcePlugin;
			let NodeTargetPlugin;
			let NodeTemplatePlugin;

			switch(options.target) {
				case "web":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeSourcePlugin = require("./node/NodeSourcePlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeSourcePlugin(options.node),
						new LoaderTargetPlugin("web")
					);
					break;
				case "webworker":
					{
						let WebWorkerTemplatePlugin = require("./webworker/WebWorkerTemplatePlugin");
						NodeSourcePlugin = require("./node/NodeSourcePlugin");
						compiler.apply(
							new WebWorkerTemplatePlugin(options.output),
							new FunctionModulePlugin(options.output),
							new NodeSourcePlugin(options.node),
							new LoaderTargetPlugin("webworker")
						);
						break;
					}
				case "node":
				case "async-node":
					NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					compiler.apply(
						new NodeTemplatePlugin({
							asyncChunkLoading: options.target === "async-node"
						}),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new LoaderTargetPlugin("node")
					);
					break;
				case "node-webkit":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", "nw.gui"),
						new LoaderTargetPlugin("node-webkit")
					);
					break;
				case "atom":
				case "electron":
				case "electron-main":
					NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new NodeTemplatePlugin({
							asyncChunkLoading: true
						}),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"app",
							"auto-updater",
							"browser-window",
							"content-tracing",
							"dialog",
							"electron",
							"global-shortcut",
							"ipc",
							"ipc-main",
							"menu",
							"menu-item",
							"power-monitor",
							"power-save-blocker",
							"protocol",
							"session",
							"web-contents",
							"tray",
							"clipboard",
							"crash-reporter",
							"native-image",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				case "electron-renderer":
					JsonpTemplatePlugin = require("./JsonpTemplatePlugin");
					NodeTargetPlugin = require("./node/NodeTargetPlugin");
					ExternalsPlugin = require("./ExternalsPlugin");
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"desktop-capturer",
							"electron",
							"ipc",
							"ipc-renderer",
							"remote",
							"web-frame",
							"clipboard",
							"crash-reporter",
							"native-image",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				default:
					throw new Error("Unsupported target '" + options.target ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webpack.webpack_web.WebpackOptionsDefaulter" id="apidoc.element.webpack.webpack_web.WebpackOptionsDefaulter">
        function <span class="apidocSignatureSpan">webpack.webpack_web.</span>WebpackOptionsDefaulter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebpackOptionsDefaulter extends OptionsDefaulter {
	constructor() {
		super();
		this.set("devtool", false);
		this.set("cache", true);

		this.set("context", process.cwd());
		this.set("target", "web");

		this.set("module.unknownContextRequest", ".");
		this.set("module.unknownContextRegExp", false);
		this.set("module.unknownContextRecursive", true);
		this.set("module.unknownContextCritical", true);
		this.set("module.exprContextRequest", ".");
		this.set("module.exprContextRegExp", false);
		this.set("module.exprContextRecursive", true);
		this.set("module.exprContextCritical", true);
		this.set("module.wrappedContextRegExp", /.*/);
		this.set("module.wrappedContextRecursive", true);
		this.set("module.wrappedContextCritical", false);
		this.set("module.strictExportPresence", false);

		this.set("module.unsafeCache", true);

		this.set("output", "call", (value, options) =&gt; {
			if(typeof value === "string") {
				return {
					filename: value
				};
			} else if(typeof value !== "object") {
				return {};
			} else {
				return value;
			}
		});
		this.set("output.filename", "[name].js");
		this.set("output.chunkFilename", "make", (options) =&gt; {
			const filename = options.output.filename;
			return filename.indexOf("[name]") &gt;= 0 ? filename.replace("[name]", "[id]") : "[id]." + filename;
		});
		this.set("output.library", "");
		this.set("output.hotUpdateFunction", "make", (options) =&gt; {
			return Template.toIdentifier("webpackHotUpdate" + options.output.library);
		});
		this.set("output.jsonpFunction", "make", (options) =&gt; {
			return Template.toIdentifier("webpackJsonp" + options.output.library);
		});
		this.set("output.libraryTarget", "var");
		this.set("output.path", process.cwd());
		this.set("output.sourceMapFilename", "[file].map[query]");
		this.set("output.hotUpdateChunkFilename", "[id].[hash].hot-update.js");
		this.set("output.hotUpdateMainFilename", "[hash].hot-update.json");
		this.set("output.crossOriginLoading", false);
		this.set("output.hashFunction", "md5");
		this.set("output.hashDigest", "hex");
		this.set("output.hashDigestLength", 20);
		this.set("output.devtoolLineToLine", false);
		this.set("output.strictModuleExceptionHandling", false);

		this.set("node", {});
		this.set("node.console", false);
		this.set("node.process", true);
		this.set("node.global", true);
		this.set("node.Buffer", true);
		this.set("node.setImmediate", true);
		this.set("node.__filename", "mock");
		this.set("node.__dirname", "mock");

		this.set("performance.maxAssetSize", 250000);
		this.set("performance.maxEntrypointSize", 250000);
		this.set("performance.hints", false);

		this.set("resolve", {});
		this.set("resolve.unsafeCache", true);
		this.set("resolve.modules", ["node_modules"]);
		this.set("resolve.extensions", [".js", ".json"]);
		this.set("resolve.aliasFields", "make", (options) =&gt; {
			if(options.target === "web" || options.target === "webworker")
				return ["browser"];
			else
				return [];
		});
		this.set("resolve.mainFields", "make", (options) =&gt; {
			if(options.target === "web" || options.target === "webworker")
				return ["browser", "module", "main"];
			else
				return ["module", "main"];
		});
		this.set("resolveLoader", {});
		this.set("resolveLoader.unsafeCache", true);
		this.set("resolveLoader.mainFields", ["loader", "main"]);
		this.set("resolveLoader.extensions", [".js", ".json"]);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>